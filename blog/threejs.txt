1:HL["/_next/static/media/0c7e3e2387401c47-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
2:HL["/_next/static/css/6566b64e7f0e478f.css","style",{"crossOrigin":""}]
0:["6rRi4gyJWW1lEIwhXfR43",[[["",{"children":["blog",{"children":[["category","threejs","d"],{"children":["__PAGE__?{\"category\":\"threejs\"}",{}]}]}]},"$undefined","$undefined",true],"$L3",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/6566b64e7f0e478f.css","precedence":"next","crossOrigin":""}]],"$L4"]]]]
5:I[9248,["576","static/chunks/576-dc377cf448834f03.js","251","static/chunks/251-ef7560cc4f7a9f6d.js","185","static/chunks/app/layout-5bdea2f994faa404.js"],""]
6:I[179,["576","static/chunks/576-dc377cf448834f03.js","251","static/chunks/251-ef7560cc4f7a9f6d.js","185","static/chunks/app/layout-5bdea2f994faa404.js"],""]
7:I[6962,["576","static/chunks/576-dc377cf448834f03.js","251","static/chunks/251-ef7560cc4f7a9f6d.js","185","static/chunks/app/layout-5bdea2f994faa404.js"],""]
8:I[6954,[],""]
9:I[7264,[],""]
3:[null,["$","html",null,{"lang":"ko","children":["$","body",null,{"className":"__className_7bb6ba","children":["$","div",null,{"className":"w-full\n            h-full\n            overflow-y-scroll\n            overflow-x-auto","children":["$","$L5",null,{"children":[["$","$L6",null,{}],["$","$L7",null,{"style":{"minHeight":"calc(100% - 72px)"},"children":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L9",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"childProp":{"current":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L9",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":[null,"$La",null],"segment":["category","threejs","d"]},"styles":null}],"segment":"blog"},"styles":null}]}]]}]}]}]}],null]
4:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"Chocobe Blog v2"}],["$","meta","3",{"name":"description","content":"Frontend 기술 블로그 입니다."}],["$","link","4",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}],["$","meta","5",{"name":"next-size-adjust"}]]
b:I[689,["281","static/chunks/08ffe114-a8e3ed06beefbf38.js","465","static/chunks/48507feb-6de01ca04009bb96.js","306","static/chunks/39209d7c-a33d4549f726b4ab.js","576","static/chunks/576-dc377cf448834f03.js","251","static/chunks/251-ef7560cc4f7a9f6d.js","75","static/chunks/app/blog/%5Bcategory%5D/layout-7ae3540a4673a57a.js"],""]
a:["$","div",null,{"children":["$","div",null,{"className":"w-full\n                    flex items-start","children":[["$","$Lb",null,{"className":"shrink-0\n                        ml-auto\n                        h-[calc(100vh-72px)]\n                        sticky top-[72px]\n                        overflow-auto\n                        max-[600px]:w-0","navTitle":"블로그 카테고리"}],["$","div",null,{"style":{"maxWidth":"980px"},"className":"flex-1\n                        mr-auto\n                        w-full\n                        overflow-x-hidden","children":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children",["category","threejs","d"],"children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L9",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$Lc","$Ld",null],"segment":"__PAGE__?{\"category\":\"threejs\"}"},"styles":null}]}]]}]}]
c:null
e:I[2317,["576","static/chunks/576-dc377cf448834f03.js","251","static/chunks/251-ef7560cc4f7a9f6d.js","128","static/chunks/128-a9a4b8134fdbdc1d.js","254","static/chunks/app/blog/%5Bcategory%5D/page-864fbedea356ae73.js"],""]
f:T5076,---
id: 1
title: Three.js 설치 및 실행
description: 'Three.js 를 사용하기 위한 설치와 첫번째 화면을 그려봅니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: true
tags: [
    'threejs',
    'javascript',
    '3d',
]

createdAt: '2023-12-31 22:47:00'
modifiedHistories: []
---

# Three.js 설치 및 실행

일반적인 웹페이지는 2D 기반으로 구현합니다.

이러한 웹페이지는 서비스를 제공하거나 정보 공유를 목적으로 충분합니다.

만약 이렇게 보편적으로 사용하는 2D 웹페이지에 3D 환경을 더한다면, 서비스나 제품의 브렌딩에 차별점을 줄 수 있을 것 같습니다.

<br />

Three.js 를 스터디하며, 이 블로그의 Profile 페이지를 구현하는 것을 첫번째 목표로 하여 포스팅을 해보려 합니다.



<br />



## Vite 프로젝트 생성하기

Three.js 를 사용하기 위해, VanillaJS 환경의 프로젝트를 생성해 보겠습니다.

Webpack 을 사용하여 프로젝트를 만들어도 되지만, 프로젝트 구성에 투자되는 리소스가 많아지므로, Vite 를 사용하여 프로젝트를 생성해보겠습니다.

```bash title="Vite 프로젝트 생성"
yarn create vite --template vanilla my-threejs

cd my-threejs

yarn install
```



<br />



## Three.js 설치하기

프로젝트를 생성한 후, Three.js 를 설치합니다.

```bash title="Three.js 설치"
yarn install three
```



<br />



## Three.js 기본 구조 구성하기

Three.js 는 **WebGL** 을 기반으로 동작합니다.

이는 **HTML Canvas API** 를 사용하여 그리는 방식입니다.

Three.js 로 화면을 그리기 위한 기본 과정을 살펴보면 다음과 같습니다.

1. `<canvas />` 태그 생성
2. **WebGLRenderer** 객체 생성
3. 카메라 생성
4. 조명 생성
5. **Scene** 객체 생성
6. 위에서 생성한 객체들을 조합하여 **WebGLRenderer** 에 적용
7. `requestAnimationFrame()` 을 사용하여 `<canvas />` 렌더링

<br />

위 과정은 아래와 같이 함수를 생성하여 구현해 보겠습니다.

1. `init()` 함수 만들기: 1번 ~ 6번 과정을 처리합니다.
2. `render()` 함수 만들기: 7번 과정을 처리합니다.



<br />



## 1. `<canvas />` 태그 생성

먼저 Three.js 를 렌더링할 `<canvas />` 태그를 생성하는 로직을 구현해 보겠습니다.

```js title="main.js" showLineNumber
function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);
}

init();
```



<br />



## 2. **WebGLRenderer** 객체 생성

**WebGLRenderer** 객체는 Three.js 의 코어 역할을 합니다.

위에서 생성한 `<canvas />` 를 인자로 넘겨주어 렌더링 대상을 지정해 줍니다.

```js title="main.js" showLineNumbers {2, 5-6, 15-18}
import {
    WebGLRenderer,
} from 'three';

/** @type { WebGLRenderer } */
let renderer;

function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    // 2. WebGLRenderer 객체 생성
    renderer = new WebGLRenderer({
        canvas: $canvas,
    });
}

init();
```



<br />



## 3. 카메라 생성

Three.js 가 실제로 화면에 렌더링하는 것은 `Camera` 가 비추는 곳이 됩니다.

따라서 Three.js 에 사용할 카메라 객체를 생성해 줍니다.

```js title="main.js" showLineNumbers {3, 9-10, 24-25}
import {
    WebGLRenderer,
    PerspectiveCamera,
} from 'three';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    // 2. `WebGLRenderer` 객체 생성
    renderer = new WebGLRenderer({
        canvas: $canvas,
    });

    // 3. 카메라 생성
    camera = new PerspectiveCamera();
}

init();
```



<br />



## 4. 조명 생성

이번에는 조명 객체인 **DirectionalLight** 객체를 생성해 보겠습니다.

현실 세계에서도 빛이 있어야 물체를 볼 수 있듯이, Three.js 에서도 조명이 있어야 물체가 렌더링 됩니다.

조명은 여러가지가 있는데, 이 중 햇빛처럼 직선의 일정한 양의 빛을 나타내는 **DirectionalLight** 객체를 사용해 보겠습니다.

```js title="main.js" showLineNumbers {4, 28-29}
import {
    WebGLRenderer,
    PerspectiveCamera,
    DirectionalLight,
} from 'three';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    // 2. `WebGLRenderer` 객체 생성
    renderer = new WebGLRenderer({
        canvas: $canvas,
    });

    // 3. 카메라 생성
    camera = new PerspectiveCamera();

    // 4. 조명 생성
    const light = new DirectionalLight();
}

init();
```



<br />



## 5. **Scene** 객체 생성

무대는 `Scene` 객체로 만들 수 있습니다.

`Scene` 객체는 `add()` 메서드를 사용하여 위에서 만들었던 조명과 물체(Mesh)들을 적용할 수 있습니다.

<br />

`Scene` 객체를 생성하고 조명을 적용해 보겠습니다.

```js title="main.js" showLineNumbers {5, 14-15, 35-37}
import {
    WebGLRenderer,
    PerspectiveCamera,
    DirectionalLight,
    Scene,
} from 'three';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

/** @type { Scene } */
let scene;

function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    // 2. `WebGLRenderer` 객체 생성
    renderer = new WebGLRenderer({
        canvas: $canvas,
    });

    // 3. 카메라 생성
    camera = new PerspectiveCamera();

    // 4. 조명 생성
    const light = new DirectionalLight();

    // 5. `Scene` 객체 생성
    scene = new Scene();
    scene.add(light);
}

init();
```



<br />



## 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용

이제 Three.js 를 실행하여 화면을 그릴 준비가 되었습니다.

**WebGLRenderer** 는 **Scene(무대)** 와 **카메라** 를 사용하여 화면을 그리는 역할을 하게 됩니다.

```js title="main.js" showLineNumbers {39-40}
import {
    WebGLRenderer,
    PerspectiveCamera,
    DirectionalLight,
    Scene,
} from 'three';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

/** @type { Scene } */
let scene;

function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    // 2. `WebGLRenderer` 객체 생성
    renderer = new WebGLRenderer({
        canvas: $canvas,
    });

    // 3. 카메라 생성
    camera = new PerspectiveCamera();

    // 4. 조명 생성
    const light = new DirectionalLight();

    // 5. `Scene` 객체 생성
    scene = new Scene();
    scene.add(light);

    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용
    renderer.render(scene, camera);
}

init();
```



<br />



## 7. `requestAnimationFrame()` 을 사용하여 `<canvas />` 렌더링

이번에는 `init()` 의 마지막에 호출할 `render()` 함수를 만들고, Three.js 를 실행하여 브라우저에서 결과를 확인해 보겠습니다.

추가할 `render()` 함수는 `requestAnimationFrame()` 을 사용하여 `render()` 함수를 재귀 호출하도록 하는데, 이는 브라우저에서 **60fps 로 실행하며 화면을 업데이트** 하게 됩니다.

```js title="main.js" showLineNumbers {42-43, 46-50}
import {
    WebGLRenderer,
    PerspectiveCamera,
    DirectionalLight,
    Scene,
} from 'three';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

/** @type { Scene } */
let scene;

function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    // 2. `WebGLRenderer` 객체 생성
    renderer = new WebGLRenderer({
        canvas: $canvas,
    });

    // 3. 카메라 생성
    camera = new PerspectiveCamera();

    // 4. 조명 생성
    const light = new DirectionalLight();

    // 5. `Scene` 객체 생성
    scene = new Scene();
    scene.add(light);

    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용
    renderer.render(scene, camera);

    // 7. requestAnimationFrame() 을 사용하여 <canvas /> 렌더링
    render();
}

function render() {
    renderer.render(scene, camera);

    requestAnimationFrame(render);
}

init();
```



<br />



## 추가: Scene 에 SphereMesh 추가하기

지금까지 작성한 코드를 실행하면, 검은색 화면만 보이게 됩니다.

이는 실제로 화면에 그릴 물체(Mesh) 가 없기 때문에 그릴 대상이 없는 현상입니다.

<br />

위에서 구성한 Three.js 가 잘 동작하는지 테스트를 위해 구형 물체(Sphere Mesh) 를 생성하고, 적용해 보겠습니다.

```js title="main.js" showLineNumbers {7-9, 48-49, 61-67}
import {
    WebGLRenderer,
    PerspectiveCamera,
    DirectionalLight,
    Scene,

    SphereGeometry,
    MeshPhongMaterial,
    Mesh,
} from 'three';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

/** @type { Scene } */
let scene;

function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    // 2. `WebGLRenderer` 객체 생성
    renderer = new WebGLRenderer({
        canvas: $canvas,
    });

    // 3. 카메라 생성
    camera = new PerspectiveCamera();
    camera.position.set(0, 0, 10);

    // 4. 조명 생성
    const light = new DirectionalLight();
    light.position.set(1, 1, 1);

    // 5. `Scene` 객체 생성
    scene = new Scene();
    scene.add(light);

    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용
    renderer.render(scene, camera);

    // 추가: Schene 에 SphereMesh 추가하기
    createSphereMesh();

    // 7. requestAnimationFrame() 을 사용하여 <canvas /> 렌더링
    render();
}

function render() {
    renderer.render(scene, camera);

    requestAnimationFrame(render);
}

function createSphereMesh() {
    const sphere_geometry = new SphereGeometry();
    const sphere_material = new MeshPhongMaterial();
    const sphere_mesh = new Mesh(sphere_geometry, sphere_material);

    scene.add(sphere_mesh);
}

init();
```

<br />

`createSphereMesh()` 함수에서 3가지 객체를 생성하고 있습니다.

이는 컴퓨터 그래픽스에서 3D 물체를 표현하기 위한 요소들 입니다.

* Geometry: 색이 없는 모델링 객체
* Material: 모델링 객체의 색상 또는 질감
* Mesh: Geometry 와 Material 을 합친 결과 모델링 객체

`sphere_mesh` 객체의 `add()` 메소드를 사용하여 **Geometry** 와 **Material** 을 합쳐서 하나의 **Mesh** 를 만들 수 있게 됩니다.

<br />

지금까지 작성한 코드를 실행하면 다음과 같은 결과물을 볼 수 있습니다.

<img src="/markdownAssets/threejs/2023-12-31-01/2023-12-31-01-01.png" alt="Threejs 실행 결과" />



<br />



## 추가: `<canvas />` 를 전체화면으로 설정하기

위 결과물을 확인하면, `<canvas />` 요소가 inline 으로 렌더링되고 있습니다.

이는 **WebGLRenderer** 객체의 **size** 를 조정하여 전체화면으로 설정할 수 있습니다.

그리고 `<canvas />` 의 기본 스타일인 `display: inline` 을 `display: block` 으로 변경합니다.

```css title="style.css" showLineNumbers
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

canvas {
    display: block;
}
```

```js title="main.js" showLineNumbers {11, 33-36}
import {
    WebGLRenderer,
    PerspectiveCamera,
    DirectionalLight,
    Scene,

    SphereGeometry,
    MeshPhongMaterial,
    Mesh,
} from 'three';
import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

/** @type { Scene } */
let scene;

function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    // 2. `WebGLRenderer` 객체 생성
    renderer = new WebGLRenderer({
        canvas: $canvas,
    });
    renderer.setSize(
        window.innerWidth,
        window.innerHeight
    );

    // 3. 카메라 생성
    camera = new PerspectiveCamera();
    camera.position.set(0, 0, 10);

    // 4. 조명 생성
    const light = new DirectionalLight();
    light.position.set(1, 1, 1);

    // 5. `Scene` 객체 생성
    scene = new Scene();
    scene.add(light);

    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용
    renderer.render(scene, camera);

    // 추가: Schene 에 SphereMesh 추가하기
    createSphereMesh();

    // 7. requestAnimationFrame() 을 사용하여 <canvas /> 렌더링
    render();
}

function render() {
    renderer.render(scene, camera);

    requestAnimationFrame(render);
}

function createSphereMesh() {
    const sphere_geometry = new SphereGeometry();
    const sphere_material = new MeshPhongMaterial();
    const sphere_mesh = new Mesh(sphere_geometry, sphere_material);

    scene.add(sphere_mesh);
}

init();
```

<br />

이렇게 적용한 결과는 다음과 같습니다.

<img src="/markdownAssets/threejs/2023-12-31-01/2023-12-31-01-02.png" alt="전체화면 적용" />



<br />



## 추가: 찌그러진 화면 보정하기

Scene 에 추가한 모델링은 구(Sphere) 입니다.

하지만 결과 화면에서 보여지는 구는 타원형으로 보여집니다.

원인은 아래와 같습니다. 

* **카메라의 종횡비(aspect radio)** 설정을 하지 않았으므로, 기본값인 **1** 로 설정됨
* 브라우저의 종횡비가 1:1 이 아닌 상태에서 `<canvas />` 를 전체화면으로 늘리면서 발생하는 화면 늘어짐

<br />

이를 해결하기 위해 **카메라의 종횡비(aspect radio)** 를 설정해줍니다.

```js title="main.js" showLineNumbers {39-42}
import {
    WebGLRenderer,
    PerspectiveCamera,
    DirectionalLight,
    Scene,

    SphereGeometry,
    MeshPhongMaterial,
    Mesh,
} from 'three';
import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

/** @type { Scene } */
let scene;

function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    // 2. `WebGLRenderer` 객체 생성
    renderer = new WebGLRenderer({
        canvas: $canvas,
    });
    renderer.setSize(
        window.innerWidth,
        window.innerHeight
    );

    // 3. 카메라 생성
    camera = new PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight
    );
    camera.position.set(0, 0, 10);

    // 4. 조명 생성
    const light = new DirectionalLight();
    light.position.set(1, 1, 1);

    // 5. `Scene` 객체 생성
    scene = new Scene();
    scene.add(light);

    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용
    renderer.render(scene, camera);

    // 추가: Schene 에 SphereMesh 추가하기
    createSphereMesh();

    // 7. requestAnimationFrame() 을 사용하여 <canvas /> 렌더링
    render();
}

function render() {
    renderer.render(scene, camera);

    requestAnimationFrame(render);
}

function createSphereMesh() {
    const sphere_geometry = new SphereGeometry();
    const sphere_material = new MeshPhongMaterial();
    const sphere_mesh = new Mesh(sphere_geometry, sphere_material);

    scene.add(sphere_mesh);
}

init();
```

<br />

`PerspectiveCamera` 생성자에 인자로 2가지를 넘겨주었습니다.

인자 타입은 다음과 같습니다.

```ts title="Perspective 생성자의 인자"
class PerspectiveCamera {
    constructor(
        fov: number,
        aspect: number
    ) {
        // ...
    }
}
```

**fov (Field of View)** 는 **카메라의 왜곡 정도값**을 말합니다.

이는 **렌즈 배율** 과 **Sensor-size** 에 대한 연산값이며, **화각을 수치화** 한 것입니다.

값이 클수록 멀리서 보는 느낌의 효과가 발생합니다.

<br />

두번째 인자인 **aspect** 는 **카메라 종횡비(aspect ratio)** 에 대한 설정입니다.

화면의 **가로 / 세로** 비율을 나타내므로, `window.innerWidth / window.innerHeight` 로 값을 도출할 수 있습니다.

<br />

이렇게 설정한 결과물은 아래와 같습니다.

<img src="/markdownAssets/threejs/2023-12-31-01/2023-12-31-01-03.png" alt="전체화면 적용" />



<br />



## 추가: **계단 효과** 보정하기

모니터는 Pixel 에 RGB 를 발사하여 화면을 그립니다.

이 Pixel 은 정사각형 모양이기 때문에 곡선을 렌더링하게 되면 마치 계단처럼 각진 곡선으로 표현됩니다.

**WebGLRenderer** 객체를 생성하며 options 를 통해 계단 효과를 보정할 수 있습니다.

<br />

컴퓨터 그래픽스에서 계단 효과를 해소하는 기법을 간단하게 설명하면, 곡선이 아닌 부분을 흐림(blur) 처리하여 마치 자연스러운 곡선처럼 표현해 줍니다.

이러한 기법을 **Anti-Aliasing** 이라고 합니다.

```js title="main.js" showLineNumbers {32}
import {
    WebGLRenderer,
    PerspectiveCamera,
    DirectionalLight,
    Scene,

    SphereGeometry,
    MeshPhongMaterial,
    Mesh,
} from 'three';
import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

/** @type { Scene } */
let scene;

function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    // 2. `WebGLRenderer` 객체 생성
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });
    renderer.setSize(
        window.innerWidth,
        window.innerHeight
    );

    // 3. 카메라 생성
    camera = new PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight
    );
    camera.position.set(0, 0, 10);

    // 4. 조명 생성
    const light = new DirectionalLight();
    light.position.set(1, 1, 1);

    // 5. `Scene` 객체 생성
    scene = new Scene();
    scene.add(light);

    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용
    renderer.render(scene, camera);

    // 추가: Schene 에 SphereMesh 추가하기
    createSphereMesh();

    // 7. requestAnimationFrame() 을 사용하여 <canvas /> 렌더링
    render();
}

function render() {
    renderer.render(scene, camera);

    requestAnimationFrame(render);
}

function createSphereMesh() {
    const sphere_geometry = new SphereGeometry();
    const sphere_material = new MeshPhongMaterial();
    const sphere_mesh = new Mesh(sphere_geometry, sphere_material);

    scene.add(sphere_mesh);
}

init();
```



## 마치며

Three.js 를 실행하기 위한 최소 구성요소를 구현해 보았습니다.

뭔가 복잡해 보이지만 현실 세계의 무대를 만드는 것과 유사한 개념으로 만들고 있습니다.

* `WebGLRenderer`: 무대를 구성할 건물
* `Scene`: 무대
* `PerspectiveCamera`: 카메라
* `DirectionalLight`: 조명
* `Mesh`: 배경, 배우, 소품

<br />

Three.js 를 처음 시작하며 제가 느낀 어려움으로는 컴퓨터 그래픽스 개념과 카메라에 대한 이해였습니다.

단순히 Three.js 사용법을 익히는 것만으로 원하는 결과물을 얻기는 어려워 보입니다.

지금까지의 코딩에 비해 학습 난이도는 높지만, 새로운 성취감과 즐거움이 기대됩니다.
10:T1f1c,---
id: 7
title: 모델 파일을 Three.js 에 렌더링하기
description: '.gltf 또는 .glb 확장자인 모델 파일을 Three.js 에 불러오고 렌더링하는 방법을 정리합니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'threejs',
    'javascript',
    '3d',
    'hdr',
    '.gltf',
    '.glb',
    'model',
]

createdAt: '2024-01-10 23:50:00'
modifiedHistories: []
---

# 모델 파일을 Three.js 에 렌더링하기

3D 모델 파일의 확장자는 아래와 같습니다.

* .gltf
    * 3D 모델 파일이며 JSON 형식의 데이터입니다.
* .glb
    * 3D 모델 파일이며 Binary 데이터입니다.
    * **3D 모델을 렌더링하여 사용할 목적이라면, .glb 파일의 용량이 더 적으므로 적합합니다.**

<br />

이번 포스팅에서는 3D 모델 파일을 Three.js 에 렌더링하는 방법과 불러온 모델 객체를 수정하는 방법에 대해 정리하고자 합니다.



<br />



## 용어 정리

### Luminance

Luminance 는 **휘도** 라는 뜻을 가집니다.

Three.js 에서는 **emissive** 가 **빛을 방출하는 정도에 대한 속성** 이지만, 3D Tool 중 Cinema4D 에서는 **Luminance** 로 표기되어 있습니다.



<br />



## 예시 코드

이번 포스팅에서 사용할 예시 코드는 다음과 같습니다.

```js title="예시 코드" showLineNumbers
import {
    WebGLRenderer,
    Scene,
    PerspectiveCamera,

    Color,
    DirectionalLight,
    HemisphereLight,

    SphereGeometry,
    MeshStandardMaterial,
    Mesh,
} from 'three';
import {
    OrbitControls,
} from 'three/examples/jsm/controls/OrbitControls';
import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { Scene } */
let scene;

/** @type { PerspectiveCamera } */
let camera;

/** @type { OrbitControls } */
let controls;

//
// core
//
function initCanvas() {
    const $canvas = document.createElement('canvas');
    $canvas.width = window.innerWidth;
    $canvas.height = window.innerHeight;

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    return $canvas;
}

function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });

    renderer.shadowMap.enabled = true;
}

function initScene() {
    scene = new Scene();
}

function initCamera() {
    camera = new PerspectiveCamera();
    camera.fov = 35;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.position.set(0, 0, 2);

    camera.updateProjectionMatrix();
}

function initControls($emitter) {
    controls = new OrbitControls(camera, $emitter);
    controls.enableDamping = true;
}

//
// light
//
function initDirectionalLight() {
    const color = new Color('#fff');

    const light = new DirectionalLight(color);
    light.position.set(1, 1, 1);
    light.castShadow = true;

    scene.add(light);
}

function initHemisphereLight() {
    const skyColor = new Color('#fff');
    const groundColor = new Color('#000');

    const light = new HemisphereLight(
        skyColor,
        groundColor,
        0.25
    );

    scene.add(light);
}

//
// mesh
//
function initSphereMesh() {
    const geometry = new SphereGeometry();
    const material = new MeshStandardMaterial();
    const sphere = new Mesh(geometry, material);

    scene.add(sphere);
}

//
// executor
//
function render() {
    window.requestAnimationFrame(render);

    renderer.render(scene, camera);
    controls.update();
}

function init() {
    const $canvas = initCanvas();

    initRenderer($canvas);
    initScene();
    initCamera();
    initControls($canvas);

    initDirectionalLight();
    initHemisphereLight();

    initSphereMesh();

    render();
}

init();
```



<br />



## GLTFLoader 를 사용하여 3D 모델 파일 불러오기

.glb 또는 .gltf 파일을 불러오기 위해서는 Loader 가 필요합니다.

이 때 사용하는 Loader 는 GLTFLoader 인스턴스 입니다.

아래는 .gltf 파일을 불러온 후, 불러온 모델 객체를 `console.log()` 로 출력하고 있습니다.

```js title="GLTFLoader import 하기" showLineNumbers{17}
import {
    GLTFLoader,
} from 'three/examples/jsm/loaders/GLTFLoader';
```

```js title="GLTFLoader 로 .gltf 파일 불러오기" showLineNumbers{112}
function initRubberDuck() {
    const loader = new GLTFLoader();
    loader.load('/gltf/rubberDuck/rubber_duck_toy_4k.gltf', gltf => {
        console.group('onLoad()');
        console.log('gltf: ', gltf);
        console.groupEnd();
    });
}
```

```js title="iniRubberDuct 함수 호출" showLineNumbers{131} {13}
function init() {
    const $canvas = initCanvas();

    initRenderer($canvas);
    initScene();
    initCamera();
    initControls($canvas);

    initDirectionalLight();
    initHemisphereLight();

    initSphereMesh();
    initRubberDuck();

    render();
}
```

<br />

부라우저 콘솔에서 확인하면, GLTFLoader 가 불러온 3D 모델 객체를 확인할 수 있습니다.



## 불러온 3D 모델 객체 렌더링하기

불러온 3D 모델 객체에는 **scene 속성** 이 있습니다.

**scene 속성** 을 Mesh 와 동일하게 취급할 수 있습니다.

따라서 기존의 sphere Mesh 를 `scene.add()` 메서드로 추가했던 것과 동일한 방법으로 `scene` 에 추가할 수 있습니다.

```js title="3D 모델 객체 렌더링" showLineNumbers{112} {8-9}
function initRubberDuck() {
    const loader = new GLTFLoader();
    loader.load('/gltf/rubberDuck/rubber_duck_toy_4k.gltf', gltf => {
        console.group('onLoad()');
        console.log('gltf: ', gltf);
        console.groupEnd();

        gltf.scene.position.set(0, -0.15, 0);
        scene.add(gltf.scene);
    });
}
```

<img src="/markdownAssets/threejs/2024-01-10-01/2024-01-10-01-01.png" alt="3D 모델 렌더링" />



<br />



## 추가: 불렁론 3D 모델이 깨지는 현상

3D 모델을 Three.js 에 렌더링했을 때, 깨지는 현상이 발생할 수 있습니다.

이는 3D Tool(예: Cinema4D, Blender) 를 사용하여, 모델의 **Material** 을 수정하여 해결할 수 있습니다.

가장 유력한 케이스는 **Material** 설정 중, **Alpha** 설정이 활성화된 경우 입니다.

만약 **Alpha** 설정이 활성화되어 있었다면, 해제 후 export 한 파일을 사용해봅니다.

<br />

Three.js 는 브라우저 환경에서 동작하기 때문에 3D Tool 의 무거운 기능들은 지원하지 않습니다.

이러한 현상이 나타난다면, **Material** 을 좀 더 가볍게 하면 해소할 수 있습니다.



<br />



## 3D 모델 객체 구조 살펴보기

Three.js 에 불러온 3D 모델을 그대로 렌더링했을 때, 원하는 결과를 얻지 못할 가능성이 큽니다.

특히 그림자 설정은 3D 모델을 개발할 때 설정하는 것이 아닌, Three.js 에 렌더링할 객체의 설정이 필요한 경우입니다.

이러한 이유로 Three.js 에 불러온 3D 모델 객체의 주요 속성들을 수정하기 위해, 먼저 속성들을 살펴보겠습니다.

<br />

GLTFLoader 로 불러운 3D 모델을 gltf 로 칭하겠습니다.

gltf 객체는 크게 다음과 같은 속성이 있습니다.

* scene
    * Mesh 처럼 다룰 수 있으며, 렌더링할 때도 사용합니다.
* animations
    * 애니메이션 객체 입니다.
* children
    * 3D Tool 로 개발할 때 만든 부모-자식 계층 입니다.
* material
    * 현재 Mesh 의 Material 설정입니다.

<br />

gltf 객체의 scene 과 children 의 중첩구조를 살펴보면 크게 2가지 타입으로 이루어져 있습니다.

* Mesh
    * 실제 Mesh 객체입니다.
* Object3D
    * Mesh 가 아닌 기타 타입입니다.
    * 3D Tool 의 Symmetry(대칭복사), Subdivision(곡선생성) 등의 기능으로 만든 부분 (엄밀히 Mesh 는 아니기 때문)



<br />



## 3D 모델 객체 수정하기
11:T3408,---
id: 6
title: 배경화면 및 환경조명 설정하기
description: '360도 이미지 확장자인 .hdr 파일을 사용하여 배경화면을 설정하고, 배경화면에 의한 환경조명 설정에 대한 정리입니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'threejs',
    'javascript',
    '3d',
    'hdr',
    'background',
    '3D 배경화면',
    '환경조명',
]

createdAt: '2024-01-08 23:50:00'
modifiedHistories: []
---

# 배경화면 및 환경조명 설정하기

지금까지는 배경이 없는 환경에서 물체를 렌더링하였습니다.

3D 환경에서 배경화면을 설정하기 위해 360도 이미지 파일인 **.hdr (Hign Dynamic Range)** 파일을 설정해 보고자 합니다.

<br />

추가로 배경화면이 물체에 반사되는 환경조명까지 설정해 보겠습니다.

환경조명을 설정하게 되면, 배경이 스틸에 반사되는 효과를 연출할 수 있습니다.

이를 위해 **Material** 설정 방법에 대해서도 정리합니다.



<br />



## 예시 코드

이번 포스팅에서 사용할 예시 코드는 다음과 같습니다.

```js title="예시 코드" showLineNumbers
import {
    WebGLRenderer,
    Scene,
    PerspectiveCamera,

    Color,

    DirectionalLight,
    DirectionalLightHelper,
    HemisphereLight,
    HemisphereLightHelper,

    Mesh,
    MeshStandardMaterial,

    SphereGeometry,
    PlaneGeometry,

    VSMShadowMap,
} from 'three';
import {
    OrbitControls,
} from 'three/examples/jsm/controls/OrbitControls';

import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { Scene } */
let scene;

/** @type { PerspectiveCamera } */
let camera;

/** @type { OrbitControls } */
let controls;

//
// core
//
function initCanvas() {
    const $canvas = document.createElement('canvas');
    $canvas.width = window.innerWidth;
    $canvas.height = window.innerHeight;

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    return $canvas;
}

function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });

    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = VSMShadowMap;
}

function initScene() {
    scene = new Scene();
}

function initCamera() {
    camera = new PerspectiveCamera();
    camera.fov = 75;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.position.set(-3, 3, 5);

    camera.updateProjectionMatrix();
}

function initControls($canvas) {
    controls = new OrbitControls(camera, $canvas);
    controls.enableDamping = true;
}

//
// light
//
function initDirectionalLight() {
    const color = new Color('#fff');

    const light = new DirectionalLight(
        color,
        0.75
    );
    light.position.set(1, 1, 1);
    light.castShadow = true;
    light.shadow.blurSamples = 30;
    light.shadow.radius = 12;

    const helper = new DirectionalLightHelper(light);

    scene.add(light);
    scene.add(helper);
}

function initHemisphereLight() {
    const skyColor = new Color('#fff');
    const groundColor = new Color('#000');

    const light = new HemisphereLight(
        skyColor,
        groundColor,
        0.25
    );

    const helper = new HemisphereLightHelper(light);

    scene.add(light);
    scene.add(helper);
}

//
// mesh
//
function initSphereMesh() {
    const geometry = new SphereGeometry();
    const material = new MeshStandardMaterial();
    const sphere = new Mesh(geometry, material);
    sphere.castShadow = true;

    scene.add(sphere);
}

function initPlaneMesh() {
    const geometry = new PlaneGeometry(10, 10);
    const material = new MeshStandardMaterial();
    const plane = new Mesh(geometry, material);
    plane.position.set(0, -1, 0);
    plane.rotation.set(Math.PI / -2, 0, 0);
    plane.receiveShadow = true;

    scene.add(plane);
}

//
// executor
//
function render() {
    window.requestAnimationFrame(render);

    controls.update();
    renderer.render(scene, camera);
}

(function init() {
    const $canvas = initCanvas();
    initRenderer($canvas);
    initScene();
    initCamera();
    initControls($canvas);

    initDirectionalLight();
    initHemisphereLight();

    initSphereMesh();
    initPlaneMesh();

    render();

    console.log('init()');
}());
```



<br />



## **.hdr** 파일이란?

Three.js 는 3D 환경입니다.

배경화면을 설정하려면 일반적인 2D 이미지를 사용해서는 연출할 수 없습니다.

**.hdr (High Dynamic Range)** 확장자를 가진 파일은 360도 이미지 파일이며, 이 파일을 사용하여 3D 환경에 배경화면을 설정할 수 있습니다.

<br />

360도 배경화면은 아래의 플렛폼에서 오픈소스로 다운로드할 수 있습니다.

* [polyhaven.com](https://polyhaven.com/hdris)



<br />



## 용어 정리

이번 포스팅에서 사용하게될 컴퓨터 그래픽스 용어에 대해 간단하게 정리하고 가겠습니다.

### Vertex

3D 공간에서 가장 작은 단위인 **점** 을 말합니다.

### Edge

2개의 Vertex 를 연결하여 생성된 **선** 을 말합니다.

### Polygon

복수의 Edge 를 연결하여 만들어진 **면** 을 말합니다.

가장 작은 Polygon 은 3개의 Edge 로 만들 수 있는 삼각형 입니다.

### Mesh

복수의 Polygon 으로 만들 수 있는 다각형으로, 지금까지 사용해보았던 Sphere, Box, Plane 등을 말합니다.

### Texture

[참고: 나무위키](https://namu.wiki/w/%ED%85%8D%EC%8A%A4%EC%B2%98)

3D 물체의 표면에 2D 이미지를 입혀서 렌더링 하는 방식을 말합니다.

Mesh 를 구성하는 Polygon 이 많을수록 성능을 많이 사용하게 되는데, 이를 해소하기 위해 Mesh 의 표면에 2D 이미지를 입히는 방식의 렌더링 요소 입니다.

### emissive

emission 은 **(빛)방사** 라는 뜻을 가집니다.

컴퓨터 그래픽스에서 **emissive** 라는 용어를 사용하는데, 이는 Mesh 가 광원이 되여 빛을 방출한다는 것을 말합니다.

### (영단어) equirectangular

정사각형

### (영단어) reflection

반사

### (영단어) refraction

굴절



<br />



## RGBELoader 를 사용하여 .hdr 파일을 Texture 로 만들기

3D 공간 자체를 하나의 Mesh 라고 가정해 보겠습니다.

Three.js 에서는 `Scene` 객체가 배경의 역할을 하고 있습니다.

배경화면을 설정하기 위해서는 `Scene` 의 `background` 에 `Texture` 를 입혀서 표현할 수 있습니다.

<br />

Three.js 는 다양한 **DataTextureLoader** 를 제공하는데, Loader 를 사용하면 360도 이미지인 `.hdr` 파일을 읽어서 `Texture` 객체로 만들 수 있습니다.

생성한 `Texture` 를 `Scene` 의 `background` 로 입혀주는 것으로 배경화면을 설정할 수 있습니다.

[Three.js 공식문서 - DataTextureLoader](https://threejs.org/docs/#api/en/loaders/DataTextureLoader)

<br />

```js title="import 하기" showLineNumbers {21, 27}
import {
    WebGLRenderer,
    Scene,
    PerspectiveCamera,

    Color,

    DirectionalLight,
    DirectionalLightHelper,
    HemisphereLight,
    HemisphereLightHelper,

    Mesh,
    MeshStandardMaterial,

    SphereGeometry,
    PlaneGeometry,

    VSMShadowMap,

    EquirectangularReflectionMapping,
} from 'three';
import {
    OrbitControls,
} from 'three/examples/jsm/controls/OrbitControls';
import {
    RGBELoader,
} from 'three/examples/jsm/loaders/RGBELoader';
```

```js title="Scene 에 배경화면 설정하기" showLineNumbers{68} {4-9}
function initScene() {
    scene = new Scene();

    const loader = new RGBELoader();
    loader.load('/hrd/background.hdr', texture => {
        texture.mapping = EquirectangularReflectionMapping;

        scene.background = texture;
    });
}
```

<br />

먼저 import 부분을 살펴보겠습니다.

**EquirectangularReflectionMapping** 은 Texture 의 mapping 방식을 제공하는 **객체** 입니다.

Texture 객체의 `mapping` 속성에 **EquirectangularReflectionMapping** 객체를 대입하는 것으로 mapping 방식을 설정하게 됩니다.

<br />

Three.js 에서 제공하는 Texture mapping 방식은 여러가지가 있습니다.

[Three.js 공식문서 - Texture Constants](https://threejs.org/docs/index.html?q=texture#api/en/constants/Textures)

* UVMapping (default)
* CubeReflectionMapping 
* CubeRefractionMapping
* EquirectangularReflectionMapping
* EquirectangularRefractionMapping 
* CubeUVReflectionMapping

<br />

위에서 사용한 **EquirectangularReflectionMapping** 은 **environment map** 에 사용하는 Texture mapping 방식 입니다.

이 mapping 방식을 사용하게 되면 `.hdr` 이미지가 마치 배경처럼 렌더링됩니다.

<br />

Texture 의 mapping 방식을 설정해준 뒤, **Scene** 의 `background` 속성에 Texture 를 대입하면 배경화면이 렌더링된 것을 볼 수 있습니다.

<img src="/markdownAssets/threejs/2024-01-08-01/2024-01-08-01-01.png" alt="배경화면 설정" />



<br />



## 환경조명 설정

빛이 있어야 물체가 렌더링 됩니다.

지금까지는 DirectionalLight 나 HemisphereLight 처럼 조명 객체를 생성하여 빛을 만들었습니다.

이번에는 조명을 모두 제거하고, 환경조명으로 렌더링하고자 합니다.

<br />

**Scene** 의 `environment` 속성에 환경조명으로 사용할 Texture 를 대입하여 설정할 수 있습니다.

`background` 로 사용했던 Texture 를 환경조명으로도 사용하도록 해보겠습니다.

```js title="환경조명 설정하기" showLineNumbers{68} {9}
function initScene() {
    scene = new Scene();

    const loader = new RGBELoader();
    loader.load('/hdr/background.hdr', texture => {
        texture.mapping = EquirectangularReflectionMapping;

        scene.background = texture;
        scene.environment = texture;
    });
}
```

<img src="/markdownAssets/threejs/2024-01-08-01/2024-01-08-01-02.png" alt="환경조명 설정하기" />

<br />

환경조명으로 설정한 Texture 의 밝은 부분과 어두운 부분이 조명의 세기로 적용되어 배경화면과 자연스러운 연출이 됩니다.



<br />



## 배경화면을 반사하는 Mesh 만들기

Sphere 와 Plane Mesh 를 렌더링하고 있습니다.

현재는 각 Mesh 에 설정한 **MeshStandardMaterial** 색상 그대로 렌더링되는 상태입니다.

이번에는 Mesh 의 Material 에 설정을 추가하여, 배경화면이 Mesh 에 비추어지는 효과를 연출해 보겠습니다.

<br />

Mesh 의 외관은 Material 에 의해 렌더링 결과가 달라집니다.

Material 은 Mesh 의 색상이나 질감을 표현하는 객체입니다.

배경화면을 반사하는 Mesh 를 만들기 위해서는 Material 설정을 사용하여 구현할 수 있습니다.

```js title="배경화면을 반사하는 Mesh 설정하기" showLineNumbers{134} {3-8}
function initSphereMesh() {
    const geometry = new SphereGeometry();
    const material = new MeshStandardMaterial({
        color: new Color('#fff'),
        roughness: 0,
        metalness: 1,
        // emissive: Color('#000'),
    });
    const sphere = new Mesh(geometry, material);
    sphere.castShadow = true;

    scene.add(sphere);
}
```

<img src="/markdownAssets/threejs/2024-01-08-01/2024-01-08-01-03.png" alt="Material 설정" />

<br />

**MeshStandardMaterial** 생성자 params 를 사용하여 Material 를 설정하고 있습니다.

params 의 각 속성은 다음고 같은 설정을 가집니다.

* `color`: 
    * Material 자체의 색상입니다. (Mesh 의 색상이 됩니다.)
* `roughness`: 
    * 배경화면을 반사하는 Mesh 의 질감을 얼만큼 거칠게 표현할지에 대한 설정입니다.
    * `0` 설정 시, 배경화면이 깔끔하게 반사됩니다.
    * `1` 설정 시, 반사되는 배경화면이 분간하기 어려울 정도로 어글어져서 렌더링됩니다.
* `metalness`:
    * 매탈 재질처럼 보이는 정도를 설정합니다.
    * `0` 설정 시, 메탈 느낌 보다는 플라스틱 느낌이 강하며, 함께 설정한 `color` 의 비중이 더 크게 렌더링됩니다.
    * `1` 설정 시, 함께 설정한 `color` 는 거의 보이지 않고, 메탈 느낌으로 렌더링됩니다.
* `emissive`:
    * Mesh(Material) 이 방출하는 빛의 색상을 설정합니다.
    * `밝은색` 설정 시, 광원처럼 밝은 빛을 내며, 자신의 그림자가 거의 생기지 않습니다.
    * `어두운색` 설정 시, 발광하는 빛이 거의 없으며, 자신의 그림자가 비교적 선명하게 생깁니다.
    * 일반적으로 활용도가 떨어지는 설정이라서, 잘 사용하지 않습니다.



<br />



## 마치며

Material 설정을 통해 배경화면을 반사하는 효과를 연출해 보았습니다.

이번에 사용한 반사효과는 배경화면만을 반사하고, Mesh 간의 반사는 렌더링되지 않습니다.

**Post Processing** 기능을 사용하면, 거울처럼 다른 Mesh 와 상호작용하며 반사하는 연출이 가능해집니다.

이 부분은 차후 정리할 예정입니다.

[Three.js 공식문서 - 거울효과 예시](https://threejs.org/examples/?q=mirror#webgl_mirror)
12:T2c06,---
id: 5
title: 그림자 표현하기
description: '그림자 설정방법과 특징에 대해 정리합니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'threejs',
    'javascript',
    '3d',
    'shadow',
]

createdAt: '2024-01-07 23:50:00'
modifiedHistories: []
---

# 그림자 표현하기

그림자를 표현하기 위해서는 물체와 조명의 각도, 그림자의 크기, 형태 등의 상호작용 연산이 필요합니다.

그래서 Three.js 의 그림자 설정의 기본값은 모두 미사용으로 설정되어 있습니다.

이 덕분에 개발자가 원하는 조명과 원하는 물체의 그림자를 직접 지정하여 표현할 수 있습니다.



<br />



## 예시 코드

이전 포스팅에서 바닥(땅) 을 만들었던 코드에 그림자 설정을 추가해 보겠습니다.

```js title="예시 코드" showLineNumbers
import {
    WebGLRenderer,
    Scene,
    PerspectiveCamera,

    Mesh,
    MeshStandardMaterial,
    SphereGeometry,
    PlaneGeometry,

    Color,
    HemisphereLight,
    HemisphereLightHelper,
    DirectionalLight,
    DirectionalLightHelper,
} from 'three';
import {
    OrbitControls,
} from 'three/examples/jsm/controls/OrbitControls';
import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { Scene } */
let scene;

/** @type { PerspectiveCamera } */
let camera;

/** @type { OrbitControls } */
let controls;

function initCanvas() {
    const $canvas = document.createElement('canvas');
    $canvas.width = window.innerWidth;
    $canvas.height = window.innerHeight;

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    return $canvas;
}

function initScene() {
    scene = new Scene();
}

function initCamera() {
    camera = new PerspectiveCamera();
    camera.fov = 35;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.position.set(0, 0, 12);

    camera.updateProjectionMatrix();
}

function initControls($canvas) {
    controls = new OrbitControls(camera, $canvas);
    controls.enableDamping = true;
}

function initHemisphereLight() {
    const skyColor = new Color('#fff');
    const groundColor = new Color('#000');
    const light = new HemisphereLight(
        skyColor,
        groundColor,
        0.75
    );

    const helper = new HemisphereLightHelper(light);

    scene.add(light);
    scene.add(helper);
}

function initDirectionalLight() {
    const color = new Color('#fff');
    const light = new DirectionalLight(color);
    light.position.set(2, 2, 2);

    const helper = new DirectionalLightHelper(light);

    scene.add(light);
    scene.add(helper);
}

function initSphereMesh() {
    const geometry = new SphereGeometry();
    const material = new MeshStandardMaterial();
    const sphere = new Mesh(geometry, material);

    scene.add(sphere);
}

function initPlaneMesh() {
    const geometry = new PlaneGeometry(10, 10);
    const material = new MeshStandardMaterial();
    const plane = new Mesh(geometry, material);
    plane.position.set(0, -1, 0);
    plane.rotation.set(
        Math.PI * -0.5,
        0,
        0
    );

    scene.add(plane);
}

function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });
}

function render() {
    window.requestAnimationFrame(render);

    renderer.render(scene, camera);
    controls.update();
}

(function init() {
    const $canvas = initCanvas();
    initRenderer($canvas);
    initScene();
    initCamera();
    initControls($canvas);

    initHemisphereLight();
    initDirectionalLight();

    initSphereMesh();
    initPlaneMesh();

    render();
}());
```



<br />



## 그림자 종류

Three.js 에서 제공하는 그림자는 크게 2가지로 볼 수 있습니다.

* Hard Shadow: 선명하며 거친 그림자를 표현합니다.
* Soft Shadow: 부드러운 그림자를 표현합니다.

<br />

Soft Shadow 는 그림자에 Blur 를 적용하여 부드럽게 표현합니다.

주의할 점은 Blur 값을 크게 설정할수록 부드럽게 표현하지만, 사용자 PC 의 연산량이 커진다는 것 입니다.

<br />

Three.js 의 그림자 설정은 다음과 같은 과정으로 만들 수 있습니다.

1. Hard Shadow 설정하기
2. Soft Shadow 설정 추가하기



<br />



## 그림자 설정이 필요한 인스턴스들

그림자를 표현하려면 몇가지 설정을 함께 해주어야 합니다.

아래는 그림자 설정이 필요한 인스턴스들 입니다.

* WebGLRenderer 인스턴스
* Light 인스턴스
* Mesh 인스턴스



<br />



## WebGLRenderer 에 shadow 설정하기

WebGLRenderer 는 **ShadowMap** 이라는 메커니즘을 제공합니다.

지금은 컴퓨터 그래픽스에서 그림자를 표현하는 여러 알고리즘 중 한가지 라는 것 정도로 정리하고자 합니다.

* WebGLRenderer shadowMap 은 그림자를 이미지로 생성한 후, 그림자를 씌우는 방식으로 동작합니다.

<br />

아래 코드는 WebGLRenderer 가 그림자를 표현하도록 설정합니다.

```js title="WebGLRenderer 그림자 사용 설정" showLineNumbers{111} {7}
function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });

    renderer.shadowMap.enabled = true;
}
```



<br />



## Light 와 Mesh 의 그림자 설정 (Hard Shadow)

Light 와 Mesh 의 그림자 설정 속성은 동일한 인터페이스를 가집니다.

그림자 설정 속성은 크게 두가지가 있습니다.

* 그림자를 만들어내는 설정: `castShadow`
* 다른 Mesh 의 그림자를 받는 설정: `receiveShadow`

<br />

Light 가 비추는 빛은 다른 Mesh 에 의해 그림자를 생성하게 됩니다.

그러므로 Light 의 **castShadow** 를 `true` 로 설정해줍니다.

```js title="DirectionalLight shadow 설정" showLineNumbers{78} {5}
function initDirectionalLight() {
    const color = new Color('#fff');
    const light = new DirectionalLight(color);
    light.position.set(2, 2, 2);
    light.castShadow = true;

    const helper = new DirectionalLightHelper(light);

    scene.add(light);
    scene.add(helper);
}
```

<br />

빛에 의해 그림자를 만들어내는 Mesh 역시 그림자를 생성하므로, **caseShadow** 를 `true` 로 설정해줍니다.

```js title="Sphere Mesh shadow 설정" showLineNumbers{90} {5}
function initSphereMesh() {
    const geometry = new SphereGeometry();
    const material = new MeshStandardMaterial();
    const sphere = new Mesh(geometry, material);
    sphere.castShadow = true;

    scene.add(sphere);
}
```

<br />

바닥(땅) 을 표현한 Plane Mesh 는 다른 Mesh 의 그림자를 받게 되므로, **receiveShadow** 를 `true` 로 설정해줍니다.

```js title="Plane Mesh shadow 설정" showLineNumbers{99} {12}
function initPlaneMesh() {
    const geometry = new PlaneGeometry(10, 10);
    const material = new MeshStandardMaterial();
    const plane = new Mesh(geometry, material);
    plane.position.set(0, -1, 0);
    plane.rotation.set(
        Math.PI * -0.5,
        0,
        0
    );

    plane.receiveShadow = true;

    scene.add(plane);
}
```

<br />

<img src="/markdownAssets/threejs/2024-01-07-02/2024-01-07-02-01.png" alt="Hard Shadow" />

<br />

지금까지 설정하여 만들어낸 그림자는 **Hard Shadow** 입니다.

Blur 처리를 하지 않기 때문에 선명한 그림자가 그려지고, 곡선에서 픽셀이 보이는 특징이 있습니다.



<br />



## Soft Shadow 설정 추가하기

Hard Shadow 설정을 한 후, WebGLRenderer 의 `shadowMap.type` 을 `VSMShadowMap` 으로 설정하므로써 Soft Shadow 로 표현됩니다.

```js title="VSMShadowMap import 하기" showLineNumbers {16}
import {
    WebGLRenderer,
    Scene,
    PerspectiveCamera,

    Mesh,
    MeshStandardMaterial,
    SphereGeometry,
    PlaneGeometry,

    Color,
    HemisphereLight,
    HemisphereLightHelper,
    DirectionalLight,
    DirectionalLightHelper,
    VSMShadowMap,
} from 'three';
```

```js title="Soft Shadow" showLineNumbers{116} {8}
function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });

    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = VSMShadowMap;
}
```

<br />

위 코드에서 사용한 `VSMShadowMap` 이외에도 다른 종류의 shadowMap 을 사용할 수도 있습니다. (이번 포스팅에서는 `VSMShadowMap` 을 사용합니다.)

[Three.js 공식 문서 - WebGLRenderer.shadowMap](https://threejs.org/docs/index.html?q=webglRenderer#api/en/renderers/WebGLRenderer.shadowMap)

* BasicShadowMap
* PCFShadowMap (default)
* PCFSoftShadowMap
* VSMShadowMap

<br />

위 설정을 추가한 후, 결과를 확인하면 Hard Shadow 와 다른점이 없어 보입니다.

이는 그림자를 생성하는 Light 의 **Blur 정도** 와 **번지는 영역의 Radius** 를 변경하면서 부드러움이 달라지는 것을 확인할 수 있습니다.

```js title="DirectionalLight 의 Blur 와 Radius 설정" showLineNumbers{79} {6-7}
function initDirectionalLight() {
    const color = new Color('#fff');
    const light = new DirectionalLight(color);
    light.position.set(2, 2, 2);
    light.castShadow = true;
    light.shadow.blurSamples = 30;
    light.shadow.radius = 12;

    const helper = new DirectionalLightHelper(light);

    scene.add(light);
    scene.add(helper);
}
```

<img src="/markdownAssets/threejs/2024-01-07-02/2024-01-07-02-02.png" alt="Soft Shadow" />

<br />

Light 의 shadow 설정 시, 주의할 사항은 다음과 같습니다.

* `shadow.blurSamples`: 값이 커질수록 부드러운 그림자를 표현하지만, 필요 성능이 높아집니다.
* `shadow.radius`: 값이 너무 작으면 화면이 깨지는 현상이 있으므로, **10 이상** 설정을 권장합니다.



<br />



## 추가: VSMShadowMap 에 대하여

Soft Shadow 를 표현하기 위해 VSMShadowMaper 을 사용해 보았습니다.

VSMShadowMap 은 곡선에 대한 그림자를 부드럽게 표현할 수 있는 특징을 가졌습니다.

그래서 지금까지 실습했던 Shpere Mesh 의 그림자를 부드럽게 표현할 수 있었습니다.

<br />

만약 Sphere Mesh 가 아닌 Box Mesh 에 VSMShadowMap 을 적용한다면, 그림자가 드리우지 않아야 하는 영역까지 침범하는 현상을 볼 수 있습니다.

이는 VSMShadowMap 의 Blur 처리가 되면서 번지는 그림자가 렌더링된 결과 입니다.

<br />

화면 구성에 Box Mesh 가 많다면, VSMShadowMap 을 사용했을 때 오히려 지저분한 그림자가 만들어질 수 있다는 점을 고려하여 선택해야 합니다.

<img src="/markdownAssets/threejs/2024-01-07-02/2024-01-07-02-03.png" alt="VSMShadow 단점" />



<br />



## 마치며

그림자는 조명과 물제의 상호연산을 사용하기 때문에 연산량이 많이 필요하다고 합니다.

그래서 그림자를 최소한으로 사용할 수 있도록 여러가지 설정을 분리시켜놓은 느낌이 들었습니다.

Three.js 를 활용할 때, 그림자 설정이 성능 최적화 대상이라는 것을 알게 되었습니다.
13:T1a79,---
id: 4
title: 평평한 바닥(땅) 만들기 (Plane Mesh)
description: '바닥을 표현하기 위해 Plane Mesh 를 생성합니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'threejs',
    'javascript',
    '3d',
    'plane',
]

createdAt: '2024-01-07 23:20:00'
modifiedHistories: []
---

# 평평한 바닥(땅) 만들기 (Plane Mesh)

이번 포스팅에서는 바닥(땅) 을 만들어 보겠습니다.

Three.js 에서는 바닥(땅) 을 **Plane Mesh** 로 만들 수 있습니다.

다음 포스팅에서 다룰 그림자를 표현하려면, 바닥(땅) 이 있어야 하므로 별도의 포스팅으로 분리하게 되었습니다.



<br />



## 예시 코드

이번 포스팅에서 사용할 예시 코드는 다음과 같습니다.

```js title="예시 코드" showLineNumbers {96}
import {
    WebGLRenderer,
    Scene,
    PerspectiveCamera,

    Mesh,
    MeshStandardMaterial,
    SphereGeometry,

    Color,
    HemisphereLight,
    HemisphereLightHelper,
    DirectionalLight,
    DirectionalLightHelper,
} from 'three';
import {
    OrbitControls,
} from 'three/examples/jsm/controls/OrbitControls';
import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { Scene } */
let scene;

/** @type { PerspectiveCamera } */
let camera;

/** @type { OrbitControls } */
let controls;

function initCanvas() {
    const $canvas = document.createElement('canvas');
    $canvas.width = window.innerWidth;
    $canvas.height = window.innerHeight;

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    return $canvas;
}

function initScene() {
    scene = new Scene();
}

function initCamera() {
    camera = new PerspectiveCamera();
    camera.fov = 35;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.position.set(0, 0, 12);

    camera.updateProjectionMatrix();
}

function initControls($canvas) {
    controls = new OrbitControls(camera, $canvas);
    controls.enableDamping = true;
}

function initHemisphereLight() {
    const skyColor = new Color('#fff');
    const groundColor = new Color('#000');
    const light = new HemisphereLight(
        skyColor,
        groundColor,
        0.75
    );

    const helper = new HemisphereLightHelper(light);

    scene.add(light);
    scene.add(helper);
}

function initDirectionalLight() {
    const color = new Color('#fff');
    const light = new DirectionalLight(color);
    light.position.set(2, 2, 2);

    const helper = new DirectionalLightHelper(light);

    scene.add(light);
    scene.add(helper);
}

function initSphereMesh() {
    const geometry = new SphereGeometry();
    const material = new MeshStandardMaterial();
    const sphere = new Mesh(geometry, material);

    scene.add(sphere);
}

// 여기에 Plane Mesh(바닥) 을 생성하는 함수를 구현할 예정입니다.

function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });
}

function render() {
    window.requestAnimationFrame(render);

    renderer.render(scene, camera);
    controls.update();
}

(function init() {
    const $canvas = initCanvas();
    initRenderer($canvas);
    initScene();
    initCamera();
    initControls($canvas);

    initHemisphereLight();
    initDirectionalLight();

    initSphereMesh();

    render();
}());
```



<br />



## Plane Mesh 생성 함수 만들기

Plane Mesh 는 **PlaneGeometry** class 를 사용하여 생성할 수 있습니다.

```js title="PlaneGeometry class import 하기" showLineNumbers {9}
import {
    WebGLRenderer,
    Scene,
    PerspectiveCamera,

    Mesh,
    MeshStandardMaterial,
    SphereGeometry,
    PlaneGeometry,

    Color,
    HemisphereLight,
    HemisphereLightHelper,
    DirectionalLight,
    DirectionalLightHelper,
} from 'three';
```

```js title="initPlaneMesh() 함수 구현하기" showLineNumbers{97}
function initPlaneMesh() {
    const geometry = new PlaneGeometry();
    const material = new MeshStandardMaterial();
    const plane = new Mesh(geometry, material);
    plane.position.set(0, -1, 0);

    scene.add(plane);
}
```

```js title="initPlaneMesh 함수 호출하기" showLineNumbers{120} {12}
(function init() {
    const $canvas = initCanvas();
    initRenderer($canvas);
    initScene();
    initCamera();
    initControls($canvas);

    initHemisphereLight();
    initDirectionalLight();

    initSphereMesh();
    initPlaneMesh();

    render();
}());
```

<img src="/markdownAssets/threejs/2024-01-07-01/2024-01-07-01-01.png" alt="PlaneMesh" />



<br />



## Plane Mesh 회전 및 크기 변경하기

위 코드를 실행하면, Sphere 하부에 사각형 물체가 렌더링됩니다.

**width**, **height**, **rotation** 을 변경하여 바닥(땅) 처럼 보이도록 설정해 보겠습니다.

```js title="initPlaneMesh() 함수 구현하기" showLineNumbers{97} {2, 6-10}
function initPlaneMesh() {
    const geometry = new PlaneGeometry(5, 5);
    const material = new MeshStandardMaterial();
    const plane = new Mesh(geometry, material);
    plane.position.set(0, -1, 0);
    plane.rotation.set(
        Math.PI * -0.5, 
        0, 
        0
    );

    scene.add(plane);
}
```

<br />

PlaneGeometry class 는 생성자에 **width** 와 **height** 를 넘겨주어 크기를 설정할 수 있습니다.

```js title="width, height 설정" showLineNumbers{98}
const geometry = new PlaneGeometry(5, 5);
```

<br />

그리고 Plane Mesh 인스턴스의 `rotation.set()` 메소드를 사용하여 회전시킬 수 있습니다.

회전시킬 값은 **Radian** 으로 넘겨주어야 하므로, **Math.PI** 를 사용합니다.

```js title="회전 시키기" showLineNumbers{102} {2}
plane.rotation.set(
    Math.PI * -0.5, 
    0, 
    0
);
```

위 코드에서 X축 회전으로 `Math.PI * -0.5` 를 주었는데, 이는 아래와 같은 Plane Mesh 의 특성으로 고려한 것입니다.

* Plane Mesh 는 한쪽면만 렌더링되는 단면 물체 입니다.
* 렌더링되지 않는 반대쪽 면에는 그림자가 드리우지 않습니다.

<br />

이렇게 실행한 결과는 다음과 같습니다.

<img src="/markdownAssets/threejs/2024-01-07-01/2024-01-07-01-02.png" alt="PlaneMesh 설정" />

<br />

카메라를 회전시켜서 Plane Mesh 의 반대쪽 면을 보면, 렌더링되지 않은 결과를 볼 수 있습니다.

<img src="/markdownAssets/threejs/2024-01-07-01/2024-01-07-01-03.png" alt="PlaneMesh 반대면" />



## 마치며

Plane Mesh 를 생성하여 바닥(땅) 을 만들 수 있게 되었습니다.

다음 포스팅에서는 바닥(땅) 에 그림자를 표현하여, 조명과 물체의 자연스러운 연출 방법을 정리해 보겠습니다.
14:T2eef,---
id: 3
title: 조명 종류와 설정
description: '조명 종류와 설정 방법에 대해 정리합니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'threejs',
    'javascript',
    '3d',
    'light',
]

createdAt: '2024-01-06 23:00:00'
modifiedHistories: []
---

# 조명 종류와 설정

Three.js 는 조명이 없으면 검은 화면만 보이게 됩니다.

이번 포스팅에서는 조명의 종류와 특징, 설정 방법에 대해 정리하고자 합니다.



<br />



## 조명 종류

조명의 종류는 다음과 같습니다.

* DirectionalLight
* PointLight
* AmbientLight
* HemisphereLight

그리고 개발환경에서 조명의 광원 위치를 파악하기 쉽게 도와주는 **Helper class** 가 있습니다.

자세한 사항은 각 조명과 함께 정리하겠습니다.



<br />



## 예시 코드

이번 포스팅에서 사용할 예시 코드는 다음과 같습니다.

```js title="예시 코드" showLineNumbers {94}
import {
    WebGLRenderer,
    Scene,
    PerspectiveCamera,

    SphereGeometry,
    MeshStandardMaterial,
    Mesh,

    Color,

    DirectionalLight,
    DirectionalLightHelper,
} from 'three';
import './style.css';
import {
    OrbitControls,
} from 'three/examples/jsm/controls/OrbitControls';

/** @type { WebGLRenderer } */
let renderer;

/** @type { Scene } */
let scene;

/** @type { PerspectiveCamera } */
let camera;

/** @type { OrbitControls } */
let controls;

function initCanvas() {
    const $canvas = document.createElement('canvas');
    $canvas.width = window.innerWidth;
    $canvas.height = window.innerHeight;

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    return $canvas;
}

function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });
}

function initScene() {
    scene = new Scene();
}

function initCamera() {
    camera = new PerspectiveCamera();
    camera.fov = 35;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.position.set(0, 0, 10);

    camera.updateProjectionMatrix();
}

function initControls($canvas) {
    controls = new OrbitControls(camera, $canvas);
    controls.enableDamping = true;
}

function createSphere() {
    const geometry = new SphereGeometry();
    const material = new MeshStandardMaterial();
    const sphere = new Mesh(geometry, material);

    return sphere;
}

function render() {
    requestAnimationFrame(render);

    renderer.render(scene, camera);
    controls.update();
}

function init() {
    const $canvas = initCanvas();

    initRenderer($canvas);
    initScene();
    initCamera();
    initControls($canvas);

    const sphere = createSphere();
    scene.add(sphere);

    // 여기에서 `조명 설정` 함수를 호출하며 실습할 예정입니다.

    render();
}

init();
```



<br />



## DirectionalLight

DirectionalLight 는 **광원** 에서 **특정 지점(lookAt(좌표))** 로 비추는 **단방향 조명** 입니다.

물체에 비추는 빛의 양은 광원과의 거리와 무관한 빛의 세기(intensity) 설정값이 적용됩니다.

<br />

```js title="DirectionalLight import 하기" showLineNumbers
import {
    DirectionalLight,
} from 'three';
```

```js title="DirectionalLight" showLineNumbers{83} {9, 14-18}
function init() {
    initRenderer(initCanvas());
    initCamera();
    initScene();

    const sphere = createSphere();
    scene.add(sphere);

    initDirectionalLight();

    render();
}

function initDirectionalLight() {
    const light = new DirectionalLight();
    light.position.set(1, 1, 1);
    scene.add(light);
}

init();
```

<br />

DirectionalLight 생성자에 인자로 **Color 객체** 를 넘겨주어 빛의 색상을 변경할 수 있습니다.

**Color** 는 Three.js 에서 제공하는 class 이며, Three.js 의 색상관련 설정은 **Color 인스턴스** 를 받습니다.

```js title="Color import 하기" showLineNumbers
import {
    Color,
} from 'three';
```

```js title="DirectionalLight 색상 설정하기" showLineNumbers{83} {15}
function init() {
    initRenderer(initCanvas());
    initCamera();
    initScene();

    const sphere = createSphere();
    scene.add(sphere);

    initDirectionalLight();

    render();
}

function initDirectionalLight() {
    const color = new Color('#f0f400');
    const light = new DirectionalLight(color);
    light.position.set(1, 1, 1);

    scene.add(light);
}

init();
```

<img src="/markdownAssets/threejs/2024-01-06-01/2024-01-06-01-01.png" alt="DirectionalLight" />



<br />



### DirectionalLightHelper

DirectionalLight 의 광원을 표기해주는 기능을 사용해 보겠습니다.

DirectionalLightHelper 인스턴스를 생성한 후, `scene.add()` 를 사용하여 등록해 줍니다.

```js title="DirectionalLightHelper import 하기" showLineNumbers {3}
import {
    DirectionalLight,
    DirectionalLightHelper,
} from 'three';
```

```js title="DirectionalLight 색상 설정하기" showLineNumbers{83} {20-21}
function init() {
    initRenderer(initCanvas());
    initCamera();
    initScene();

    const sphere = createSphere();
    scene.add(sphere);

    initDirectionalLight();

    render();
}

function initDirectionalLight() {
    const color = new Color('#f0f400');
    const light = new DirectionalLight(color);
    light.position.set(1, 1, 1);
    scene.add(light);

    const helper = new DirectionalLightHelper(light);
    scene.add(helper);
}

init();
```

<img src="/markdownAssets/threejs/2024-01-06-01/2024-01-06-01-02.png" alt="DirectionalLightHelper" />



<br />



## 빛의 세기(intensity) 설정하기

조명은 빛의 세기(intensity) 가 있습니다.

Three.js 의 모든 조명에도 빛의 세기(intensity) 를 설정할 수 있습니다.

빛의 세기 값은 **0 ~ 1** 값으로 설정합니다.

아래 코드는 DirectionalLight 에 빛의 세기(intensity) 를 0.75 로 설정하고 있습니다.

```js title="DirectionalLight 색상 설정하기" showLineNumbers{83} {18}
function init() {
    initRenderer(initCanvas());
    initCamera();
    initScene();

    const sphere = createSphere();
    scene.add(sphere);

    initDirectionalLight();

    render();
}

function initDirectionalLight() {
    const color = new Color('#f0f400');
    const light = new DirectionalLight(
        color, 
        0.75
    );
    light.position.set(1, 1, 1);
    scene.add(light);

    const helper = new DirectionalLightHelper(light);
    scene.add(helper);
}

init();
```



<br />



## PointLight

전등처럼 한 점에서 빛을 방사하는 조명 입니다.

사용방법은 다음과 같습니다.

```js title="PointLight import 하기" showLineNumbers
import {
    PointLight,
    PointLightHelper,
} from 'three';
```

```js title="PointLight 색상 설정하기" showLineNumbers{83} {9, 14-25}
function init() {
    initRenderer(initCanvas());
    initCamera();
    initScene();

    const sphere = createSphere();
    scene.add(sphere);

    initPointLight();

    render();
}

function initPointLight() {
    const color = new Color('#f0f400');
    const light = new PointLight(
        color,
        0.75 // 빛의 세기(intensity)
    );
    light.position.set(1, 1, 1);
    scene.add(light);

    const helper = new PointLightHelper(light);
    scene.add(helper);
}

init();
```

<img src="/markdownAssets/threejs/2024-01-06-01/2024-01-06-01-03.png" alt="PointLight" />



<br />



## AmbientLight

Ambient 는 `주변` 이라는 뜻을 가지고 있습니다.

AmbientLight 는 특정한 광원이 없고, 모든 영역에 동일하게 비추는 조명입니다.

즉 `(x, y, z)` 에 관계없이 동일한 빛을 비춥니다.

<br />

AmbientLight 가 적용된 결과를 확인하기 위해, PointLight 와 함께 사용해 보겠습니다.

```js title="PointLight import 하기" showLineNumbers {5}
import {
    PointLight,
    PointLightHelper,

    AmbientLight,
} from 'three';
```

```js title="PointLight 색상 설정하기" showLineNumbers{83} {10, 28-35}
function init() {
    initRenderer(initCanvas());
    initCamera();
    initScene();

    const sphere = createSphere();
    scene.add(sphere);

    initPointLight();
    initAmbientLight();

    render();
}

function initPointLight() {
    const color = new Color('#f0f400');
    const light = new PointLight(
        color,
        0.75 // 빛의 세기(intensity)
    );
    light.position.set(1, 1, 1);
    scene.add(light);

    const helper = new PointLightHelper(light);
    scene.add(helper);
}

function initAmbientLight() {
    const color = new Color('#fff');
    const light = new AmbientLight(
        color,
        0.25, // 빛의 세기(intensity)
    );
    scene.add(light);
}

init();
```

<img src="/markdownAssets/threejs/2024-01-06-01/2024-01-06-01-04.png" alt="AmbientLight" />

<br />

그리고 AmbientLight 는 모든 영역에 비추는 조명이므로, **Helper class 가 없다는 특징** 이 있습니다.



<br />



## HemisphereLight

HemisphereLight 는 위쪽(skyColor) 와 아래쪽(groundColor) 를 인자로 받고, 그라데이션으로 비추는 조명입니다.

일반적으로 기본 조명으로 사용하는데, 이는 Three.js 특성 때문입니다.

* 조명이 없으면, 물체(Mesh) 는 보이지 않는 검은 화면만 렌더링 됩니다.
* 다른 조명에 의해 생기는 그림자를 좀 더 자연스럽고 부드럽게 만들어줍니다.

<br />

아래 코드는 HemisphereLight 와 DirectionalLight 를 조합한 예시 입니다.

```js title="PointLight import 하기" showLineNumbers {5-6}
import {
    DirectionalLight,
    DirectionalLightHelper,

    HemisphereLight,
    HemisphereLightHelper,
} from 'three';
```

```js title="PointLight 색상 설정하기" showLineNumbers{83} {10, 28-40}
function init() {
    initRenderer(initCanvas());
    initCamera();
    initScene();

    const sphere = createSphere();
    scene.add(sphere);

    initDirectionalLight();
    initHemisphereLight();

    render();
}

function initDirectionalLight() {
    const color = new Color('#fff');
    const light = new DirectionalLight(
        color,
        0.75 // 빛의 세기(intensity)
    );
    light.position.set(1, 1, 1);
    scene.add(light);

    const helper = new PointLightHelper(light);
    scene.add(helper);
}

function initHemisphereLight() {
    const skyColor = new Color('#fff');
    const groundColor = new Color('#000');
    const light = new HemisphereLight(
        skyColor,
        groundColor,
        0.25, // 빛의 세기(intensity)
    );
    scene.add(light);

    const helper = new HemisphereLightHelper(light);
    scene.add(helper);
}

init();
```

<img src="/markdownAssets/threejs/2024-01-06-01/2024-01-06-01-05.png" alt="Hemisphere" />



<br />



## 마치며

일반적으로 DirectionalLight 와 HemisphereLight 를 조합하여 기본 조명을 구성합니다.

각 설정은 다음과 같습니다.

```js title="일반적인 조명 설정" showLineNumbers
function initDirectionalLight() {
    const color = new Color('#fff');
    const light = new DirectionalLight(
        color,
        0.75 // HemispherLight 보다 0.5 강하게 설정합니다.
    );
    scene.add(light);
}

function initHemisphereLight() {
    const skyColor = new Color('#fff');
    const groundColor = new Color('#000');
    const light = new HemisphereLight(
        skyColor,
        groundColor,
        0.25 // DirectionalLight 보다 0.5 약하게 설정합니다.
    );
    scene.add(light);
}
```

<br />

HemisphereLight 를 사용하므로써 그림자 부분이 검은색으로 보이지 않도록 해주며, 좀 더 자연스러운 조명을 연출할 수 있습니다.

그리고 PointLight 는 특정 물체를 강조하거나 효과를 주기위해 주로 사용합니다.

<br />

Three.js 는 개발 능력뿐만 아니라 사물을 표현하는 예술 능력도 필요하겠다는 느낌이 듭니다. 😱
15:T3ac1,---
id: 2
title: 카메라 설정 (PerspectiveCamera)
description: 'Three.js 의 카메라인 PerspectiveCamera 설정에 대한 포스팅입니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'threejs',
    'javascript',
    '3d',
    'camera',
]

createdAt: '2024-01-01 23:50:00'
modifiedHistories: []
---

# 카메라 설정 (PerspectiveCamera)

Three.js 가 `<canvas />` 에 실제로 렌더링하는 부분은 `카메라 (PerspectiveCamera)` 가 비추는 영역입니다.

이번 포스팅에서는 카메라 설정과 효과, 사용자 인터렉션 적용 방법에 대해 정리해 보겠습니다.

이번 포스팅에서는 아래의 코드를 시작점으로 사용하겠습니다.

```js title="샘플 코드" showLineNumbers
import {
    WebGLRenderer,
    PerspectiveCamera,
    Scene,
    DirectionalLight,

    BoxGeometry,
    MeshPhongMaterial,
    Mesh,
} from 'three';
import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

/** @type { Scene } */
let scene;

(function init() {
    const $canvas = initCanvas();

    initRenderer($canvas);

    const light = createLight();
    const boxMesh = createBoxMesh();

    initCamera();
    initScene(light, boxMesh);

    render();

    console.log('시작');
}());

function render() {
    renderer.render(scene, camera);

    window.requestAnimationFrame(render);
}

function initCanvas() {
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    return $canvas;
}

/**
 * @param { HTMLCanvasElement } $canvas 
 */
function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });

    renderer.setSize(
        window.innerWidth,
        window.innerHeight
    );
}

function createLight() {
    const light = new DirectionalLight();
    light.position.set(1, 2, 3);

    return light;
}

function createBoxMesh() {
    const boxGeometry = new BoxGeometry();
    const boxMaterial = new MeshPhongMaterial();

    return new Mesh(boxGeometry, boxMaterial);
}

function initCamera() {
    camera = new PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight
    );

    camera.position.set(0, 0, 5);
}

function initScene(...items) {
    scene = new Scene();

    items.forEach(item => {
        scene.add(item);
    });
}
```



<br />



## PerspectiveCamera 생성자 params

카메라 생성자 params 를 사용하여 초기 설정을 할 수 있습니다.

```ts title="PerspectiveCamera 생성자 함수" showLineNumbers
class PerspectiveCamera {
    constructor(
        fov?: number,
        aspect?: number,
        near?: number,
        far?: number
    );
}
```

* fov (Field of View): 시야각 (화각)
    * fov 설정값이 클수록 먼 거리에서 보는 느낌이 납니다.
    * fov 설정값이 커질수록 **투시에 따른 왜곡현상** 이 도드라지게 나타납니다.
* aspect: 카메라 종횡비 (aspect radio)
    * 카메라의 가로, 세로 비율값 입니다.
* near: (Near clipping)
    * 카메라를 기준으로 가까운 물체(Mesh) 에 대한 렌더링 잘라내기 설정값 입니다.
* far: (Far clipping)
    * 카메라를 기준으로 먼 물체(Mesh) 에 대한 렌더링 잘라내기 설정값 입니다.

<br />

위 설정들은 PerspectiveCamera 생성자를 통해서도 설정할 수 있고, 객체를 생성한 후 설정을 변경할 수도 있습니다.

만약 객체를 생성한 후 설정을 변경한다면, 카메라 메소드인 **updateProjectionMatrix()** 함수를 호출하여야 실제 렌더링에 반영됩니다.

아래 코드는 PerspectiveCamera 객체를 생성한 후, 카메라 설정을 변경하고 있습니다.

```js title="카메라 객체 설정값 변경하기" showLineNumbers {88, 89, 92}
import {
    WebGLRenderer,
    PerspectiveCamera,
    Scene,
    DirectionalLight,

    BoxGeometry,
    MeshPhongMaterial,
    Mesh,
} from 'three';
import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

/** @type { Scene } */
let scene;

(function init() {
    const $canvas = initCanvas();

    initRenderer($canvas);

    const light = createLight();
    const boxMesh = createBoxMesh();

    initCamera();
    initScene(light, boxMesh);

    render();

    console.log('시작');
}());

function render() {
    renderer.render(scene, camera);

    window.requestAnimationFrame(render);
}

function initCanvas() {
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    return $canvas;
}

/**
 * @param { HTMLCanvasElement } $canvas 
 */
function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });

    renderer.setSize(
        window.innerWidth,
        window.innerHeight
    );
}

function createLight() {
    const light = new DirectionalLight();
    light.position.set(1, 2, 3);

    return light;
}

function createBoxMesh() {
    const boxGeometry = new BoxGeometry();
    const boxMaterial = new MeshPhongMaterial();

    return new Mesh(boxGeometry, boxMaterial);
}

function initCamera() {
    camera = new PerspectiveCamera(
        // 45,
        // window.innerWidth / window.innerHeight
    );

    camera.fov = 45;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.position.set(0, 0, 3);

    camera.updateProjectionMatrix();
}

function initScene(...items) {
    scene = new Scene();

    items.forEach(item => {
        scene.add(item);
    });
}
```

<br />

위 코드의 실행 결과로 BoxMesh 의 단면을 볼 수 있습니다.

<img src="/markdownAssets/threejs/2024-01-01-01/2024-01-01-01-01.png" alt="실행 결과" />



<br />



## 카메라의 주시 좌표값 변경하기

현재는 BoxMesh 의 단면만을 비추고 있어서 마치 2D 인것 처럼 보입니다.

카메라의 위치와 카메라의 주시 좌표값을 변경하면, 물체를 다각도에서 다양한 구도로 렌더링할 수 있습니다.

<br />

먼저 카메라의 위치를 (1, 1, 2) 로 변경해 보겠습니다.

```js title="카메라 position 변경" showLineNumbers{82} {6}
function initCamera() {
    camera = new PerspectiveCamera();

    camera.fov = 45;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.position.set(1, 1, 2);

    camera.updateProjectionMatrix();
}
```

<img src="/markdownAssets/threejs/2024-01-01-01/2024-01-01-01-02.png" alt="실행 결과" />

<br />

카메라의 position 만을 변경한 결과, BoxMesh 의 일부분만 렌더링되고 있습니다.

이는 카메라의 주시 좌표값을 설정하지 않아서 카메라 위치에서 정면을 주시하고 있기 때문입니다.

카메라 객체의 `lookAt()` 메소드를 사용하면, 카메라의 위치인 position 에서 특정 좌표를 주시하게 됩니다.

BoxMesh 가 카메라의 중앙에 오도록 하기위해, BoxMesh 의 position 위치값인 (0, 0, 0) 으로 카메라 주시 좌표를 설정해 보겠습니다.

```js title="카메라 position 변경" showLineNumbers{82} {8}
function initCamera() {
    camera = new PerspectiveCamera();

    camera.fov = 45;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.position.set(1, 1, 2);

    camera.lookAt(0, 0, 0);

    camera.updateProjectionMatrix();
}
```

<img src="/markdownAssets/threejs/2024-01-01-01/2024-01-01-01-03.png" alt="실행 결과" />



<br />



## 카메라 fov 와 position 설정에 따른 왜곡 현상

fov(Field of View) 값이 커질수록 멀리서 보는 느낌으로 렌더링됩니다.

이는 물체가 더 작게 보이는 결과를 볼 수 있습니다.

<br />

만약 fov 를 큰 값으로 설정하여 물체가 작게 보이도록 한 후, 카메라의 위치를 물체와 가깝게 설정하면 어떻게 될까요?

이는 카메라의 **왜곡 현상** 에 의해 좀 더 렌즈의 굴곡이 커지게 됩니다.

fov 와 position 의 관계를 표현해 보면 다음과 같습니다.

* fov 작게 설정, position 멀리 설정
    * 왜곡 현상이 적어집니다.
* fov 크게 설정, position 가깝게 설정
    * 왜곡 현상이 커집니다.

<br />

실제 왜곡 현상의 차이를 확인하기 위해 두가지 설정을 비교해 보겠습니다.

* 첫번째 설정: **fov 작게, position 멀리** 설정
* 두번째 설정: **fov 크게, position 가깝게** 설정

```js title="fov 작게, position 멀리 설정" showLineNumbers{82} {5-6}
function initCamera() {
    camera = new PerspectiveCamera();

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.fov = 45;
    camera.position.set(2, 2, 2);

    camera.lookAt(0, 0, 0);

    camera.updateProjectionMatrix();
}
```

<img src="/markdownAssets/threejs/2024-01-01-01/2024-01-01-01-04.png" alt="실행 결과" />

<br /><br />

```js title="fov 크게, position 가깝게 설정" showLineNumbers{82} {5-6}
function initCamera() {
    camera = new PerspectiveCamera();

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.fov = 90;
    camera.position.set(1, 1, 1);

    camera.lookAt(0, 0, 0);

    camera.updateProjectionMatrix();
}
```

<img src="/markdownAssets/threejs/2024-01-01-01/2024-01-01-01-05.png" alt="실행 결과" />



<br />



## 추가: 마우스를 사용하여 카메라 제어하기

Three.js 는 여러가지 Addons 를 제공합니다.

이 중 **OrbitControls** 객체를 사용하면, 마우스를 사용하여 카메라를 제어하는 기능을 제공할 수 있습니다.

<br />

OrbitControls 는 **PerspectiveCamera 의 Addon** 개념으로 사용하게 되며, 카메라의 제어를 담당하게 됩니다.

주의할 점은 PerspectiveCamera 의 `lookAt()` 메소드를 함께 사용하게 되면, 카메라 제어에 충돌이 발생하는 현상입니다.

그러므로 OrbitControls 를 사용하려면, `lookAt()` 메소드는 꼭 제거해 주는 것이 좋습니다.

<br />

먼저 OrbitControls 의 생성자를 살펴보면 다음과 같습니다.

```ts
class OrbitControls {
    constructor(
        object: Camera, 
        domElement?: HTMLElement
    );
}
```

* object: 제어할 카메라 객체
* domElement: 마우스 이벤트를 발생시킬 HTMLElement

<br />

PerspectiveCamera 에 OrbitControls 를 적용하는 `initControls()` 함수를 추가해 보겠습니다.

```js title="OrbitControls 로 카메라 제어하기" showLineNumbers {11-13, 25-26, 37, 45, 103-108}
import {
    WebGLRenderer,
    PerspectiveCamera,
    Scene,
    DirectionalLight,

    BoxGeometry,
    MeshPhongMaterial,
    Mesh,
} from 'three';
import {
    OrbitControls,
} from 'three/examples/jsm/controls/OrbitControls'
import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

/** @type { Scene } */
let scene;

/** @type { OrbitControls } */
let controls;

(function init() {
    const $canvas = initCanvas();

    initRenderer($canvas);

    const light = createLight();
    const boxMesh = createBoxMesh();

    initCamera();
    initControls($canvas);
    initScene(light, boxMesh);

    render();
}());

function render() {
    renderer.render(scene, camera);
    controls.update();

    window.requestAnimationFrame(render);
}

function initCanvas() {
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    return $canvas;
}

/**
 * @param { HTMLCanvasElement } $canvas 
 */
function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });

    renderer.setSize(
        window.innerWidth,
        window.innerHeight
    );
}

function createLight() {
    const light = new DirectionalLight();
    light.position.set(1, 2, 3);

    return light;
}

function createBoxMesh() {
    const boxGeometry = new BoxGeometry();
    const boxMaterial = new MeshPhongMaterial();

    return new Mesh(boxGeometry, boxMaterial);
}

function initCamera() {
    camera = new PerspectiveCamera();

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.fov = 45;
    camera.position.set(2, 2, 2);

    camera.fov = 90;
    camera.position.set(1, 1, 1);

    camera.lookAt(0, 0, 0);

    camera.updateProjectionMatrix();
}

/**
 * @param { HTMLElement } $targetElement 
 */
function initControls($targetElement) {
    controls = new OrbitControls(camera, $targetElement);
}

function initScene(...items) {
    scene = new Scene();

    items.forEach(item => {
        scene.add(item);
    });
}
```

<br />

OrbitControls 를 카메라에 설치하게 되면 아래와 같은 마우스 인터렉션을 사용할 수 있습니다.

* 마우스 좌클릭 - 드래그
    * 카메라 주시 좌표를 회전 중심점으로 하여, **드래그 반대 방향으로 카메라를 회전** 시킵니다.
    * 결과적으로 카메라가 고정된 상태에서 **바라보는 물체가 회전** 하게 됩니다.
* 마우스 휠
    * 확대, 축소 동작을 합니다.
* 마우스 우클릭 - 드래그
    * **드래그 반대 방향으로 카메라의 위치를 이동** 시킵니다.
    * 결과적으로 카메라가 고정된 상태에서 **바라보는 물체가 이동** 하게 됩니다.

<br />

OrbitControls 객체의 설정을 사용하여, 특정 마우스 인터렉션의 사용 여부를 설정할 수 있습니다.

이 설정 프로퍼티들은 `enable` 을 접두사로 사용하고 있습니다.

* `enableRotate`: `false` 값을 대입하면, 회전기능을 막습니다.
* `enableZoom`: `false` 값을 대입하면 확대, 축소 기능을 막습니다.
* `enablePan`: `false` 값을 대입하면 이동 기능을 막습니다.

<br />

추가로 `enableDamping` 에 `true` 값을 대입하게 되면, 카메라의 모든 인터렉션에 감속도가 적용되어 **카메라의 부드러운 움직임이 연출** 됩니다.



<br />



## 마치며

일전에 HTML Canvas API 를 스터디하면서, 도형에 대한 인터렉션이나 애니메이션을 구현해본 적이 있습니다.

물체의 튕김이나 가속도, 감속도를 구현해 보려는 시도를 했었지만, 제가 구현한 결과물은 너무나 어색했습니다.

Three.js 의 인터렉션은 OrbitControls 하나를 접했을 뿐인데, 부드러운 3D 엔진에 그저 놀라울 뿐입니다.

<br />

하지만 실제 구현할 기획에 따라 엔진의 물리 효과를 커스터마이징을 할 수 있어야 자연스러운 결과물이 나올 것 같습니다.

OrbitControls 가 제공하는 효과는 마치 물속의 부력이 작용하는 것처럼 느껴졌습니다.

Three.js 의 기본 사용법과 원리를 이해한 후, 물리 엔진 커스터마이징에 대해서도 도전해 보고 싶어졌습니다.
d:["$","$Le",null,{"featuredMarkdownFileDataList":[{"category":"threejs","slug":"2023-12-31-01","href":"/blog/threejs/2023-12-31-01","frontmatter":{"id":1,"title":"Three.js 설치 및 실행","description":"Three.js 를 사용하기 위한 설치와 첫번째 화면을 그려봅니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":true,"tags":["threejs","javascript","3d"],"createdAt":"$D2023-12-31T22:47:00.000Z","modifiedHistories":[]},"markdownFile":"$f"}],"commonMarkdownFileDataList":[{"category":"threejs","slug":"2024-01-10-01","href":"/blog/threejs/2024-01-10-01","frontmatter":{"id":7,"title":"모델 파일을 Three.js 에 렌더링하기","description":".gltf 또는 .glb 확장자인 모델 파일을 Three.js 에 불러오고 렌더링하는 방법을 정리합니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["threejs","javascript","3d","hdr",".gltf",".glb","model"],"createdAt":"$D2024-01-10T23:50:00.000Z","modifiedHistories":[]},"markdownFile":"$10"},{"category":"threejs","slug":"2024-01-08-01","href":"/blog/threejs/2024-01-08-01","frontmatter":{"id":6,"title":"배경화면 및 환경조명 설정하기","description":"360도 이미지 확장자인 .hdr 파일을 사용하여 배경화면을 설정하고, 배경화면에 의한 환경조명 설정에 대한 정리입니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["threejs","javascript","3d","hdr","background","3D 배경화면","환경조명"],"createdAt":"$D2024-01-08T23:50:00.000Z","modifiedHistories":[]},"markdownFile":"$11"},{"category":"threejs","slug":"2024-01-07-02","href":"/blog/threejs/2024-01-07-02","frontmatter":{"id":5,"title":"그림자 표현하기","description":"그림자 설정방법과 특징에 대해 정리합니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["threejs","javascript","3d","shadow"],"createdAt":"$D2024-01-07T23:50:00.000Z","modifiedHistories":[]},"markdownFile":"$12"},{"category":"threejs","slug":"2024-01-07-01","href":"/blog/threejs/2024-01-07-01","frontmatter":{"id":4,"title":"평평한 바닥(땅) 만들기 (Plane Mesh)","description":"바닥을 표현하기 위해 Plane Mesh 를 생성합니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["threejs","javascript","3d","plane"],"createdAt":"$D2024-01-07T23:20:00.000Z","modifiedHistories":[]},"markdownFile":"$13"},{"category":"threejs","slug":"2024-01-06-01","href":"/blog/threejs/2024-01-06-01","frontmatter":{"id":3,"title":"조명 종류와 설정","description":"조명 종류와 설정 방법에 대해 정리합니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["threejs","javascript","3d","light"],"createdAt":"$D2024-01-06T23:00:00.000Z","modifiedHistories":[]},"markdownFile":"$14"},{"category":"threejs","slug":"2024-01-01-01","href":"/blog/threejs/2024-01-01-01","frontmatter":{"id":2,"title":"카메라 설정 (PerspectiveCamera)","description":"Three.js 의 카메라인 PerspectiveCamera 설정에 대한 포스팅입니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["threejs","javascript","3d","camera"],"createdAt":"$D2024-01-01T23:50:00.000Z","modifiedHistories":[]},"markdownFile":"$15"}]}]
