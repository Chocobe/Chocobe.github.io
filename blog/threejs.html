<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/0c7e3e2387401c47-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" as="image" href="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg" fetchPriority="high"/><link rel="stylesheet" href="/_next/static/css/6566b64e7f0e478f.css" crossorigin="" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-14bcfdf71a1473f7.js" crossorigin=""/><script src="/_next/static/chunks/fd9d1056-9fe3c6d0c60c86d8.js" async="" crossorigin=""></script><script src="/_next/static/chunks/472-cf3134408a61a609.js" async="" crossorigin=""></script><script src="/_next/static/chunks/main-app-b1972c4cdd2be6d3.js" async="" crossorigin=""></script><script src="/_next/static/chunks/576-dc377cf448834f03.js" async=""></script><script src="/_next/static/chunks/251-ef7560cc4f7a9f6d.js" async=""></script><script src="/_next/static/chunks/app/layout-5bdea2f994faa404.js" async=""></script><script src="/_next/static/chunks/08ffe114-a8e3ed06beefbf38.js" async=""></script><script src="/_next/static/chunks/48507feb-6de01ca04009bb96.js" async=""></script><script src="/_next/static/chunks/39209d7c-a33d4549f726b4ab.js" async=""></script><script src="/_next/static/chunks/app/blog/%5Bcategory%5D/layout-7ae3540a4673a57a.js" async=""></script><script src="/_next/static/chunks/128-a9a4b8134fdbdc1d.js" async=""></script><script src="/_next/static/chunks/app/blog/%5Bcategory%5D/page-864fbedea356ae73.js" async=""></script><title>Chocobe Blog v2</title><meta name="description" content="Frontend 기술 블로그 입니다."/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" crossorigin="" noModule=""></script><style data-styled="" data-styled-version="6.1.0">*{margin:0;padding:0;box-sizing:border-box;font-family:"Pretendard Variable",sans-serif;}/*!sc*/
body{width:100vw;height:100vh;overflow:hidden;}/*!sc*/
data-styled.g1[id="sc-global-eqoFij1"]{content:"sc-global-eqoFij1,"}/*!sc*/
.bogipj{display:flex;flex-wrap:wrap;gap:20px;}/*!sc*/
.bogipj >.navItem{padding:0 8px;color:#222;font-size:16px;line-height:24px;font-weight:500;}/*!sc*/
data-styled.g2[id="sc-4612defa-0"]{content:"bogipj,"}/*!sc*/
.fiXfoi{position:sticky;top:0;z-index:1;background-color:#E8F3F3;}/*!sc*/
.fiXfoi >.innerWrapper{margin:0 auto;padding:24px 20px 20px;width:100%;max-width:1200px;display:grid;grid-template-columns:repeat(3, 1fr);}/*!sc*/
.fiXfoi >.innerWrapper >.logoLink{display:flex;justify-content:center;align-items:flex-end;gap:4px;}/*!sc*/
.fiXfoi >.innerWrapper >.logoLink >.chocobe{padding:8px 4px 0;color:#fff;font-size:28px;line-height:20px;font-weight:600;background-color:#00AAA1;}/*!sc*/
.fiXfoi >.innerWrapper >.logoLink >.fe-blog{position:relative;color:#222;font-size:16px;line-height:16px;font-weight:600;}/*!sc*/
.fiXfoi >.innerWrapper >.logoLink >.fe-blog::before{content:'';width:4px;height:4px;display:block;position:absolute;bottom:2px;right:-6px;border-radius:50%;background-color:#00AAA1;}/*!sc*/
.fiXfoi >.innerWrapper >.headerActionsWrapper{display:flex;justify-content:flex-end;}/*!sc*/
data-styled.g3[id="sc-2b4c7cfd-0"]{content:"fiXfoi,"}/*!sc*/
.gWzijn{height:0;min-height:100%;}/*!sc*/
data-styled.g4[id="sc-6cb25f84-0"]{content:"gWzijn,"}/*!sc*/
.bVIbHO{width:100%;border-bottom:1px solid #EEEEEE;position:relative;overflow:hidden;cursor:pointer;}/*!sc*/
.bVIbHO:last-child{border-bottom:none;}/*!sc*/
.bVIbHO >.decorator{width:32px;position:absolute;top:0;bottom:100%;left:16px;background-color:#ffffff00;transform-origin:top right;transform:rotateZ(15deg) skewY(-15deg);transition:all 1s ease;}/*!sc*/
.bVIbHO >.inner{padding:10px;width:100%;position:sticky;top:0;left:0;display:flex;align-items:center;gap:8px;}/*!sc*/
.bVIbHO >.inner >.icon{color:#6D6E76;transition:all 1s ease;}/*!sc*/
.bVIbHO >.inner >.displayName{color:#6D6E76;font-size:20px;line-height:30px;font-weight:700;transition:all 1s ease;}/*!sc*/
.bVIbHO:hover >.inner >.icon{color:#333333;}/*!sc*/
.bVIbHO:hover >.inner >.displayName{color:#333333;}/*!sc*/
.bVIbHO.isSelected >.decorator{bottom:-100%;background-color:#FFD050;}/*!sc*/
.bVIbHO.isSelected >.inner >.icon{color:#009189;}/*!sc*/
.bVIbHO.isSelected >.inner >.displayName{color:#009189;}/*!sc*/
data-styled.g5[id="sc-db19d186-0"]{content:"bVIbHO,"}/*!sc*/
.fLooeo{border-right:1px solid #EEEEEE;}/*!sc*/
.fLooeo >.navTitle{padding:20px 10px;font-size:14px;line-height:22px;font-weight:500;text-align:center;}/*!sc*/
.fLooeo >.navList{width:200px;}/*!sc*/
data-styled.g6[id="sc-fa18996f-0"]{content:"fLooeo,"}/*!sc*/
.gwGyTj{display:flex;border-radius:8px;box-shadow:1px 3px 6px 0 rgba(0, 0, 0, 0.2);overflow:hidden;transition:all 0.18s ease;}/*!sc*/
.gwGyTj >.thumbnailWrapper{flex-shrink:0;width:40%;height:auto;position:relative;}/*!sc*/
.gwGyTj >.thumbnailWrapper >.thumbnail{object-fit:cover;object-position:center;}/*!sc*/
.gwGyTj >.cardBody{flex:1;padding:20px 16px;width:100%;position:relative;color:#fff;}/*!sc*/
.gwGyTj >.cardBody >.hoverDecorator{width:50%;height:32px;position:absolute;top:0;right:0;transform:translate(100%, -100%);transition:all 0.18s ease-in-out;background-color:#fdd835;pointer-events:none;}/*!sc*/
.gwGyTj >.cardBody >.hoverDecorator::after{content:'';width:50%;height:50px;display:block;position:absolute;top:8px;right:8px;transform:translate(100%, 100%);transition:all 0.18s ease-in-out;transition-delay:0.09s;background-color:#009189;}/*!sc*/
.gwGyTj >.cardBody >.category{color:#592EA9;font-size:16px;line-height:24px;font-weight:600;}/*!sc*/
.gwGyTj >.cardBody >.title{margin-top:20px;color:#232536;font-size:24px;line-height:30px;font-weight:700;}/*!sc*/
.gwGyTj >.cardBody >.date{margin-top:16px;color:#4C4C4C;font-size:14px;line-height:22px;font-weight:500;}/*!sc*/
.gwGyTj >.cardBody >.description{margin-top:16px;color:#6D6E76;font-size:16px;line-height:24px;font-weight:400;white-space:pre-line;display:-webkit-box;overflow:hidden;-webkit-box-orient:vertical;-webkit-line-clamp:2;}/*!sc*/
.gwGyTj >.cardBody >.readMoreLink{margin-top:32px;padding:16px 48px;display:none;color:#fff;font-size:18px;line-height:28px;font-weight:700;background-color:#009189;}/*!sc*/
.gwGyTj:not([data-variant=featured]):hover{box-shadow:3px 6px 12px 0 rgba(0, 0, 0, 0.5);cursor:pointer;}/*!sc*/
.gwGyTj:not([data-variant=featured]):hover >.cardBody >.hoverDecorator{transform:translate(0, 0);}/*!sc*/
.gwGyTj:not([data-variant=featured]):hover >.cardBody >.hoverDecorator::after{transform:translate(0, 0);}/*!sc*/
.gwGyTj[data-variant=featured]{flex-flow:row-reverse;border-radius:0;box-shadow:none;}/*!sc*/
.gwGyTj[data-variant=featured] >.thumbnailWrapper{border-radius:8px;overflow:hidden;}/*!sc*/
.gwGyTj[data-variant=featured] >.cardBody >.hoverDecorator{display:none;}/*!sc*/
.gwGyTj[data-variant=featured] >.cardBody >.title{font-size:36px;line-height:40px;}/*!sc*/
.gwGyTj[data-variant=featured] >.cardBody >.description{display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:2;overflow:hidden;white-space:pre-line;}/*!sc*/
.gwGyTj[data-variant=featured] >.cardBody >.readMoreLink{display:inline-block;}/*!sc*/
.gwGyTj[data-variant=featured]:hover{box-shadow:none;}/*!sc*/
data-styled.g7[id="sc-ae8c9e8b-0"]{content:"gwGyTj,"}/*!sc*/
.djGJcL >.featuredSection{padding:40px 20px;background-color:#F2F8F7;}/*!sc*/
.djGJcL >.commonSection{padding:20px;}/*!sc*/
data-styled.g8[id="sc-6666d4f0-0"]{content:"djGJcL,"}/*!sc*/
</style></head><body class="__className_7bb6ba"><div class="w-full
            h-full
            overflow-y-scroll
            overflow-x-auto"><header class="sc-2b4c7cfd-0 fiXfoi"><div class="innerWrapper"><nav class="sc-4612defa-0 bogipj"><a class="navItem" href="/profile">Profile</a></nav><a class="logoLink" href="/"><span class="chocobe">Chocobe</span><span class="fe-blog">FE Blog</span></a></div></header><div style="min-height:calc(100% - 72px)" class="sc-6cb25f84-0 gWzijn"><div><div class="w-full
                    flex items-start"><nav class="sc-fa18996f-0 fLooeo shrink-0
                        ml-auto
                        h-[calc(100vh-72px)]
                        sticky top-[72px]
                        overflow-auto
                        max-[600px]:w-0"><div class="navTitle">블로그 카테고리</div><ul class="navList"><li href="/blog/javascript" class="sc-db19d186-0 bVIbHO"><div class="decorator"></div><div class="inner"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="icon" height="30px" width="30px" xmlns="http://www.w3.org/2000/svg"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M20 4l-2 14.5l-6 2l-6 -2l-2 -14.5z"></path><path d="M7.5 8h3v8l-2 -1"></path><path d="M16.5 8h-2.5a.5 .5 0 0 0 -.5 .5v3a.5 .5 0 0 0 .5 .5h1.423a.5 .5 0 0 1 .495 .57l-.418 2.93l-2 .5"></path></svg><div class="displayName">Javascript</div></div></li><li href="/blog/react" class="sc-db19d186-0 bVIbHO"><div class="decorator"></div><div class="inner"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="icon" height="30px" width="30px" xmlns="http://www.w3.org/2000/svg"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M6.306 8.711c-2.602 .723 -4.306 1.926 -4.306 3.289c0 2.21 4.477 4 10 4c.773 0 1.526 -.035 2.248 -.102"></path><path d="M17.692 15.289c2.603 -.722 4.308 -1.926 4.308 -3.289c0 -2.21 -4.477 -4 -10 -4c-.773 0 -1.526 .035 -2.25 .102"></path><path d="M6.305 15.287c-.676 2.615 -.485 4.693 .695 5.373c1.913 1.105 5.703 -1.877 8.464 -6.66c.387 -.67 .733 -1.339 1.036 -2"></path><path d="M17.694 8.716c.677 -2.616 .487 -4.696 -.694 -5.376c-1.913 -1.105 -5.703 1.877 -8.464 6.66c-.387 .67 -.733 1.34 -1.037 2"></path><path d="M12 5.424c-1.925 -1.892 -3.82 -2.766 -5 -2.084c-1.913 1.104 -1.226 5.877 1.536 10.66c.386 .67 .793 1.304 1.212 1.896"></path><path d="M12 18.574c1.926 1.893 3.821 2.768 5 2.086c1.913 -1.104 1.226 -5.877 -1.536 -10.66c-.375 -.65 -.78 -1.283 -1.212 -1.897"></path><path d="M11.5 12.866a1 1 0 1 0 1 -1.732a1 1 0 0 0 -1 1.732z"></path></svg><div class="displayName">React</div></div></li><li href="/blog/nextjs" class="sc-db19d186-0 bVIbHO"><div class="decorator"></div><div class="inner"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="icon" height="30px" width="30px" xmlns="http://www.w3.org/2000/svg"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M9 15v-6l7.745 10.65a9 9 0 1 1 2.255 -1.993"></path><path d="M15 12v-3"></path></svg><div class="displayName">Nextjs</div></div></li><li href="/blog/jest" class="sc-db19d186-0 bVIbHO"><div class="decorator"></div><div class="inner"><svg stroke="currentColor" fill="currentColor" stroke-width="0" role="img" viewBox="0 0 24 24" class="icon" height="30px" width="30px" xmlns="http://www.w3.org/2000/svg"><title></title><path d="M22.251 11.82a3.117 3.117 0 0 0-2.328-3.01L22.911 0H8.104L11.1 8.838a3.116 3.116 0 0 0-2.244 2.988c0 1.043.52 1.967 1.313 2.536a8.279 8.279 0 0 1-1.084 1.244 8.14 8.14 0 0 1-2.55 1.647c-.834-.563-1.195-1.556-.869-2.446a3.11 3.11 0 0 0-.91-6.08 3.117 3.117 0 0 0-3.113 3.113c0 .848.347 1.626.903 2.182-.048.097-.097.195-.146.299-.465.959-.993 2.043-1.195 3.259-.403 2.432.257 4.384 1.849 5.489A5.093 5.093 0 0 0 5.999 24c1.827 0 3.682-.917 5.475-1.807 1.279-.632 2.599-1.292 3.898-1.612.48-.118.98-.187 1.508-.264 1.07-.153 2.175-.312 3.168-.89a4.482 4.482 0 0 0 2.182-3.091c.174-.994 0-1.994-.444-2.87.298-.48.465-1.042.465-1.647zm-1.355 0c0 .965-.785 1.75-1.75 1.75a1.753 1.753 0 0 1-1.085-3.126l.007-.007c.056-.042.118-.084.18-.125 0 0 .008 0 .008-.007.028-.014.055-.035.083-.05.007 0 .014-.006.021-.006.028-.014.063-.028.097-.042.035-.014.07-.027.098-.041.007 0 .013-.007.02-.007.028-.007.056-.021.084-.028.007 0 .02-.007.028-.007.034-.007.062-.014.097-.02h.007l.104-.022c.007 0 .02 0 .028-.007.028 0 .055-.007.083-.007h.035c.035 0 .07-.007.111-.007h.09c.028 0 .05 0 .077.007h.014c.055.007.111.014.167.028a1.766 1.766 0 0 1 1.396 1.723zM10.043 1.39h10.93l-2.509 7.4c-.104.02-.208.055-.312.09l-2.64-5.385-2.648 5.35c-.104-.034-.216-.055-.327-.076l-2.494-7.38zm4.968 9.825a3.083 3.083 0 0 0-.938-1.668l1.438-2.904 1.452 2.967c-.43.43-.743.98-.868 1.605H15.01zm-3.481-1.098c.034-.007.062-.014.097-.02h.02c.029-.008.056-.008.084-.015h.028c.028 0 .049-.007.076-.007h.271c.028 0 .049.007.07.007.014 0 .02 0 .035.007.027.007.048.007.076.014.007 0 .014 0 .028.007l.097.02h.007c.028.008.056.015.083.029.007 0 .014.007.028.007.021.007.049.014.07.027.007 0 .014.007.02.007.028.014.056.021.084.035h.007a.374.374 0 0 1 .09.049h.007c.028.014.056.034.084.048.007 0 .007.007.013.007.028.014.05.035.077.049l.007.007c.083.062.16.132.236.201l.007.007a1.747 1.747 0 0 1 .48 1.209 1.752 1.752 0 0 1-3.502 0 1.742 1.742 0 0 1 1.32-1.695zm-6.838-.049c.966 0 1.751.786 1.751 1.751s-.785 1.751-1.75 1.751-1.752-.785-1.752-1.75.786-1.752 1.751-1.752zm16.163 6.025a3.07 3.07 0 0 1-1.508 2.133c-.758.438-1.689.577-2.669.716a17.29 17.29 0 0 0-1.64.291c-1.445.355-2.834 1.05-4.182 1.717-1.724.854-3.35 1.66-4.857 1.66a3.645 3.645 0 0 1-2.154-.688c-1.529-1.056-1.453-3.036-1.272-4.12.167-1.015.632-1.966 1.077-2.877.028-.055.049-.104.077-.16.152.056.312.098.479.126-.264 1.473.486 2.994 1.946 3.745l.264.139.284-.104c1.216-.431 2.342-1.133 3.336-2.071a9.334 9.334 0 0 0 1.445-1.716c.16.027.32.034.48.034a3.117 3.117 0 0 0 3.008-2.327h1.167a3.109 3.109 0 0 0 3.01 2.327c.576 0 1.11-.16 1.57-.43.18.52.236 1.063.139 1.605z"></path></svg><div class="displayName">Jest</div></div></li><li href="/blog/threejs" class="sc-db19d186-0 bVIbHO"><div class="decorator"></div><div class="inner"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="icon" height="30px" width="30px" xmlns="http://www.w3.org/2000/svg"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 22l-5 -19l19 5.5z"></path><path d="M12.573 17.58l-6.152 -1.576l8.796 -9.466l1.914 6.64"></path><path d="M12.573 17.58l-1.573 -6.58l6.13 2.179"></path><path d="M9.527 4.893l1.473 6.107l-6.31 -1.564z"></path></svg><div class="displayName">Three.js</div></div></li><li href="/blog/llmops" class="sc-db19d186-0 bVIbHO"><div class="decorator"></div><div class="inner"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 640 512" class="icon" height="30px" width="30px" xmlns="http://www.w3.org/2000/svg"><path d="M320 32c-8.1 0-16.1 1.4-23.7 4.1L15.8 137.4C6.3 140.9 0 149.9 0 160s6.3 19.1 15.8 22.6l57.9 20.9C57.3 229.3 48 259.8 48 291.9v28.1c0 28.4-10.8 57.7-22.3 80.8c-6.5 13-13.9 25.8-22.5 37.6C0 442.7-.9 448.3 .9 453.4s6 8.9 11.2 10.2l64 16c4.2 1.1 8.7 .3 12.4-2s6.3-6.1 7.1-10.4c8.6-42.8 4.3-81.2-2.1-108.7C90.3 344.3 86 329.8 80 316.5V291.9c0-30.2 10.2-58.7 27.9-81.5c12.9-15.5 29.6-28 49.2-35.7l157-61.7c8.2-3.2 17.5 .8 20.7 9s-.8 17.5-9 20.7l-157 61.7c-12.4 4.9-23.3 12.4-32.2 21.6l159.6 57.6c7.6 2.7 15.6 4.1 23.7 4.1s16.1-1.4 23.7-4.1L624.2 182.6c9.5-3.4 15.8-12.5 15.8-22.6s-6.3-19.1-15.8-22.6L343.7 36.1C336.1 33.4 328.1 32 320 32zM128 408c0 35.3 86 72 192 72s192-36.7 192-72L496.7 262.6 354.5 314c-11.1 4-22.8 6-34.5 6s-23.5-2-34.5-6L143.3 262.6 128 408z"></path></svg><div class="displayName">LLMOps</div></div></li></ul></nav><div style="max-width:980px" class="flex-1
                        mr-auto
                        w-full
                        overflow-x-hidden"><div class="sc-6666d4f0-0 djGJcL"><section class="featuredSection"><div data-variant="featured" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="Gamma, GammFactor, sRGB 정리" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">Gamma, GammFactor, sRGB 정리</div><div class="date">작성일: </div><div class="description">디지털 환경에서 색상을 표현하는데 사용되는 일부 개념들을 정리합니다.</div><a class="readMoreLink" href="/blog/threejs/2024-01-28-01">Read More</a></div></div></section><section class="commonSection"><div class="flex flex-col gap-[20px]"><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="Particle 로 반딧불이 표현하기" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">Particle 로 반딧불이 표현하기</div><div class="date">작성일: </div><div class="description">3D 환경에서 반딧불이나 별을 표현할 때 Particle 을 활용합니다. 매우 많은 입자들로 표현하는 Particle 을 어떻게 구현하는지 정리하고자 합니다.</div><a class="readMoreLink" href="/blog/threejs/2024-02-29-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="Material 의 map, bumpMap, normalMap" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">Material 의 map, bumpMap, normalMap</div><div class="date">작성일: </div><div class="description">Material 의 표현 방식과 울퉁불퉁한 재질을 처리하는 방식을 정리합니다.</div><a class="readMoreLink" href="/blog/threejs/2024-02-12-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="click 이벤트에 animation 연동하기" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">click 이벤트에 animation 연동하기</div><div class="date">작성일: </div><div class="description">특정 버튼을 click 했을 때 animation 을 실행하는 방법을 정리합니다.</div><a class="readMoreLink" href="/blog/threejs/2024-02-06-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="Model 에 Click Event 적용하기 (추가: ToneMapping, light.shadow.camera)" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">Model 에 Click Event 적용하기 (추가: ToneMapping, light.shadow.camera)</div><div class="date">작성일: </div><div class="description">Canvas 에 렌더링된 Model 에 Click 인터렉션을 적용 해봅니다.</div><a class="readMoreLink" href="/blog/threejs/2024-02-03-02">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="(Issue) 조명이 어둡게 보이는 현상" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">(Issue) 조명이 어둡게 보이는 현상</div><div class="date">작성일: </div><div class="description">강좌의 결과물에 비해 실습 결과물의 밝기가 어둡게 렌더링되는 현상이 발생하였습니다. 현상 원인과 해결 방법에 대해 정리하고자 합니다.</div><a class="readMoreLink" href="/blog/threejs/2024-02-03-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="키보드를 사용하여 카메라 이동 인터렉션 만들기" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">키보드를 사용하여 카메라 이동 인터렉션 만들기</div><div class="date">작성일: </div><div class="description">키보드 입력에 대한 event listener 를 사용하여 카메라를 이동할 수 있는 인터렉션을 구현해 봅니다.</div><a class="readMoreLink" href="/blog/threejs/2024-01-30-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="canvas 크기 설정 및 material 렌더링 side 설정" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">canvas 크기 설정 및 material 렌더링 side 설정</div><div class="date">작성일: </div><div class="description">사용자 모니터 대응을 위한 WebGLRenderer 설정과 material 의 렌더링 side 설정에 대해 정리합니다.</div><a class="readMoreLink" href="/blog/threejs/2024-01-28-02">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="Model 에 Animation 효과 적용하기" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">Model 에 Animation 효과 적용하기</div><div class="date">작성일: </div><div class="description">Model 파일인 .gltf, .glb 에 Animation 을 적용하는 방법에 대해 정리합니다.</div><a class="readMoreLink" href="/blog/threejs/2024-01-26-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="Model (.gltf, .glb) 객체 구조파악 및 그림자 적용" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">Model (.gltf, .glb) 객체 구조파악 및 그림자 적용</div><div class="date">작성일: </div><div class="description">Three.js 환경에 불러온 Model 객체의 주요 구성요소를 파악하고, 속성값을 변경하여 그림자를 만들어 봅니다.</div><a class="readMoreLink" href="/blog/threejs/2024-01-21-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="모델 파일을 Three.js 에 렌더링하기" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">모델 파일을 Three.js 에 렌더링하기</div><div class="date">작성일: </div><div class="description">.gltf 또는 .glb 확장자인 모델 파일을 Three.js 에 불러오고 렌더링하는 방법을 정리합니다.</div><a class="readMoreLink" href="/blog/threejs/2024-01-10-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="배경화면 및 환경조명 설정하기" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">배경화면 및 환경조명 설정하기</div><div class="date">작성일: </div><div class="description">360도 이미지 확장자인 .hdr 파일을 사용하여 배경화면을 설정하고, 배경화면에 의한 환경조명 설정에 대한 정리입니다.</div><a class="readMoreLink" href="/blog/threejs/2024-01-08-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="그림자 표현하기" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">그림자 표현하기</div><div class="date">작성일: </div><div class="description">그림자 설정방법과 특징에 대해 정리합니다.</div><a class="readMoreLink" href="/blog/threejs/2024-01-07-02">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="평평한 바닥(땅) 만들기 (Plane Mesh)" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">평평한 바닥(땅) 만들기 (Plane Mesh)</div><div class="date">작성일: </div><div class="description">바닥을 표현하기 위해 Plane Mesh 를 생성합니다.</div><a class="readMoreLink" href="/blog/threejs/2024-01-07-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="조명 종류와 설정" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">조명 종류와 설정</div><div class="date">작성일: </div><div class="description">조명 종류와 설정 방법에 대해 정리합니다.</div><a class="readMoreLink" href="/blog/threejs/2024-01-06-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="카메라 설정 (PerspectiveCamera)" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">카메라 설정 (PerspectiveCamera)</div><div class="date">작성일: </div><div class="description">Three.js 의 카메라인 PerspectiveCamera 설정에 대한 포스팅입니다.</div><a class="readMoreLink" href="/blog/threejs/2024-01-01-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="Three.js 설치 및 실행" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">Three.js 설치 및 실행</div><div class="date">작성일: </div><div class="description">Three.js 를 사용하기 위한 설치와 첫번째 화면을 그려봅니다.</div><a class="readMoreLink" href="/blog/threejs/2023-12-31-01">Read More</a></div></div></div></section></div></div></div></div></div></div><script src="/_next/static/chunks/webpack-14bcfdf71a1473f7.js" crossorigin="" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/0c7e3e2387401c47-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/6566b64e7f0e478f.css\",\"style\",{\"crossOrigin\":\"\"}]\n0:\"$L3\"\n"])</script><script>self.__next_f.push([1,"4:I[3728,[],\"\"]\n6:I[9928,[],\"\"]\n7:I[9248,[\"576\",\"static/chunks/576-dc377cf448834f03.js\",\"251\",\"static/chunks/251-ef7560cc4f7a9f6d.js\",\"185\",\"static/chunks/app/layout-5bdea2f994faa404.js\"],\"\"]\n8:I[179,[\"576\",\"static/chunks/576-dc377cf448834f03.js\",\"251\",\"static/chunks/251-ef7560cc4f7a9f6d.js\",\"185\",\"static/chunks/app/layout-5bdea2f994faa404.js\"],\"\"]\n9:I[6962,[\"576\",\"static/chunks/576-dc377cf448834f03.js\",\"251\",\"static/chunks/251-ef7560cc4f7a9f6d.js\",\"185\",\"static/chunks/app/layout-5bdea2f994faa404.js\"],\"\"]\na"])</script><script>self.__next_f.push([1,":I[6954,[],\"\"]\nb:I[7264,[],\"\"]\n"])</script><script>self.__next_f.push([1,"3:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/6566b64e7f0e478f.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]],[\"$\",\"$L4\",null,{\"buildId\":\"2YqwK_FmVSoyGW4SvqkcX\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/blog/threejs\",\"initialTree\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"category\",\"threejs\",\"d\"],{\"children\":[\"__PAGE__?{\\\"category\\\":\\\"threejs\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialHead\":[false,\"$L5\"],\"globalErrorComponent\":\"$6\",\"children\":[null,[\"$\",\"html\",null,{\"lang\":\"ko\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_7bb6ba\",\"children\":[\"$\",\"div\",null,{\"className\":\"w-full\\n            h-full\\n            overflow-y-scroll\\n            overflow-x-auto\",\"children\":[\"$\",\"$L7\",null,{\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"$L9\",null,{\"style\":{\"minHeight\":\"calc(100% - 72px)\"},\"children\":[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"childProp\":{\"current\":[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[null,\"$Lc\",null],\"segment\":[\"category\",\"threejs\",\"d\"]},\"styles\":null}],\"segment\":\"blog\"},\"styles\":null}]}]]}]}]}]}],null]}]]\n"])</script><script>self.__next_f.push([1,"d:I[689,[\"281\",\"static/chunks/08ffe114-a8e3ed06beefbf38.js\",\"465\",\"static/chunks/48507feb-6de01ca04009bb96.js\",\"306\",\"static/chunks/39209d7c-a33d4549f726b4ab.js\",\"576\",\"static/chunks/576-dc377cf448834f03.js\",\"251\",\"static/chunks/251-ef7560cc4f7a9f6d.js\",\"75\",\"static/chunks/app/blog/%5Bcategory%5D/layout-7ae3540a4673a57a.js\"],\"\"]\n"])</script><script>self.__next_f.push([1,"c:[\"$\",\"div\",null,{\"children\":[\"$\",\"div\",null,{\"className\":\"w-full\\n                    flex items-start\",\"children\":[[\"$\",\"$Ld\",null,{\"className\":\"shrink-0\\n                        ml-auto\\n                        h-[calc(100vh-72px)]\\n                        sticky top-[72px]\\n                        overflow-auto\\n                        max-[600px]:w-0\",\"navTitle\":\"블로그 카테고리\"}],[\"$\",\"div\",null,{\"style\":{\"maxWidth\":\"980px\"},\"className\":\"flex-1\\n                        mr-auto\\n                        w-full\\n                        overflow-x-hidden\",\"children\":[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",[\"category\",\"threejs\",\"d\"],\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$Le\",\"$Lf\",null],\"segment\":\"__PAGE__?{\\\"category\\\":\\\"threejs\\\"}\"},\"styles\":null}]}]]}]}]\n"])</script><script>self.__next_f.push([1,"5:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Chocobe Blog v2\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"Frontend 기술 블로그 입니다.\"}],[\"$\",\"link\",\"4\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"5\",{\"name\":\"next-size-adjust\"}]]\n"])</script><script>self.__next_f.push([1,"e:null\n"])</script><script>self.__next_f.push([1,"10:I[2317,[\"576\",\"static/chunks/576-dc377cf448834f03.js\",\"251\",\"static/chunks/251-ef7560cc4f7a9f6d.js\",\"128\",\"static/chunks/128-a9a4b8134fdbdc1d.js\",\"254\",\"static/chunks/app/blog/%5Bcategory%5D/page-864fbedea356ae73.js\"],\"\"]\n11:Te10,"])</script><script>self.__next_f.push([1,"---\nid: 10\ntitle: 'Gamma, GammFactor, sRGB 정리'\ndescription: '디지털 환경에서 색상을 표현하는데 사용되는 일부 개념들을 정리합니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: true\ntags: [\n    'threejs',\n    'gamma',\n    'gamma factor',\n    'sRGB',\n]\n\ncreatedAt: '2024-01-28 18:00:00'\nmodifiedHistories: []\n---\n\n# Gamma, GammFactor, sRGB 정리\n\nThree.js 를 스터디하며 아래와 같은 용어를 접하게 되었습니다.\n\n* Gamma\n* GammaFactor`\n* sRGB\n\n\u003cbr /\u003e\n\n이번 포스팅에서는 위 용어에 대한 개념을 정리하고 Three.js 에서는 어떻게 설정할 수 있는지 살펴 보겠습니다.\n\n\u003e 참고: [What is Gamma? - Benq](https://www.benq.com/en-us/knowledge-center/knowledge/gamma-monitor.html)\n\u003e\n\u003e 참고: [Deprecated Gamma Correction Alternative - discourse.threejs](https://discourse.threejs.org/t/deprecated-gamma-correction-alternative/57170)\n\u003e\n\u003e 참고: [sRGB - 위키피디아](https://en.wikipedia.org/wiki/SRGB)\n\n\n\n\u003cbr /\u003e\n\n\n\n## Gamma 란?\n\nGamma 는 이미지나 색상을 처리하는 기술 중 하나입니다.\n\n**색상간의 밝기와 대비를 보정** 하거나, 사용자 **모니터의 특성을 보상** 하기 위해 사용되는 기술입니다.\n\n\u003cbr /\u003e\n\n좀 더 구체적으로 정의한다면 다음과 같습니다.\n\n* **디지털 환경에서 Black 과 White 사이를 얼마나 부드럽게 전환(표현)할 것인지에 대한 수치** 입니다.\n\n\u003cbr /\u003e\n\nGamma 는 **sRGB (Standard RGB)** 환경에서 사용되는 개념이며, 아래에서 정리하겠습니다.\n\n\u003cbr /\u003e\n\nGamma 는 일반적으로 **2.2** 값을 사용합니다.\n\n이 값은 **Gamma Curve** 를 그리는 연산식의 도출값인데, 값에 따른 차이를 비교하면 아래와 같습니다.\n\n\u003e 이미지 출처: [Deprecated Gamma Correction Alternative - discourse.threejs](https://discourse.threejs.org/t/deprecated-gamma-correction-alternative/57170)\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-28-01/2024-01-28-01-01.png\" alt=\"Gamma\" /\u003e\n\n\u003cbr /\u003e\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-28-01/2024-01-28-01-02.png\" alt=\"Gamma\" /\u003e\n\n\u003cbr /\u003e\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-28-01/2024-01-28-01-03.png\" alt=\"Gamma\" /\u003e\n\n\n\n## GammaFactor\n\nGammaFactor 는 Three.js 에서 Gamma 를 지칭하는 property 입니다.\n\nThree.js 구버전에서는 `WebGLRenderer` 인스턴스의 property 로 `gammaFactor` 를 설정할 수 있었습니다.\n\n`gammaFactor` 는 Three.js 에서 **Deprecated** 되었고, 포스팅을 작성하는 시점의 Three.js 최신 버전인 `0.160.1` 에서는 사라진 설정입니다.\n\n\u003cbr /\u003e\n\n만약 구버전 Three.js 코드에서 `gammaFactor` 설정을 보게 된다면, 최신 버전에서는 **Light** 인스턴스의 **intensity (빛의 강함 설정)** 을 사용해 봅시다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## sRGB\n\nsRGB 는 **Standard RGB Color Space** 의 약자 입니다.\n\n모니터, 프린터, 웹 과 같은 디지털 환경에서 색상을 표현하귀 위한 **표준 색상 공간(환경)** 입니다.\n\n앞서 살펴보았던 **Gamma 의 기본값이 2.2 인 것은 sRGB 의 값을 2.2 로 사용** 한다는 의미로 보여집니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\nThree.js 스터디를 하는 중, gammaFactor 설정이 궁금하여 이번 포스팅을 작성하게 되었습니다.\n\n의미와 용도 정도만 파악하려는 목적이었지만, gamma 와 sRGB 는 상당히 깊고 어려운 내용이었습니다.\n\n지금은 간단한 의미 정도만 파악한 후, 차후 필요성이 생겼을 때 좀 더 깊게 알아볼 예정입니다.\n"])</script><script>self.__next_f.push([1,"12:T4115,"])</script><script>self.__next_f.push([1,"---\nid: 16\ntitle: 'Particle 로 반딧불이 표현하기'\ndescription: '3D 환경에서 반딧불이나 별을 표현할 때 Particle 을 활용합니다. 매우 많은 입자들로 표현하는 Particle 을 어떻게 구현하는지 정리하고자 합니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    '3D',\n    'Particle',\n    'BufferGeometry',\n    'PointsMaterial',\n    'Points',\n]\n\ncreatedAt: '2024-02-29 20:00:00'\nmodifiedHistories: []\n---\n\n# Particle 로 반딧불이 표현하기\n\n반딧불이나 별은 매우 많은 입자들로 표현합니다.\n\n이를 3D 그래픽스에서는 Particle 이라고 합니다.\n\n각각의 입자를 개별 Mesh 로 구현한다면 화면이 버벅이거나 실행할 수 없는 경우까지 발생할 수 있습니다.\n\n\u003cbr /\u003e\n\n이번 포스팅에서는 컴퓨터 성능을 저해하지 않으면서 Particle 을 구현하는 방법에 대해 정리하고자 합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 예시 코드\n\n\u003e [Model 다운로드 링크](https://polyhaven.com/a/coast_rocks_05)\n\n이번 포스팅의 예시코드는 위 모델을 렌더링한 시점입니다.\n\n```js title=\"예시 코드\" showLineNumbers\n// three.js\nimport {\n    WebGLRenderer,\n    ACESFilmicToneMapping,\n\n    Scene,\n\n    PerspectiveCamera,\n\n    AxesHelper,\n\n    Color,\n    DirectionalLight,\n    DirectionalLightHelper,\n} from 'three';\n// three.js - addons\nimport {\n    OrbitControls,\n} from 'three/examples/jsm/controls/OrbitControls';\nimport {\n    GLTFLoader,\n} from 'three/examples/jsm/loaders/GLTFLoader';\n// style\nimport './style.css';\n\n//\n// state\n//\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { OrbitControls } */\nlet controls;\n\n//\n// core\n//\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app?.appendChild($canvas);\n\n    return $canvas;\n}\n\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.setPixelRatio(window.devicePixelRatio);\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.toneMapping = ACESFilmicToneMapping;\n    renderer.shadowMap.enabled = true;\n}\n\nfunction initScene() {\n    scene = new Scene();\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n\n    camera.fov = 30;\n    camera.aspect = window.innerWidth / window.innerHeight;\n\n    camera.near = 0.5;\n    camera.far = 2_000;\n\n    camera.position.set(0, 0, 5);\n    camera.lookAt(0, 0, 0);\n\n    camera.updateProjectionMatrix();\n}\n\nfunction initAxesHelper() {\n    const helper = new AxesHelper(1);\n\n    scene.add(helper);\n}\n\nfunction initControls($target) {\n    controls = new OrbitControls(camera, $target);\n    controls.enableDamping = true;\n}\n\n//\n// light\n//\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n\n    const light = new DirectionalLight(\n        color,\n        Math.PI * 1\n    );\n\n    light.position.set(-2, 2, 1);\n    light.lookAt(0, 0, 0);\n\n    light.castShadow = true;\n\n    const helper = new DirectionalLightHelper(light);\n\n    scene.add(light);\n    scene.add(helper);\n}\n\n//\n// model\n//\nfunction initModel() {\n    const loader = new GLTFLoader();\n\n    loader.load('/gltf/coast-rocks-05/coast_rocks_05_4k.gltf', gltf =\u003e {\n        const model = gltf.scene;\n        model.position.set(0, -0.5, 0);\n\n        model.traverse(child =\u003e {\n            if (!child.isMesh) {\n                return;\n            }\n\n            child.castShadow = true;\n            child.receiveShadow = true;\n        });\n\n        scene.add(model);\n    });\n}\n\n//\n// executor\n//\nfunction render() {\n    window.requestAnimationFrame(render);\n\n    renderer.render(scene, camera);\n    controls?.update();\n}\n\n(function init() {\n    const $canvas = initCanvas();\n\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n    initAxesHelper();\n    initControls($canvas);\n\n    initDirectionalLight();\n\n    initModel();\n\n    render();\n}());\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-02-29-01/2024-02-29-01-01.png\" alt=\"예시 코드 결과\" /\u003e\n\n\n\n\n\u003cbr /\u003e\n\n\n\n## Particle 구현 흐름\n\n3D 환경에서 물체를 렌더링하기 위해, Geometry 와 Material 을 조합한 Mesh 를 사용합니다.\n\nParticle 은 Mesh 가 아닌 **Points** 객체로 만들 수 있습니다.\n\nPoints 를 생성할 때도 Mesh 처럼 Geometry 와 Material 이 필요합니다.\n\n\u003cbr /\u003e\n\nParticle 을 만드는 과정을 간략하게 표현하면 다음과 같습니다.\n\n1. **BufferGeometry** 객체 생성하기\n2. **PointsMaterial** 객체 생성하기\n3. BufferGeometry 와 PointsMaterial 을 인자로 사용하여 **Points** 객체 생성하기\n4. `scene.add()` 로 등록하기\n\n\n\n\u003cbr /\u003e\n\n\n\n## 1. BufferGeometry 만들기\n\nParticle 의 Geometry 는 **BufferGeometry** 로 만들 수 있습니다.\n\nBufferGeometry 는 buffer 라는 개념을 사용한 Geometry 이며, 다음과 같은 과정으로 생성합니다.\n\n1. **Float32Array** 객체 생성\n2. Float32Array 를 사용하여 **BufferAttribute** 객체 생성\n3. **BufferGeometry** 객체 생성\n4. **BufferGeometry** 의 position 속성에 BufferGeometry 적용\n\n\n\n\u003cbr /\u003e\n\n\n\n### 1. Float32Array 객체 생성\n\n* [참고: JavaScript 형식화 배열 - MDN 공식문서](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Typed_arrays)\n\n* [참고: Float32Array - MDN 공식문서](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Float32Array)\n\n\u003cbr /\u003e\n\nFloat32Array 는 **형식화 배열** 입니다.\n\n자바스크립트의 Array 는 배열 길이를 동적으로 사용할 수 있고, Tuple 로도 활용할 수 있습니다.\n\n형식화 배열은 Java 와 같은 정적 언어의 배열처럼 고정된 길이의 Array 입니다.\n\n참고로 형식화 배열은 자바스크립트에서 Array 와 구분하고 있으며, `형식화_배열.__proto__.isArray()` 는 **false** 를 반환합니다.\n\n\u003cbr /\u003e\n\nFloat32Array 는 **부동소수로 구성된 형식화 배열** 입니다.\n\n비디오나 오디오와 같은 리소스를 빠르게 제어하기 위해 사용되는 빌트인 객체 입니다.\n\n우리가 생성할 buffer 는 각 Particle 입자들의 x, y, z 좌표값으로 생성할 예정입니다.\n\n아래는 buffer 의 예시이며, 1차원 배열에 x, y, z 좌표값이 순서대로 나열된 형태 입니다.\n\n```bash title=\"buffer 구조 예시\"\n[\n    x1, y1, z1,\n    x2, y2, z2,\n    x3, y3, z3,\n]\n```\n\n\u003cbr /\u003e\n\n500개의 Particle 을 표현하기 위한 Float32Array 를 생성하면 다음과 같습니다.\n\n```js title=\"1. Float32Array 객체 생성\" showLineNumbers{140}\n//\n// particle\n//\nconst PARTICLE_AXIS = {\n    X: 0,\n    Y: 1,\n    Z: 2,\n};\n\nfunction initParticle() {\n    const buffer = new Float32Array(Array.from(\n        // 3개의 요소가 Particle 1개의 x, y, z 좌표값이 되며, 500 개를 생성합니다.\n        { length: 3 * 500 },\n        (_, i) =\u003e {\n            const randomValue = Math.random();\n            const axis = i % 3;\n\n            switch (axis) {\n                case PARTICLE_AXIS.X:\n                case PARTICLE_AXIS.Z:\n                    return (randomValue * 2 - 1) * 2;\n                case PARTICLE_AXIS.Y:\n                default:\n                    return randomValue * 2;\n            }\n        }\n    ));\n}\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n### 2. Float32Array 를 사용하여 **BufferAttribute** 객체 생성\n\nBufferGeometry 는 Particle 의 Geometry 로 활용됩니다.\n\nBufferGeometry 에 buffer 를 직접 적용할 수는 없고, **BufferAttribute** 객체를 통해서만 적용할 수 있습니다.\n\n```js title=\"BufferAttribute import 하기\" showLineNumbers {16}\n// three.js\nimport {\n    WebGLRenderer,\n    ACESFilmicToneMapping,\n\n    Scene,\n\n    PerspectiveCamera,\n\n    AxesHelper,\n\n    Color,\n    DirectionalLight,\n    DirectionalLightHelper,\n\n    BufferAttribute,\n} from 'three';\n```\n\n```js title=\"2. Float32Array 를 사용하여 BufferAttribute 객체 생성\" showLineNumbers{142} {28}\n//\n// particle\n//\nconst PARTICLE_AXIS = {\n    X: 0,\n    Y: 1,\n    Z: 2,\n};\n\nfunction initParticle() {\n    const buffer = new Float32Array(Array.from(\n        { length: 3 * 500 },\n        (_, i) =\u003e {\n            const randomValue = Math.random();\n            const axis = i % 3;\n\n            switch (axis) {\n                case PARTICLE_AXIS.X:\n                case PARTICLE_AXIS.Z:\n                    return (randomValue * 2 - 1) * 2;\n                case PARTICLE_AXIS.Y:\n                default:\n                    return randomValue * 2;\n            }\n        }\n    ));\n\n    const positionAttribute = new BufferAttribute(buffer, 3);\n}\n```\n\n\u003cbr /\u003e\n\nBufferAttribute 생성자는 다음과 같은 interface 를 가집니다.\n\n```typescript\nclass BufferAttribute {\n    constructor(\n        // 형식화 배열\n        array: TypedArray, \n\n        // 입자 하나를 이루는 요소(좌표값) 개수\n        itemSize: number\n    );\n}\n```\n\n\u003cbr /\u003e\n\n우리가 생성한 buffer 는 x, y, z 3개의 좌표가 1개의 입자를 표현하므로, 아래와 같이 BufferAttribute 를 생성하였습니다.\n\n```js\nconst positionAttribute = new BufferAttribute(buffer, 3);\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n### 3. **BufferGeometry** 객체 생성\n\nBufferGeometry 객체를 생성해 보겠습니다.\n\n```js title=\"BufferGeometry import 하기\" showLineNumbers {17}\n// three.js\nimport {\n    WebGLRenderer,\n    ACESFilmicToneMapping,\n\n    Scene,\n\n    PerspectiveCamera,\n\n    AxesHelper,\n\n    Color,\n    DirectionalLight,\n    DirectionalLightHelper,\n\n    BufferAttribute,\n    BufferGeometry,\n} from 'three';\n```\n\n```js title=\"BufferGeometry 객체 생성\" showLineNumbers{143} {30}\n//\n// particle\n//\nconst PARTICLE_AXIS = {\n    X: 0,\n    Y: 1,\n    Z: 2,\n};\n\nfunction initParticle() {\n    const buffer = new Float32Array(Array.from(\n        { length: 3 * 500 },\n        (_, i) =\u003e {\n            const randomValue = Math.random();\n            const axis = i % 3;\n\n            switch (axis) {\n                case PARTICLE_AXIS.X:\n                case PARTICLE_AXIS.Z:\n                    return (randomValue * 2 - 1) * 2;\n                case PARTICLE_AXIS.Y:\n                default:\n                    return randomValue * 2;\n            }\n        }\n    ));\n\n    const positionAttribute = new BufferAttribute(buffer, 3);\n\n    const geometry = new BufferGeometry();\n}\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 4. **BufferGeometry** 의 position 속성에 BufferGeometry 적용\n\nBufferGeometry 객체는 `setAttribute('속성명', BufferAttribute_객체)` 메소드를 사용하여 프로퍼티를 변경할 수 있습니다.\n\nBufferGeometry 의 attribute 중, 좌표값은 **'position'** 으로 사용합니다.\n\n```js title=\"BufferGeometry 의 position 속성에 BufferGeometry 적용\" showLineNumbers{143} {31}\n//\n// particle\n//\nconst PARTICLE_AXIS = {\n    X: 0,\n    Y: 1,\n    Z: 2,\n};\n\nfunction initParticle() {\n    const buffer = new Float32Array(Array.from(\n        { length: 3 * 500 },\n        (_, i) =\u003e {\n            const randomValue = Math.random();\n            const axis = i % 3;\n\n            switch (axis) {\n                case PARTICLE_AXIS.X:\n                case PARTICLE_AXIS.Z:\n                    return (randomValue * 2 - 1) * 2;\n                case PARTICLE_AXIS.Y:\n                default:\n                    return randomValue * 2;\n            }\n        }\n    ));\n\n    const positionAttribute = new BufferAttribute(buffer, 3);\n\n    const geometry = new BufferGeometry();\n    geometry.setAttribute('position', positionAttribute);\n}\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 2. **PointsMaterial** 객체 생성 및 Particle 렌더링하기\n\nParticle 의 Material 은 **PointsMaterial** 을 사용합니다.\n\n각 Particle 의 재질에 **이미지 파일** 을 패턴으로 사용하도록 만들고자 합니다.\n\n\u003cbr /\u003e\n\nPointsMaterial 과 BufferGeometry 를 생성하였으므로, **Points** 객체를 생성하여 Particle 을 렌더링할 수 있습니다.\n\n```js title=\"PointsMaterial, Points import 하기\" showLineNumbers {18-20}\n// three.js\nimport {\n    WebGLRenderer,\n    ACESFilmicToneMapping,\n\n    Scene,\n\n    PerspectiveCamera,\n\n    AxesHelper,\n\n    Color,\n    DirectionalLight,\n    DirectionalLightHelper,\n\n    BufferAttribute,\n    BufferGeometry,\n    PointsMaterial,\n    TextureLoader,\n    Points,\n} from 'three';\n```\n\n```js title=\"PointsMaterial 객체 생성 및 Particle 렌더링하기\" showLineNumbers{146} {33-40}\n//\n// particle\n//\nconst PARTICLE_AXIS = {\n    X: 0,\n    Y: 1,\n    Z: 2,\n};\n\nfunction initParticle() {\n    const buffer = new Float32Array(Array.from(\n        { length: 3 * 500 },\n        (_, i) =\u003e {\n            const randomValue = Math.random();\n            const axis = i % 3;\n\n            switch (axis) {\n                case PARTICLE_AXIS.X:\n                case PARTICLE_AXIS.Z:\n                    return (randomValue * 2 - 1) * 2;\n                case PARTICLE_AXIS.Y:\n                default:\n                    return randomValue * 2;\n            }\n        }\n    ));\n\n    const positionAttribute = new BufferAttribute(buffer, 3);\n\n    const geometry = new BufferGeometry();\n    geometry.setAttribute('position', positionAttribute);\n\n    const material = new PointsMaterial({\n        map: new TextureLoader().load('/particle/circle.png'),\n        size: 1,\n    });\n\n    const particle = new Points(geometry, material);\n\n    scene.add(particle);\n}\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-02-29-01/2024-02-29-01-02.png\" alt=\"Particle 만들기\" /\u003e\n\n\u003cbr /\u003e\n\n위 코드에서 PointsMaterial 을 생성하는 부분을 살펴보겠습니다.\n\nPointsMaterial 생성자에 넘겨준 params 에 `map` 속성이 있습니다.\n\n`map` 속성을 사용하여 Particle 하나에 적용시킬 이미지를 **Texture** 로 넘겨줄 수 있습니다.\n\n```js\nconst loader = new TextureLoader();\nconst texture = loader.load('이미지_경로');\n```\n\n\u003cbr /\u003e\n\n우리가 넘겨준 이미지는 배경을 투명하게 처리한 `png` 임에도 불구하고, 렌더링 결과에는 이미지의 투명도가 적용되지 않은 상태 입니다.\n\n이를 해결하기 위해, PointsMaterial 생성자 params 에 추가 설정이 필요합니다.\n\n아래와 같이 추가해 보겠습니다.\n\n```js title=\"AdditiveBelnding import 하기\" showLineNumbers {21}\n// three.js\nimport {\n    WebGLRenderer,\n    ACESFilmicToneMapping,\n\n    Scene,\n\n    PerspectiveCamera,\n\n    AxesHelper,\n\n    Color,\n    DirectionalLight,\n    DirectionalLightHelper,\n\n    BufferAttribute,\n    BufferGeometry,\n    PointsMaterial,\n    TextureLoader,\n    Points,\n    AdditiveBlending,\n} from 'three';\n```\n\n```js title=\"PointsMaterial 에 투명도 설정하기\" showLineNumbers{147} {36-48}\n//\n// particle\n//\nconst PARTICLE_AXIS = {\n    X: 0,\n    Y: 1,\n    Z: 2,\n};\n\nfunction initParticle() {\n    const buffer = new Float32Array(Array.from(\n        { length: 3 * 500 },\n        (_, i) =\u003e {\n            const randomValue = Math.random();\n            const axis = i % 3;\n\n            switch (axis) {\n                case PARTICLE_AXIS.X:\n                case PARTICLE_AXIS.Z:\n                    return (randomValue * 2 - 1) * 2;\n                case PARTICLE_AXIS.Y:\n                default:\n                    return randomValue * 2;\n            }\n        }\n    ));\n\n    const positionAttribute = new BufferAttribute(buffer, 3);\n\n    const geometry = new BufferGeometry();\n    geometry.setAttribute('position', positionAttribute);\n\n    const material = new PointsMaterial({\n        map: new TextureLoader().load('/particle/circle.png'),\n\n        // Particle 1개의 크기\n        size: 0.5,\n        // Particle 색상\n        color: new Color('#006400'),\n        // Particle 투명도\n        opacity: 0.5,\n\n        // 투명도 사용여부\n        transparent: true,\n        // Particle 과 겹치는 부분의 색상을 처리(섞는) 방식 설정\n        blending: AdditiveBlending,\n        // Particle 의 깊이 표현 여부\n        depthWrite: false,\n    });\n\n    const particle = new Points(geometry, material);\n\n    scene.add(particle);\n}\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-02-29-01/2024-02-29-01-03.png\" alt=\"Particle 만들기\" /\u003e\n\n\u003cbr /\u003e\n\n**PointsMaterial** 에 투명도를 설정할 때는 아래의 설정이 함께 필요합니다.\n\n* `transparent: true`\n* `blending: AdditiveBlending`\n* `depthWrite: true`\n\n\n\n\u003cbr /\u003e\n\n\n\n### 마치며\n\nThree.js 의 Particle 생성 방법을 스터디하기 전까지는 개별 Particle 요소를 하나하나 만들어야 하는 것 같았습니다.\n\n이번 포스팅을 통해 Particle 을 효과적으로 활용할 수 있을 것 같습니다.\n"])</script><script>self.__next_f.push([1,"13:Tf6c,"])</script><script>self.__next_f.push([1,"---\nid: 15\ntitle: 'Material 의 map, bumpMap, normalMap'\ndescription: 'Material 의 표현 방식과 울퉁불퉁한 재질을 처리하는 방식을 정리합니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    '3D',\n    'Material',\n    'Texture',\n    'map',\n    'bumpMap',\n    'normalMap',\n]\n\ncreatedAt: '2024-02-12 15:17:30'\nmodifiedHistories: []\n---\n\n# Material 의 map, bumpMap, normalMap\n\nMesh 는 형태를 정의하는 Geometry 와 재질을 표현하는 Material 로 구성합니다.\n\n이번 포스팅에서는 Material 의 표면 처리 방식에 대해 정리합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## Material 에 Texture Image 설정\n\nMaterial 은 다양한 종류가 있습니다.\n\n재질을 표현하기 위해 **Texture Image** 를 입힐 때, `TextureLoader` class 를 사용하여 **이미지 파일 (.png 등)** 을 사용할 수 있습니다.\n\nTexture Image 를 Material 에 적용하는 가장 기본 속성은 `map` 입니다.\n\n아래는 MeshStandardMaterial 에 map 을 사용하여 Texture Image 를 입히는 예시코드 입니다.\n\n```js title=\"map 속성으로 Texture Image 입히기\"\nimport {\n    MeshStandardMaterial,\n    TextureLoader,\n} from 'three';\n\nfunction createMaterial() {\n    const material = new MeshStandardMaterial({\n        map: new TextureLoader().load('/imgs/my-image.png'),\n    });\n}\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## bumpMap 과 normalMap\n\n모든 Material 이 갖지는 않지만, **MeshStandardMaterial** 과 **MeshPhysicalMaterial** 등 에는 또다른 map 속성이 있습니다.\n\n```js title=\"bumpMap 과 normalMap 속성\"\nimport {\n    MeshStandardMaterial,\n    TextureLoader,\n} from 'three';\n\nfunction initMaterial() {\n    const material = new MeshStandardMaterial({\n        map: new TextureLoader().load('/imgs/my-image.png'),\n        bumpMap: new TextureLoader().load('/imgs/my-image.png'),\n        normalMap: new TextureLoader().load('/imgs/my-image.png'),\n    });\n}\n```\n\n* `bumpMap`\n* `normalMap`\n\n\u003cbr /\u003e\n\n물론 `map` 속성도 사용할 수 있지만, 재질을 표현하는 방식과 결과에 차이가 있습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## map, bumpMap, normalMap 정의\n\n* map\n    * 단순 이미지(.png 등) 을 표면에 입혀줍니다.\n    * Light 에 영향을 받지 않습니다.\n    * 가장 낮은 성능을 사용합니다.\n* bumpMap\n    * 3D Graphics 용어 의미\n        * **표면이 조금씩 불규칙한 부분** 을 의미합니다.\n    * 이미지의 밝거나 어두운 부분을 표면의 시각적인 높낮이로 표현합니다.\n        * 밝은 부분: 높게 표현\n        * 어두운 부분: 낮게 표현\n    * Light 에 영향을 받지 않습니다.\n    * map 보다 많은 성능을 사용합니다.\n* normalMap\n    * 3D Graphics 용어 의미\n        * **표면의 수직 방향 벡터** 를 의미합니다.\n    * **법선 벡터 (Normal Vector)** 를 사용하여 **Light 의 반사 방향** 조정하며, 결과적으로 **Light 와 상호작용하여 입체감을 표현** 합니다.\n    * bumpMap 보다 많은 성능을 사용합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## map, bumpMap, normalMap 사용처\n\nmap 방식에 따라 성능차이와 렌더링 차이가 있으므로, 사용처에 따라 적합한 선택이 필요 합니다.\n\n* map\n    * 단순 이미지를 입히거나 패턴으로 사용할 때 적합합니다.\n* bumpMap\n    * 흙이나 벽돌처럼 울퉁불퉁한 질감을 표현할 때 사용합니다.\n* normalMap\n    * 울퉁불퉁함을 넘어 입체감까지 표현할 때 사용합니다.\n    * Light 와 상호작용이 필요할 때 사용합니다.\n\n\u003cbr /\u003e\n\n표현할 재질에 따라 map, bumpMap, normalMap 을 혼합하여 사용하기도 합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며...\n\nThree.js 자체의 학습보다는 3D Graphics 개념을 파악하는 것이 더 어려운 것 같습니다.\n\nThree.js 공식 문서는 API 소개 정도만 안내하고 있어서 아쉽습니다.\n"])</script><script>self.__next_f.push([1,"14:T4780,"])</script><script>self.__next_f.push([1,"---\nid: 14\ntitle: 'click 이벤트에 animation 연동하기'\ndescription: '특정 버튼을 click 했을 때 animation 을 실행하는 방법을 정리합니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    '3D',\n    'mouse event',\n    'click interaction',\n    'animation',\n    'AnimationMixer',\n    'AnimationClip',\n    'AnimationAction',\n]\n\ncreatedAt: '2024-02-06 15:00:00'\nmodifiedHistories: []\n---\n\n# click 이벤트에 animation 연동하기\n\nAnimation 은 이전 포스팅 [Model 에 Animation 효과 적용하기](https://chocobe.github.io/blog/threejs/2024-01-26-01) 에서 한번 사용해 보았습니다.\n\n사용자 인터렉션이 아닌, 동영상 링크처럼 자동 재생되는 형식으로 구현했습니다.\n\n이번 포스팅에서는 버튼을 click 했을 때, 해당 버튼의 Animation 만 실행되도록 구현해 보고자 합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 예시 코드\n\n예시코드에서 사용한 Model 은 [상상력을 자극하는 고퀄리티 3D 인터랙티브 웹 제작 (최인 강사님)](https://coloso.co.kr/products/graphicdesign-choiin) 강좌 리소스를 사용하였습니다.\n\n3D Tool 에서 Model 에 Keyframe Animation 을 함께 포함시켰을 때, 이 Animation 을 Three.js 에서 필요한 시점에만 실행시키는 동작을 구현할 예정입니다.\n\n\u003cbr /\u003e\n\n아래 예시 코드는 클릭한 버튼의 color 를 scene 의 배경과 rocket model 에 적용하는 기능까지 구현한 상태 입니다.\n\n```js title=\"예시 코드\" showLineNumbers\n// three\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n    ACESFilmicToneMapping,\n\n    Color,\n    DirectionalLight,\n    HemisphereLight,\n\n    MeshStandardMaterial,\n\n    Vector2,\n    Raycaster,\n} from 'three';\n// three.js - addons\nimport {\n    GLTFLoader,\n} from 'three/examples/jsm/loaders/GLTFLoader';\n// style\nimport './style.css';\n\n//\n// state\n//\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n//\n// core\n//\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.setPixelRatio(window.devicePixelRatio);\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.toneMapping = ACESFilmicToneMapping;\n    renderer.shadowMap.enabled = true;\n}\n\nfunction initScene() {\n    scene = new Scene();\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n\n    camera.fov = 45;\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.near = 0.5;\n    camera.far = 2000;\n\n    camera.position.set(100, 100, 100);\n    camera.lookAt(-20, 0, -20);\n\n    camera.updateProjectionMatrix();\n}\n\n//\n// light\n//\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n\n    const light = new DirectionalLight(\n        color,\n        Math.PI * 1\n    );\n\n    light.position.set(-1, 1, 0.5);\n    light.lookAt(0, 0, 0);\n    light.castShadow = true;\n\n    light.shadow.mapSize.set(1024, 1024);\n    light.shadow.camera.near = 0.5;\n    light.shadow.camera.far = 500;\n    light.shadow.camera.top = 180;\n    light.shadow.camera.bottom = -120;\n    light.shadow.camera.left = -100;\n    light.shadow.camera.right = 100;\n\n    scene.add(light);\n}\n\nfunction initHemisphereLight() {\n    const skyColor = new Color('#fff');\n    const groundColor = new Color('#555');\n\n    const light = new HemisphereLight(\n        skyColor,\n        groundColor,\n        Math.PI * 0.5\n    );\n\n    light.position.set(0, -1, 0);\n\n    scene.add(light);\n}\n\n//\n// model\n//\nfunction initModel() {\n    const loader = new GLTFLoader();\n\n    loader.load('/gltf/click.glb', gltf =\u003e {\n        const model = gltf.scene;\n\n        const ratio = 0.1;\n        model.scale.set(ratio, ratio, ratio);\n        model.position.set(0, 0, 0);\n\n        model.traverse(child =\u003e {\n            if (!child.isMesh) {\n                return;\n            }\n\n            child.castShadow = true;\n            child.receiveShadow = true;\n\n            child.material = new MeshStandardMaterial({\n                color: child.material.color,\n                roughness: 0.3,\n            });\n        });\n\n        scene.add(model);\n    });\n}\n\n//\n// interaction\n//\nfunction initResize() {\n    window.addEventListener('resize', () =\u003e {\n        renderer.setSize(window.innerWidth, window.innerHeight);\n\n        camera.aspect = window.innerWidth / window.innerHeight;\n        camera.updateProjectionMatrix();\n    });\n}\n\nfunction initClickInteraction($target) {\n    const raycaster = new Raycaster();\n\n    $target.addEventListener('click', e =\u003e {\n        const {\n            clientX,\n            clientY,\n        } = e;\n\n        const mouseCoord = new Vector2(\n            (clientX / window.innerWidth) * 2 - 1,\n            -(clientY / window.innerHeight) * 2 + 1\n        );\n\n        raycaster.setFromCamera(mouseCoord, camera);\n\n        const intersects = raycaster.intersectObjects(scene.children, true);\n        const firstModel = intersects[0]?.object;\n\n        if (!firstModel || !firstModel.name.match(/^button.*/)) {\n            return;\n        }\n\n        const rocketChangingModel = scene.getObjectByName('change');\n\n        const buttonColor = firstModel.material.color;\n\n        rocketChangingModel.material.color = buttonColor;\n        scene.background = buttonColor;\n    });\n}\n\n//\n// executor\n//\nfunction render() {\n    window.requestAnimationFrame(render);\n\n    renderer.render(scene, camera);\n}\n\n(function init() {\n    const $canvas = initCanvas();\n\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n\n    initDirectionalLight();\n    initHemisphereLight();\n\n    initModel();\n\n    initResize();\n    initClickInteraction($canvas);\n\n    render();\n}());\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## AnimationMixer 만들기\n\nModel 에 포함된 Animation 을 실행시키기 위해서는 **AnimationMixer** 가 필요 합니다.\n\nAnimationMixer 는 **애니메이션 플레이어** 역할을 합니다.\n\n실행시킬 Animation 을 AnimationMixer 에 등록 시켜주고, `render()` 함수에서 `animationMixer.update(프레임)` 으로 다음 장면을 업데이트 해주는 방식으로 동작합니다.\n\n\u003cbr /\u003e\n\n이와 관련한 class 를 살펴보면 다음과 같습니다.\n\n* AnimationMixer: 애니메이션 플레이어 역할을 합니다.\n* AnimationClip: 실행할 애니메이션 1개의 정보를 담고 있습니다.\n* AnimationAction: AnimationClip 을 재생, 정지, 반복 등의 컨트롤 기능을 제공하는 객체 입니다.\n\n\u003cbr /\u003e\n\n애니메이션을 실행하는데 필요한 작업은 다음과 같은 과정이 필요합니다.\n\n1. 애니메이션 대상이 되는 Model 을 사용하여 AnimationMixer 인스턴스를 생성합니다.\n2. Model 에 포함된 `gltf.animations` 를 AnimationMixer 의 `clipAction(clip)` 으로 **AnimationAction** 으로 만듭니다.\n3. click 이벤트가 발생하면, 원하는 AnimationAction 을 실행시킵니다.\n4. 프레임마다 실행되는 `render()` 함수 내부에서 AnimationMixer 의 `update()` 로 장면을 갱신해줍니다.\n\n```js title=\"AnimationMixer import 하기\" showLineNumbers {17-19, 40-41, 43-44}\n// three\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n    ACESFilmicToneMapping,\n\n    Color,\n    DirectionalLight,\n    HemisphereLight,\n\n    MeshStandardMaterial,\n\n    Vector2,\n    Raycaster,\n\n    AnimationMixer,\n    AnimationAction,\n    LoopOnce,\n} from 'three';\n// three.js - addons\nimport {\n    GLTFLoader,\n} from 'three/examples/jsm/loaders/GLTFLoader';\n// style\nimport './style.css';\n\n//\n// state\n//\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { AnimationMixer } */\nlet animationMixer;\n\n/** @type { Record\u003cstring, AnimationAction\u003e } */\nlet animationActions = {};\n```\n\n```js title=\"AnimationMixer 및 AnimationAction 인스턴스 생성하기\" showLineNumbers{129} {28-29, 31-37}\n//\n// model\n//\nfunction initModel() {\n    const loader = new GLTFLoader();\n\n    loader.load('/gltf/click.glb', gltf =\u003e {\n        const model = gltf.scene;\n\n        const ratio = 0.1;\n        model.scale.set(ratio, ratio, ratio);\n        model.position.set(0, 0, 0);\n\n        model.traverse(child =\u003e {\n            if (!child.isMesh) {\n                return;\n            }\n\n            child.castShadow = true;\n            child.receiveShadow = true;\n\n            child.material = new MeshStandardMaterial({\n                color: child.material.color,\n                roughness: 0.3,\n            });\n        });\n\n        // 1. AnimationMixer 생성하기\n        animationMixer = new AnimationMixer(model);\n\n        // 2. AnimationAction 생성하기\n        gltf.animations.forEach(clip =\u003e {\n            const animationAction = animationMixer.clipAction(clip);\n            animationAction.loop = LoopOnce;\n\n            animationActions.push(animationAction);\n        });\n\n        scene.add(model);\n    });\n}\n```\n\n```js title=\"click 시, AnimationAction play() 하기\" showLineNumbers{183} {31-34}\nfunction initClickInteraction($target) {\n    const raycaster = new Raycaster();\n\n    $target.addEventListener('click', e =\u003e {\n        const {\n            clientX,\n            clientY,\n        } = e;\n\n        const mouseCoord = new Vector2(\n            (clientX / window.innerWidth) * 2 - 1,\n            -(clientY / window.innerHeight) * 2 + 1\n        );\n\n        raycaster.setFromCamera(mouseCoord, camera);\n\n        const intersects = raycaster.intersectObjects(scene.children, true);\n        const firstModel = intersects[0]?.object;\n\n        if (!firstModel || !firstModel.name.match(/^button.*/)) {\n            return;\n        }\n\n        const rocketChangingModel = scene.getObjectByName('change');\n\n        const buttonColor = firstModel.material.color;\n\n        rocketChangingModel.material.color = buttonColor;\n        scene.background = buttonColor;\n\n        animationActions.forEach(animationAction =\u003e {\n            animationAction.reset();\n            animationAction.play();\n        });\n    });\n}\n```\n\n```js title=\"render() 함수에서 animationMixer.update() 호출하기\" showLineNumbers{220} {9}\n//\n// executor\n//\nfunction render() {\n    window.requestAnimationFrame(render);\n\n    renderer.render(scene, camera);\n\n    animationMixer?.update(1 / 60);\n}\n```\n\n\u003cvideo width=\"100%\" height=\"auto\" preload=\"none\" autoPlay={true} loop={true} muted={true} controls={false}\u003e\n    \u003csource src=\"/markdownAssets/threejs/2024-02-06-01/2024-02-06-01-01.webm\" type=\"video/webm\" /\u003e\n    animation\n\u003c/video\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## click 한 버튼만 Animation 실행시키기\n\n버튼을 click 하면 모든 버튼의 Animation 이 플레이 되는 것을 볼 수 있습니다.\n\n현재는 click 이벤트가 발생하면, 모든 AnimationAction 을 `play()` 하기 때문입니다.\n\n\u003cbr /\u003e\n\n버튼별 Animation 을 적용하기 위해, Model 에 포함된 `animations` 구조를 파악해야 합니다.\n\n이는 3D Tool 로 구현한 Animations 의 구조에 따라 다르기 때문에, Model animations 의 구조를 파악하고 사용하기 편하게 재구성할 수 있는 능력이 필요합니다.\n\n\u003cbr /\u003e\n\n먼저 Model 의 animations 를 `console` 에서 확인하면 다음과 같습니다.\n\n```js title=\"gltf.animations 구조\" showLineNumbers{129} {39}\n//\n// model\n//\nfunction initModel() {\n    const loader = new GLTFLoader();\n\n    loader.load('/gltf/click.glb', gltf =\u003e {\n        const model = gltf.scene;\n\n        const ratio = 0.1;\n        model.scale.set(ratio, ratio, ratio);\n        model.position.set(0, 0, 0);\n\n        model.traverse(child =\u003e {\n            if (!child.isMesh) {\n                return;\n            }\n\n            child.castShadow = true;\n            child.receiveShadow = true;\n\n            child.material = new MeshStandardMaterial({\n                color: child.material.color,\n                roughness: 0.3,\n            });\n        });\n\n        // 1. AnimationMixer 생성하기\n        animationMixer = new AnimationMixer(model);\n\n        // 2. AnimationAction 생성하기\n        gltf.animations.forEach(clip =\u003e {\n            const animationAction = animationMixer.clipAction(clip);\n            animationAction.loop = LoopOnce;\n\n            animationActions.push(animationAction);\n        });\n\n        console.log('gltf.animations: ', gltf.animations);\n\n        scene.add(model);\n    });\n}\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-02-06-01/2024-02-06-01-02.png\" alt=\"gltf.animations\" /\u003e\n\n\u003cbr /\u003e\n\n* `name`\n    * AnimationClip 의 이름입니다.\n    * `animation_0` 이라는 이름이라서, 버튼별 식별자로 사용할 수는 없어 보입니다.\n* `tracks`\n    * AnimationClip 을 이루는 **최소 단위 Animation** 의 리스트입니다.\n    * 하나의 Animation 에서 회전, 위치 등이 동시에 변형될 수도 있는데, 이를 **VectorKeyframeTrack** 인스턴스로 표현합니다.\n    * `console` 에서 확인하면, **각 track 의 name** 으로 **특정 버튼을 식별** 할 수 있을 것 같습니다.\n        * `button.position`, `button.scale`\n        * `button_1.position`, `button_1.scale`\n        * `button_2.position`, `button_2.scale`\n        * `button_3.position`, `button_3.scale`\n        * `button_4.position`, `button_4.scale`\n        * `button_5.position`, `button_5.scale`\n        * `button_6.position`, `button_6.scale`\n\n\u003cbr /\u003e\n\nclick 이벤트가 발생하면 Raycaster 의 `intersectObjects()` 로 대상 Model 을 참조할 수 있었습니다.\n\n그리고 아래와 같이 대상 Model 의 name 을 참조할 수 있습니다.\n\n```js\nconst intersects = raycaster.intersectObjects(scene.children, true);\n\nconst targetModel = intersects[0].object;\n\nconst targetModelName = targetModel.name;\n```\n\n대상 Model 의 name 과 VectorKeyframeTract 의 name 의 관계를 찾아보면 다음과 같습니다.\n\n```js\nif (targetModelName === track.name.split('.')[0]) {\n    // targetModel 에 대한 track 식별 성공\n}\n```\n\n\u003cbr /\u003e\n\n지금까지 파악한 Model 의 animations 를 요약하면 다음과 같습니다.\n\n* 단일 AnimationClip 이 존재합니다.\n* 모든 버튼의 VectorKeyframeTrack 이 단일 AnimationClip 에 묶여있습니다.\n\n묶여있는 VectorKeyframeTrack 을 각 버튼별 AnimationClip 으로 재구성해야 버튼별 Animation 을 개별로 플레이 할 수 있습니다.\n\n단일 AnimationClip 을 버튼별 AnimationClip 으로 재구성하면 다음과 같습니다.\n\n```js title=\"animationActions 를 animationActionMapper 로 변경\" showLineNumbers\n/** @type { Record\u003cstring, AnimationAction\u003e } */\nlet animationActionMapper = {};\n```\n\n```js title=\"버튼별 AnimationClip 으로 재구성하기\" showLineNumbers{130} {39-63}\n//\n// model\n//\nfunction initModel() {\n    const loader = new GLTFLoader();\n\n    loader.load('/gltf/click.glb', gltf =\u003e {\n        const model = gltf.scene;\n\n        const ratio = 0.1;\n        model.scale.set(ratio, ratio, ratio);\n        model.position.set(0, 0, 0);\n\n        model.traverse(child =\u003e {\n            if (!child.isMesh) {\n                return;\n            }\n\n            child.castShadow = true;\n            child.receiveShadow = true;\n\n            child.material = new MeshStandardMaterial({\n                color: child.material.color,\n                roughness: 0.3,\n            });\n        });\n\n        // 1. AnimationMixer 생성하기\n        animationMixer = new AnimationMixer(model);\n\n        // 2. AnimationAction 생성하기\n        // gltf.animations.forEach(clip =\u003e {\n        //     const animationAction = animationMixer.clipAction(clip);\n        //     animationAction.loop = LoopOnce;\n\n        //     animationActions.push(animationAction);\n        // });\n\n        /** @type { Record\u003cstring, AnimationClip\u003e } */\n        const animationClipMapper = {};\n\n        gltf.animations[0].tracks.forEach(track =\u003e {\n            const name = track.name.split('.')[0];\n            const targetClip = animationClipMapper[name];\n\n            if (targetClip) {\n                targetClip.tracks.push(track);\n            } else {\n                const newClip = new AnimationClip(name, -1, [\n                    track,\n                ]);\n                animationClipMapper[name] = newClip;\n            }\n        });\n\n        Object\n            .entries(animationClipMapper)\n            .forEach(([name, clip]) =\u003e {\n                const clipAction = animationMixer.clipAction(clip);\n                clipAction.loop = LoopOnce;\n\n                animationActionMapper[name] = clipAction;\n            });\n\n        scene.add(model);\n    });\n}\n```\n\n```js title=\"click 한 버튼의 animationAction 만 플레이 하기\" showLineNumbers{212} {35-37}\nfunction initClickInteraction($target) {\n    const raycaster = new Raycaster();\n\n    $target.addEventListener('click', e =\u003e {\n        const {\n            clientX,\n            clientY,\n        } = e;\n\n        const mouseCoord = new Vector2(\n            (clientX / window.innerWidth) * 2 - 1,\n            -(clientY / window.innerHeight) * 2 + 1\n        );\n\n        raycaster.setFromCamera(mouseCoord, camera);\n\n        const intersects = raycaster.intersectObjects(scene.children, true);\n        const firstModel = intersects[0]?.object;\n\n        if (!firstModel || !firstModel.name.match(/^button.*/)) {\n            return;\n        }\n\n        const rocketChangingModel = scene.getObjectByName('change');\n\n        const buttonColor = firstModel.material.color;\n\n        rocketChangingModel.material.color = buttonColor;\n        scene.background = buttonColor;\n\n        // animationActions.forEach(animationAction =\u003e {\n        //     animationAction.reset();\n        //     animationAction.play();\n        // });\n        const targetAnimationAction = animationActionMapper[firstModel.name];\n        targetAnimationAction?.reset();\n        targetAnimationAction?.play();\n    });\n}\n```\n\n\u003cvideo width=\"100%\" height=\"auto\" preload=\"none\" autoPlay={true} loop={true} muted={true} controls={false}\u003e\n    \u003csource src=\"/markdownAssets/threejs/2024-02-06-01/2024-02-06-01-03.webm\" type=\"video/webm\" /\u003e\n    animation\n\u003c/video\u003e"])</script><script>self.__next_f.push([1,"15:T3178,"])</script><script>self.__next_f.push([1,"---\nid: 13\ntitle: 'Model 에 Click Event 적용하기 (추가: ToneMapping, light.shadow.camera)'\ndescription: 'Canvas 에 렌더링된 Model 에 Click 인터렉션을 적용 해봅니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    '3D',\n    'mouse event',\n    'click interaction',\n]\n\ncreatedAt: '2024-02-03 16:00:00'\nmodifiedHistories: []\n---\n\n# Model 에 Click Event 적용하기 (추가: ToneMapping, light.shadow.camera)\n\nCanvas 에 렌더링된 Model 에 Click 기능을 추가해 보겠습니다.\n\nDOM 과 다르게 Canvas 에 그려지는 Model 은 직접 eventListener 를 적용할 수 없습니다.\n\n그래서 **Raycasting** 이라는 개념을 사용하여 Click Event 를 구현합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 예시 코드\n\n이번 포스팅에서 사용할 예시코드는 다음과 같습니다.\n\n\u003cbr /\u003e\n\n예시코드에서 사용한 Model 은 [상상력을 자극하는 고퀄리티 3D 인터랙티브 웹 제작 (최인 강사님)](https://coloso.co.kr/products/graphicdesign-choiin) 강좌 리소스를 사용하였습니다.\n\n```js title=\"예시 코드\" showLineNumbers {6, 57}\n// three/js\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n    ACESFilmicToneMapping,\n\n    Color,\n    DirectionalLight,\n    HemisphereLight,\n\n    MeshStandardMaterial,\n} from 'three';\n// three.js - addons\nimport {\n    GLTFLoader,\n} from 'three/examples/jsm/loaders/GLTFLoader';\n// style\nimport './style.css';\n\n//\n// state\n//\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { Parameters\u003cParameters\u003cGLTFLoader['load']\u003e[1]\u003e[0]['scene'] } */\nlet mainModel;\n\n//\n// core\n//\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.setPixelRatio(window.devicePixelRatio);\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.shadowMap.enabled = true;\n    renderer.toneMapping = ACESFilmicToneMapping;\n}\n\nfunction initScene() {\n    scene = new Scene();\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n\n    camera.fov = 45;\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.near = 0.5;\n    camera.far = 2000;\n    camera.position.set(100, 100, 100);\n    camera.lookAt(-20, 0, -20);\n\n    camera.updateProjectionMatrix();\n}\n\n//\n// light\n//\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n\n    const light = new DirectionalLight(\n        color,\n        Math.PI * 1\n    );\n\n    light.position.set(-1, 1, 0.5);\n    light.castShadow = true;\n\n    light.shadow.mapSize.set(1024, 1024);\n    light.shadow.camera.near = 0.5;\n    light.shadow.camera.far = 500;\n\n    light.shadow.camera.top = 180;\n    light.shadow.camera.bottom = -100;\n    light.shadow.camera.left = -120;\n    light.shadow.camera.right = 120;\n\n    scene.add(light);\n}\n\nfunction initHemisphereLight() {\n    const skyColor = new Color('#fff');\n    const groundColor = new Color('#555');\n\n    const light = new HemisphereLight(\n        skyColor,\n        groundColor,\n        Math.PI * 0.5\n    );\n\n    light.position.set(0, -1, 0);\n\n    scene.add(light);\n}\n\n//\n// model\n//\nfunction initMainModel() {\n    const loader = new GLTFLoader();\n\n    loader.load('/gltf/click.glb', gltf =\u003e {\n        const ratio = 0.1;\n\n        mainModel = gltf.scene;\n        mainModel.position.set(0, 0, 0);\n        mainModel.scale.set(ratio, ratio, ratio);\n\n        mainModel.traverse(child =\u003e {\n            if (!child.isMesh) {\n                return;\n            }\n\n            child.material = new MeshStandardMaterial({\n                color: child.material.color,\n                roughness: 0.3,\n            });\n\n            child.castShadow = true;\n            child.receiveShadow = true;\n        });\n\n        scene.add(mainModel);\n    });\n}\n\n//\n// executor\n//\nfunction render() {\n    window.requestAnimationFrame(render);\n\n    renderer.render(scene, camera);\n}\n\n(function init() {\n    const $canvas = initCanvas();\n\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n\n    initDirectionalLight();\n    initHemisphereLight();\n\n    initMainModel();\n\n    render();\n}());\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## toneMapping 이란?\n\n예시 코드 57번줄을 보면 다음과 같은 코드가 있습니다.\n\n```js title=\"toneMapping 설정\"\nrenderer.toneMapping = ACESFilmicToneMapping;\n```\n\n\u003cbr /\u003e\n\nHDR(High Dynamic Range) 과 같은 Model 을 LDR(Low Dynamic Range) 로 변환하는 방식을 설정하는 부분입니다.\n\n3D Model 의 경우 HDR 로 만드는데, 사용자의 모니터나 모바일 화면은 LDR 입니다.\n\n고해상도를 저해상도로 변환하는 원리는, 복수 Pixel 의 근사치를 구하여 하나의 Pixel 로 만드는 것입니다.\n\n설정한 방식의 HDR =\u003e LDR 변환 방식을 사용하여 렌더링을 하게 되므로, 선명도가 다르거나 색상의 밝기가 달라지는 차이를 확인할 수 있습니다.\n\n\u003cbr /\u003e\n\n예시 코드에서 사용한 **ACESFilmicToneMapping** 은 toneMapping 중 하나입니다.\n\n* ACESFilmicToneMapping: Academy Color Encoding System FIlmic Tone Mapping\n\nACESFilmicToneMapping 는 영화 예술 과학 아카데미의 후원으로 개발한 무료 ToneMapping 방식입니다.\n\n**실제 사진과 유사한 시각혁 효과를 만들 때 사용합니다.**\n\n\u003cbr /\u003e\n\n어떤 toneMapping 을 사용할지는 자신의 시각적 취향이나 개발 요구사항에 맞게 선택하면 됩니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## DirectionalLight 의 shadow 설정\n\n예시 코드의 DirectionalLight 생성 함수를 보면, shadow 관련 설정이 있습니다.\n\n```js title=\"DirectionalLight 의 shadow 설정\"\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n\n    const light = new DirectionalLight(\n        color,\n        Math.PI * 1\n    );\n\n    light.position.set(-1, 1, 0.5);\n    light.castShadow = true;\n\n    light.shadow.mapSize.set(1024, 1024);\n    light.shadow.camera.near = 0.5;\n    light.shadow.camera.far = 500;\n\n    light.shadow.camera.top = 180;\n    light.shadow.camera.bottom = -100;\n    light.shadow.camera.left = -120;\n    light.shadow.camera.right = 120;\n\n    scene.add(light);\n}\n```\n\n이 중, `light.shahdow.camera` 속성을 살펴보고자 합니다.\n\n\u003cbr /\u003e\n\nLight 는 빛을 만들고 Mesh 의 그림자도 만들어 줍니다.\n\n위 코드를 보면 `shadow` 속성 하위에 `camera` 속성이 있습니다.\n\n쏘아지는 빛에 의한 **그림자를 만드는 시점 설정** 으로 볼 수 있습니다.\n\n\u003cbr /\u003e\n\n`light.shadow.camera` 는 **OrthographicCamera** 객체 입니다.\n\n우리가 지금까지 사용했던 Camera 인 **PerspectiveCamera** 와 다른점은 다음과 같습니다.\n\n* PerspectiveCamera: 3D 환경처럼 **원근법** 이 표현되는 카메라 입니다.\n* OrthographicCamera: 2D 환경처럼 원근법이 나타나지 않는 카메라 입니다.\n\n즉, light 가 비추는 빛은 2D 환경과 같이 원근법을 계산하지 않는 방식을 사용합니다.\n\n\u003cbr /\u003e\n\n그림자는 Light 가 비추는 범위 내에 Mesh 가 있어야 생성됩니다.\n\n이 범위는 **절두체(frustum)** 로 표현됩니다.\n\n\u003e [이미지 출처: 위키백과](https://ko.wikipedia.org/wiki/%EC%A0%88%EB%91%90%EC%B2%B4)\n\n\u003cimg src=\"/markdownAssets/threejs/2024-02-03-02/2024-02-03-02-01.png\" alt=\"절두체\" /\u003e\n\n\u003cbr /\u003e\n\n`light.shadow.camera.top` 설정은 카메라가 비추는 절두체 영역의 중신점에서 **top (위쪽)** 까지의 거리를 설정하는 것입니다.\n\n마찬가지로 bottom, left, right 도 같은 맥락의 설정입니다.\n\n\u003e [이미지 출처: 게임을 게임답게](https://m.blog.naver.com/canny708/221547085908)\n\n\u003cimg src=\"/markdownAssets/threejs/2024-02-03-02/2024-02-03-02-02.png\" alt=\"절두체\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## Raycaster 를 사용하여 Click 이벤트 만들기\n\n이번 포스팅의 메인 내용인 Click 이벤트에 대해 알아보겠습니다.\n\ncanvas 에 렌더링하는 요소는 DOM 이벤트로 감지할 수 없습니다.\n\n그래서 **Raycasting** 이라는 개념을 사용합니다.\n\n\u003e 참고: [위키백과](https://ko.wikipedia.org/wiki/%EA%B4%91%EC%84%A0_%ED%88%AC%EC%82%AC)\n\n* Raycasting: 가상의 광선을 쏘아서 물체와 교차되는 좌표값을 계산하기 위한 기법\n\n\u003cbr /\u003e\n\nThree.js 에서는 `Raycaster` 인스턴스를 생성하여 Mesh, Model 을 특정할 수 있습니다.\n\nHTMLCanvasElement 에 click 이벤트를 추가하고, handler 에서 Raycaster 를 사용하여 어떤 Mesh, Model 이 교차되었는지 식별하는 방법으로 구현합니다.\n\n\u003cbr /\u003e\n\n```js title=\"Raycaster import 하기\" showLineNumbers {14-15}\n// three/js\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n    ACESFilmicToneMapping,\n\n    Color,\n    DirectionalLight,\n    HemisphereLight,\n\n    MeshStandardMaterial,\n\n    Raycaster,\n    Vector2,\n} from 'three';\n```\n\n```js title=\"Raycaster 로 click 이벤트 만들기\" showLineNumbers{152} {4-9, 11-42, 65}\n//\n// interaction\n//\nfunction changeColor(color) {\n    scene.background = color;\n\n    const targetModel = scene.getObjectByName('change');\n    targetModel.material.color = color;\n}\n\nfunction initClickInteraction() {\n    const raycaster = new Raycaster();\n\n    window.addEventListener('click', e =\u003e {\n        const {\n            clientX,\n            clientY,\n        } = e;\n\n        // Raycaster 좌표계로 변환 및 Vector2 인스턴스 생성\n        const mouseCoord = new Vector2();\n        mouseCoord.x = (clientX / window.innerWidth) * 2 - 1;\n        mouseCoord.y = -(clientY / window.innerHeight) * 2 + 1;\n\n        // Raycaster 에 좌표값과 대상 카메라 적용\n        raycaster.setFromCamera(mouseCoord, camera);\n\n        // `Ray(광선)` 과 교차하는 Mesh, Model 을 추출\n        const intersects = raycaster.intersectObjects(scene.children, true);\n        const firstIntersect = intersects[0];\n        const firstModel = firstIntersect?.object;\n\n        if (!firstModel) {\n            return;\n        }\n\n        if (!firstModel.name.match(/^button.*/)) {\n            return;\n        }\n\n        const buttonColor = firstModel.material.color;\n\n        changeColor(buttonColor);\n    });\n}\n\n//\n// executor\n//\nfunction render() {\n    window.requestAnimationFrame(render);\n\n    renderer.render(scene, camera);\n}\n\n(function init() {\n    const $canvas = initCanvas();\n\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n\n    initDirectionalLight();\n    initHemisphereLight();\n\n    initMainModel();\n\n    initClickInteraction();\n\n    render();\n}());\n```\n\n\u003cvideo width=\"100%\" height=\"auto\" preload=\"none\" autoPlay={true} loop={true} muted={true} controls={false}\u003e\n    \u003csource src=\"/markdownAssets/threejs/2024-02-03-02/2024-02-03-02-03.webm\" type=\"video/webm\" /\u003e\n    Raycaster\n\u003c/video\u003e\n\n\u003cbr /\u003e\n\nclick 이벤트를 초기화 하는 `initClickInteraction` 함수를 살펴보겠습니다.\n\nRaycasting 을 사용하기 위해 `new Raycaster()` 로 인스턴스를 만듭니다.\n\n그리고 click 이벤트가 발생하면, raycaster 인스턴스를 사용하게 됩니다.\n\n\u003cbr /\u003e\n\n위 코드에서 사용한 Raycaster 메소드는 다음과 같습니다.\n\n* `setFromCamera(좌표값, 카메라)`\n* `intersectObjects(감지대상_리스트, 재귀_여부)`\n\n\u003cbr /\u003e\n\nclick 이벤트가 발생하면, 마우스위 위치를 알 수 있습니다.\n\n이 좌표값을 사용하여 **Vector2** 인스턴스를 생성할 수 있습니다.\n\n\u003e 참고: [Three.js 공식문서 - Raycaster](https://threejs.org/docs/?q=raycaster#api/en/core/Raycaster)\n\n여기서 중요한 점은 **Raycaster 의 좌표계** 에 맞도록 변환하는 것입니다.\n\nRaycaster 의 좌표계는 2D 이며 다음과 같습니다.\n\n* X축: **-1 ~ 1**\n* Y축: **-1 ~ 1**\n\n\u003cbr /\u003e\n\n그래서 clientX, clientY 좌표값을 아래와 같은 공식으로 변환하여 Vector2 인스턴스를 생성하게 됩니다.\n\n```js title=\"Raycaster 좌표계로 변환\"\nwindow.addEventListener('click', e =\u003e {\n    const {\n        clientX,\n        clientY,\n    } = e;\n\n    const x = (clientX / window.innerWidth) * 2 - 1;\n    const y = -(clientY / window.innerHeight) * 2 + 1;\n});\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\nPath2D 를 사용하여 구현했었던 Canvas API 에 비해, Raycaster 는 코드상으로도 가독성이 좋은 것 같습니다.\n\nThree.js 를 좀 더 잘 사용할 수 있게된다면, 지금까지 사용했던 Canvas API 를 대체하여 사용하고 싶습니다.\n"])</script><script>self.__next_f.push([1,"16:T1049,"])</script><script>self.__next_f.push([1,"---\nid: 13\ntitle: '(Issue) 조명이 어둡게 보이는 현상'\ndescription: '강좌의 결과물에 비해 실습 결과물의 밝기가 어둡게 렌더링되는 현상이 발생하였습니다. 현상 원인과 해결 방법에 대해 정리하고자 합니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    '3D',\n    'DirectionalLgith',\n    'HemisphereLight',\n    'intensity'\n]\n\ncreatedAt: '2024-02-03 14:00:00'\nmodifiedHistories: []\n---\n\n# (Issue) 조명이 어둡게 보이는 현상\n\n강좌에서 제공하는 프로젝트 환경에서 실습을 하였습니다.\n\n그 후, Vite 프로젝트를 생성하여 복습한 결과, 어둡게 렌더링되는 현상이 발생하였습니다.\n\n* 강좌 결과: 밝게 렌더링\n* 복습 결과: 어둡게 렌더링\n\n\u003cimg src=\"/markdownAssets/threejs/2024-02-03-01/2024-02-03-01-01.png\" alt=\"발기 차이\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 원인은 Three.js 버전\n\n강좌에서 사용한 Three.js 버전은 **0.132.2**, 복습에서는 **0.162.2** 을 사용하였습니다.\n\n\u003cbr /\u003e\n\n동일한 코드임에도 불구하고 복습 결과가 더 어둡게 렌더링된 것은, Three.js 의 버전이 올라가면서 Light 의 **intensity** 값에 대한 단위가 바뀌었기 때문입니다.\n\n\u003e 참고: [Three.js 포럼](https://discourse.threejs.org/t/breaking-changes-between-r132-vs-r133/30629)\n\u003e\n\u003e 참고: [Three.js 포럼 질문](https://discourse.threejs.org/t/r132-r133-darkened-scene/30951)\n\n\n\n\u003cbr /\u003e\n\n\n\n## 해결 방법 1 (deprecated)\n\nWebGLRenderer 인스턴스의 `useLegacyLights` 속성을 `true` 설정하면 강좌 처럼 밝게 렌더링됩니다.\n\n다만 `useLegacyLights` 는 deprecated 된 속성이기 때문에 권장하는 방법이 필요합니다.\n\n```js title=\"useLegacyLights 설정\" {6}\nconst renderer = new WebGLRenderer({\n    canvas,\n    antialias: true,\n});\n\nrenderer.useLegacyLights = true;\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 해결 방법 2 (recommanded)\n\n어둡게 렌더링되는 원인인 Light 의 intensity 값을 조정하는 방법을 권장합니다.\n\n기존에는 intensity 값을 **정수** 를 기준으로 하였지만, **PI** 값을 기준으로 변경되었습니다.\n\n그래서 기존과 동일한 밝기로 렌더링하고자 한다면, **기존_intensity_값 * PI** 를 사용하여 얻을 수 있습니다.\n\n* v0.131.0 에서 Light intensity: **1**\n* 이후 버전에서 Light intensity: **1 * Math.PI**\n\n\u003cbr /\u003e\n\n```js title=\"Light intensity 에 PI 적용\"\nconst directionalLight = new DirectionalLight(\n    new Color('#fff'),\n    Math.PI * 1\n);\n\nconst hemisphereLight = new HemisphereLight(\n    new Color('#fff'),\n    new Color('#000'),\n    Math.PI * 0.5\n);\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-02-03-01/2024-02-03-01-02.png\" alt=\"Light intensity 에 PI 적용\" /\u003e\n\n\u003cbr /\u003e\n\nLight 의 intensity 를 사용하여 기존과 거의 유사한 밝기의 결과를 확인할 수 있습니다.\n\n다만 완벽히 동일한 결과를 얻을수는 없습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## Light 의 intensity 단위가 바뀐 이유\n\n\u003e [참고: Physically Based Rendering and Lighting](https://discoverthreejs.com/book/first-steps/physically-based-rendering/)\n\n**물리 기반 렌더링 (Phycally Based Renderering)** 을 위해 Light 의 intensity 값에 PI 를 도입하게 되었다고 합니다.\n\n물리 기반이란, Light 와 물체의 거리에 따라 생성할 그림자에 물리 법칙을 적용하여 더 사실적으로 렌더링할 수 있게 됩니다.\n\n\u003cbr /\u003e\n\nintensity 에 PI 를 적용하도록 변경된 Light 는 다음과 같습니다.\n\n* AmbientLight\n* DirectionalLight\n* HemisphereLight\n* SpotLight\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\n복습한 결과가 강좌의 결과와 다른 이유가 너무나 궁금하였습니다.\n\n만약 이번 이슈를 해결하지 못하고 넘어간다면, 의도한 밝기의 결과를 만들지 못한다는 걱정이 컸습니다.\n\n다행히 Three.js 포럼에 관련 질문과 설명이 있었습니다.\n\n\u003cbr /\u003e\n\nThree.js 의 공식 문서는 개요 파악 정도로 사용하고, Three.js 포럼에서 좀 더 자세한 내용을 찾아보아야 할 것 같습니다.\n"])</script><script>self.__next_f.push([1,"17:T2afe,"])</script><script>self.__next_f.push([1,"---\nid: 12\ntitle: '키보드를 사용하여 카메라 이동 인터렉션 만들기'\ndescription: '키보드 입력에 대한 event listener 를 사용하여 카메라를 이동할 수 있는 인터렉션을 구현해 봅니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    '3D',\n    'keyboard event',\n    'camera',\n    'interaction',\n]\n\ncreatedAt: '2024-01-30 18:00:00'\nmodifiedHistories: []\n---\n\n# 키보드를 사용하여 카메라 이동 인터렉션 만들기\n\n이번에는 사용자 인터렉션을 구현해 보겠습니다.\n\n키보드 입력값에 따라 카메라를 이동할 수 있는 기능을 구현해 보고자 합니다.\n\n추가로 브라우저 resize 이벤트를 사용하여 canvas 의 크기를 조정하는 기능까지 구현해 보겠습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 예시 코드\n\n이번 포스팅에서 사용할 예시 코드는 다음과 같습니다.\n\n```js title=\"예시 코드\" showLineNumbers\n// three.js\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n\n    Color,\n    PointLight,\n    HemisphereLight,\n\n    MeshBasicMaterial,\n    MeshStandardMaterial,\n} from 'three';\n// three.js - addons\nimport {\n    GLTFLoader,\n} from 'three/examples/jsm/loaders/GLTFLoader';\n// style\nimport './style.css';\n\n/** @type { WebGLRenderer} */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n//\n// core\n//\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.setPixelRatio(window.devicePixelRatio);\n    renderer.setSize(\n        window.innerWidth,\n        window.innerHeight\n    );\n}\n\nfunction initScene() {\n    scene = new Scene();\n    scene.background = new Color('#000');\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n    camera.fov = 45;\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.near = 0.1;\n    camera.far = 3000;\n    camera.position.set(0, 0, 0);\n    camera.lookAt(0, 0, 0);\n\n    camera.updateProjectionMatrix();\n}\n\n//\n// light\n//\nfunction initPointLight() {\n    const color = new Color('#fff');\n\n    const light = new PointLight(color, 1);\n    light.position.set(0, 0, 0);\n\n    scene.add(light);\n}\n\nfunction initHemisphereLight() {\n    const skyColor = new Color('#000');\n    const groundColor = new Color('#fff');\n\n    const light = new HemisphereLight(\n        skyColor,\n        groundColor,\n        0.4\n    );\n    light.position.set(1, 0, 1);\n\n    scene.add(light);\n}\n\n//\n// model\n//\nfunction initMoveModel() {\n    const loader = new GLTFLoader();\n\n    loader.load('/gltf/move.glb', gltf =\u003e {\n        const moveModel = gltf.scene;\n\n        // Model 의 크기가 너무 커서, 0.1 배로 줄여서 사용합니다.\n        const ratio = 0.1;\n\n        moveModel.scale.set(\n            ratio,\n            ratio,\n            ratio\n        );\n        moveModel.position.set(0, 0, 0);\n\n        moveModel.traverse(child =\u003e {\n            if (!child.isMesh) {\n                return;\n            }\n\n            switch(child.name) {\n                case 'light':\n                    child.material = new MeshBasicMaterial({\n                        color: new Color('#fff'),\n                    });\n                    break;\n                default:\n                    child.material = new MeshStandardMaterial({\n                        color: new Color('#fff'),\n                        roughness: 0.5,\n                    });\n            }\n        });\n\n        // Model 에 포함되어 있는 카메라 위치값을 사용합니다.\n        const moveModelCamera = gltf.cameras[0];\n        camera.position.set(\n            moveModelCamera.position.x * ratio,\n            moveModelCamera.position.y * ratio,\n            moveModelCamera.position.z * ratio\n        );\n\n        scene.add(moveModel);\n    });\n}\n\n//\n// executor\n//\nfunction render() {\n    window.requestAnimationFrame(render);\n\n    renderer.render(scene, camera);\n}\n\n(function init() {\n    const $canvas = initCanvas();\n\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n\n    initPointLight();\n    initHemisphereLight();\n\n    initMoveModel();\n\n    render();\n}());\n```\n\n\u003cbr /\u003e\n\n예시코드에서 사용한 Model 은 [상상력을 자극하는 고퀄리티 3D 인터랙티브 웹 제작 (최인 강사님)](https://coloso.co.kr/products/graphicdesign-choiin) 강좌 리소스를 사용하였습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 이동 상태값 만들기\n\n눌러진 키보드 방향키에 따라 카메라의 Z 축 위치를 변경하는 인터렉션을 만들고자 합니다.\n\n* ArrowUp(위쪽 방향키): 카메라가 -Z 축으로 이동합니다.\n* ArrowDown(아래쪽 방향키): 카메라가 +Z 축으로 이동합니다.\n\n\u003cbr /\u003e\n\nArrowUp, ArrowDown 키가 눌려졌는지 상태값이 필요합니다.\n\n이 상태값을 사용하여, 키가 눌려졌다면 Camera 의 `position.z` 값을 증감시켜서, 마치 화면(카메라) 가 이동하는 듯한 효과를 연출하겠습니다.\n\n\u003cbr /\u003e\n\n```js title=\"이동 상태값 만들기\" showLineNumbers{21} {10-13}\n/** @type { WebGLRenderer} */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\nconst moveInteractionState = {\n    forward: false,\n    backward: false,\n};\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 키보드 이벤트 리스너 만들기\n\nArrowUp, ArrowDown 에 대한 키보드 이벤트 리스너를 추가해 보겠습니다.\n\n이벤트 리스너는 `moveInteractionState` 의 값을 변경하여, 해당 키가 눌려졌는지에 대한 상태를 변경하는 역할을 하게 됩니다.\n\n```js title=\"키보드 이벤트 리스너 만들기\" showLineNumbers{153}\n//\n// interaction\n//\nfunction initMoveInteraction() {\n    window.addEventListener('keydown', e =\u003e {\n        const key = e.key.toLowerCase();\n\n        switch(key) {\n            case 'up':\n            case 'arrowup':\n                moveInteractionState.forward = true;\n                break;\n            case 'down':\n            case 'arrowdown':\n                moveInteractionState.backward = true;\n                break;\n        }\n    });\n\n    window.addEventListener('keyup', e =\u003e {\n        const key = e.key.toLowerCase();\n\n        switch(key) {\n            case 'up':\n            case 'arrowup':\n                moveInteractionState.forward = false;\n                break;\n            case 'down':\n            case 'arrowdown':\n                moveInteractionState.backward = false;\n                break;\n        }\n    });\n}\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 키보드 상태값으로 카메라 이동시키기\n\n예시 코드의 `render()` 함수는 60 프레임으로 호출됩니다.\n\n매 프레임마다 키보드 상태값에 따라 카메라의 위치를 증감 시켜주는 기능을 추가하여, 카메라를 이동시키는 기능을 구현할 수 있습니다.\n\n\u003cbr /\u003e\n\n카메라를 이동시키는 기능으로 `animateCamera()` 함수를 만들면 다음과 같습니다.\n\n```js title=\"키보다 상태값으로 카메라 이동시키기\" showLineNumbers {4-13, 23, 38}\n//\n// animation\n//\nfunction animateCamera() {\n    switch(true) {\n        case moveInteractionState.forward:\n            camera.position.z -= 6;\n            break;\n        case moveInteractionState.backward:\n            camera.position.z += 6;\n            break;\n    }\n}\n\n//\n// executor\n//\nfunction render() {\n    window.requestAnimationFrame(render);\n\n    renderer.render(scene, camera);\n\n    animateCamera();\n}\n\n(function init() {\n    const $canvas = initCanvas();\n\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n\n    initPointLight();\n    initHemisphereLight();\n\n    initMoveModel();\n\n    initMoveInteraction();\n\n    render();\n}());\n```\n\n\u003cvideo width=\"100%\" height=\"auto\" preload=\"none\" autoPlay={true} loop={true} muted={true} controls={false}\u003e\n    \u003csource src=\"/markdownAssets/threejs/2024-01-30-01/2024-01-30-01-01.webm\" type=\"video/webm\" /\u003e\n    키보드 상태값으로 카메라 이동시키기\n\u003c/video\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 브라우저 resize 이벤트로 canvas 크기 조정하기\n\n**resize** 이벤트는 브라우저의 크기가 변경되면 발생하는 이벤트 입니다.\n\nresize 이벤트가 발생했을 때, canvas 의 크기를 변경된 브라우저 크기로 변경하는 기능을 구현해 보겠습니다.\n\n\u003cbr /\u003e\n\n먼저 canvas 의 크기를 변경하기 위에 `renderer.setSize()` 메솓드를 사용합니다.\n\n```js title=\"브라우저 resize 이벤트로 canvas 크기 조정하기\" showLineNumbers{47} {13-18}\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.setPixelRatio(window.devicePixelRatio);\n    renderer.setSize(\n        window.innerWidth,\n        window.innerHeight\n    );\n\n    window.addEventListener('resize', () =\u003e {\n        renderer.setSize(\n            window.innerWidth,\n            window.innerHeight\n        );\n    });\n}\n```\n\n\u003cbr /\u003e\n\n위 코드를 적용한 후, 브라우저 크기를 변경해보면, canvas 의 크기도 함께 조정됩니다.\n\n하지만 찌그러진 결과가 렌더링됨을 볼 수 있습니다.\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-30-01/2024-01-30-01-02.png\" alt=\"찌그러진 결과\" /\u003e\n\n\u003cbr /\u003e\n\n이 현상은 **Camera** 의 **비율 (aspect ratio)** 는 최초 브라우저의 비율을 그대로 사용하고 있기 때문입니다.\n\n`camera.aspect` 속성에도 변경된 브라우저 크기의 비율을 적용하여 문제를 해결할 수 있습니다.\n\n```js title=\"찌그러짐 해소\" showLineNumbers{47} {19-20}\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.setPixelRatio(window.devicePixelRatio);\n    renderer.setSize(\n        window.innerWidth,\n        window.innerHeight\n    );\n\n    window.addEventListener('resize', () =\u003e {\n        renderer.setSize(\n            window.innerWidth,\n            window.innerHeight\n        );\n\n        camera.aspect = window.innerWidth / window.innerHeight;\n        camera.updateProjectionMatrix();\n    });\n}\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\n처음으로 사용자 인터렉션을 적용해 보았습니다.\n\nJavascript 의 이벤트 처리 방식을 그대로 따르는 방법이라서 친숙하였습니다.\n\n\u003cbr /\u003e\n\n그리고 인터렉션에 의한 렌더링을 변경할 때, **프레임** 을 그리는 `render()` 함수에서 변화를 적용하여야 함을 알게 되었습니다.\n\n만약 화면을 변경하는 부분을 `render()` 함수가 아닌, event listener 에서 직접 하게 되면, **뚝뚝 끊기면서 렌더링되는 현상** 이 나타났습니다.\n\n이는 키보드를 누르고 있을 때, 체터링 간격이 `1 /60` 보다 큰 값인 것으로 추측되었습니다.\n"])</script><script>self.__next_f.push([1,"18:T1d82,"])</script><script>self.__next_f.push([1,"---\nid: 11\ntitle: 'canvas 크기 설정 및 material 렌더링 side 설정'\ndescription: '사용자 모니터 대응을 위한 WebGLRenderer 설정과 material 의 렌더링 side 설정에 대해 정리합니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    'setSize()',\n    'setPixelRatio()',\n    'material',\n    'FrontSide',\n    'BackSide',\n    'DoubleSide',\n]\n\ncreatedAt: '2024-01-28 23:00:00'\nmodifiedHistories: []\n---\n\n# canvas 크기 설정 및 material 렌더링 side 설정\n\n지금까지는 HTMLCanvasElement 인스턴스의 width, height 를 직접 설정하여 사용하고 있었습니다.\n\n이번에는 좀 더 사용자 장치(모니터)에 적합한 렌더링이 되도록 설정하는 방법과 material 의 side 속성에 대해 정리하겠습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## WebGLRenderer 를 사용한 canvas 크기 및 Pixel 비율 설정\n\n지금까지는 HTMLCanvasElement 의 크기를 아래와 같이 설정하였습니다.\n\n```js title=\"HTMLCanvasElement 크기 설정하기\" showLineNumbers\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n    $canvas.width = window.innerWidth;\n    $canvas.height = window.innerHeight;\n\n    // ...\n}\n```\n\n이렇게 설정하여도 일반적인 모니터에서는 문제없이 렌더링 됩니다.\n\n이는 **Pixel Ratio** 가 **1** 인 모니터에 대한 설정이며, 기본 설정값입니다.\n\n\u003cbr /\u003e\n\n\u003e 참고: [Window: devicePixelRatio 속성 - MDN](https://developer.mozilla.org/ko/docs/Web/API/Window/devicePixelRatio)\n\nPixel Ratio 이란, **렌더링할 Pixel 크기** 와 **모니터의 물리적 Pixel 크기** 에 대한 비율입니다.\n\n웹을 기준으로 본다면, 아래의 값이 Pixel Ratio 를 도출할 수 있습니다.\n\n* `물리적(모니터) Pixel 크기` / `CSS Pixel 크기`\n\n즉, 일반적인 모니터의 **Pixel Ratio** 가 **1** 이라는 뜻은, **CSS Pixel 1개** 당 **모니터의 실제 Pixel 1개** 를 사용하여 렌더링한다는 의미입니다.\n\n\u003cbr /\u003e\n\n**HiDPI** 와 **Apple 의 retina** 디스플레이는 Pixel Ratio 가 2인 모니터입니다.\n\n이는 기존의 **CSS Pixel 1개** 를 **모니터의 실제 Pixel 2개** 에 렌더링한다는 의미가 되며, 이러한 제품은 더 많은 물리적 Pixel 을 사용하여 더 선명한 화질을 제공하기 위함입니다.\n\n\u003cbr /\u003e\n\n우리가 Web 에서 사용하는 HTMLCanvasElement 에 Pixel Ratio 를 적용하려면, 아래와 같은 설정이 필요합니다.\n\n```js title=\"HTMLCanvasElement 에 Pixel Ratio 적용하기\" showLineNumbers\nconst pixelRatio = window.devicePixelRatio;\n\nconst $canvas = document.createElement('canvas');\n\n$canvas.style.width = `${window.innerWidth}px`;\n$canvas.style.height = `${window.innerHeight}px`;\n\n$canvas.width = window.innerWidth * pixelRatio;\n$canvas.width = window.innerHeight * pixelRatio;\n```\n\n\u003cbr /\u003e\n\n이렇게 설정하게 되면, 아래와 같이 선명도의 차이가 나타납니다.\n\n\u003e 이미지 출처: [Window: devicePixelRatio 속성 - MDN](https://developer.mozilla.org/ko/docs/Web/API/Window/devicePixelRatio)\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-28-02/2024-01-28-02-01.png\" alt=\"Pixel Ratio\" /\u003e\n\n\u003cbr /\u003e\n\nThree.js 는 WebGLRenderer 인스턴스를 사용하여 Pixel Ratio 를 설정할 수 있습니다.\n\n```js title=\"Three.js 에 Pixel Ratio 설정하기\"\nconst renderer = new WebGLRenderer();\n\nrenderer.setPixelRatio(window.devicePixelRatio);\n```\n\n\u003cbr /\u003e\n\n추가로 HTMLCanvasElement 의 width 와 height 를 직접 설정하는 것이 아닌 WebGLRenderer 의 `setSize()` 메소드를 사용하여 설정할 수 있습니다.\n\n`setSize()` 는 HTMLCanvasElement 의 크기 변경과 함께, **Viewport** 까지 **Fit** 하게 설정해 줍니다.\n\n이를 적용하면 아래와 같이 코드를 작성할 수 있습니다.\n\n```js title=\"WebGLRenderer 설정\" showLineNumbers\nimport {\n    WebGLRenderer,\n} from 'three';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.setPixelRatio(window.devicePixelRatio);\n    renderer.setSize(\n        window.innerWidth,\n        window.innerHeight\n    );\n}\n\nfunction init() {\n    const $canvas = initCanvas();\n\n    initRenderer($canvas);\n}\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## Material 의 side 프로퍼티\n\nMaterial 은 Model 의 재질을 담당하며, 렌더링 대상 중 하나입니다.\n\n렌더링 대상이 많을수록 더 많은 PC 성능을 요구하게 되므로, Material 도 최적화가 필요합니다.\n\n\u003cbr /\u003e\n\nThree.js 의 Material 인스턴스는 `side` 라는 프로퍼티를 제공합니다.\n\n이는 실제로 렌더링할 **면** 을 지정하여, 렌더링 대상에 속한 Material 만 렌더링하게 됩니다.\n\n\u003cbr /\u003e\n\nMaterial 의 `side` 는 다음과 같은 설정을 할 수 있습니다.\n\n* `FrontSide`\n    * Mesh 의 **앞면** 에 해당하는 Material 만 렌더링 합니다.\n    * 뒷면은 렌더링하지 않습니다.\n    * 기본값 입니다.\n* `BackSide`\n    * Mesh 의 **뒷면** 에 해당하는 Material 만 렌더링 합니다.\n    * 앞면은 렌더링하지 않습니다.\n* `DoubleSide`\n    * Mesh 의 전체 Material 을 렌더링 합니다.\n\n\u003cbr /\u003e\n\nGLTFLoader 를 사용하여 불러온 Model 에 `side` 를 적용하면 다음과 같습니다.\n\n```js title=\"Material 의 side 설정\" showLineNumbers\nimport {\n    FrontSide,\n    BackSide,\n    DoubleSide,\n} from 'three';\nimport {\n    GLTFLoader,\n} from 'three/examples/jsm/loader/GLTFLoader';\n\nfunction initFrontSideModel() {\n    const loader = new GLTFLoader();\n\n    loader.load('/gltf/someModel.gltf', gltf =\u003e {\n        gltf.scene.traverse(child =\u003e {\n            if (!child.isMesh) {\n                return;\n            }\n\n            // `앞면` 만 렌더링\n            child.material.side = FrontSide;\n        });\n    });\n}\n\nfunction initBackSideModel() {\n    const loader = new GLTFLoader();\n\n    loader.load('/gltf/someModel.gltf', gltf =\u003e {\n        gltf.scene.traverse(child =\u003e {\n            if (!child.isMesh) {\n                return;\n            }\n\n            // `뒷면` 만 렌더링\n            child.material.side = BackSide;\n        });\n    });\n}\n\nfunction initDoubleSideModel() {\n    const loader = new GLTFLoader();\n\n    loader.load('/gltf/someModel.gltf', gltf =\u003e {\n        gltf.scene.traverse(child =\u003e {\n            if (!child.isMesh) {\n                return;\n            }\n\n            // 앞, 뒤 모두 렌더링\n            child.material.side = DoubleSide;\n        });\n    });\n}\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\n스터디를 한 후, 내용이 이해되지 않거나 전혀 생각나지 않을 경우, 상실감을 느낍니다.\n\n그래서 강의 수강과 함께 정리를 병행하고 있습니다.\n\n내용에 따라 하나의 강의를 분리하여 정리하기도 합니다.\n\n이렇게 학습하게 되면, 비교적 학습시간이 많이 필요하게 되지만, 많은 것을 기억할 수 있습니다.\n\n\u003cbr /\u003e\n\n느린 학습 속도에 조바심이 나기도 하고, 정리에 대한 부담감도 생깁니다.\n\n100% 를 기억하지는 못하더라도, 맥락과 주요 개념을 기억하기 위해서는 당연한 방법이라고 생각합니다.\n\n다만 투자하는 시간에 대한 아쉬움으로 짧은 푸념을 남깁니다.\n"])</script><script>self.__next_f.push([1,"19:T2b48,"])</script><script>self.__next_f.push([1,"---\nid: 9\ntitle: 'Model 에 Animation 효과 적용하기'\ndescription: 'Model 파일인 .gltf, .glb 에 Animation 을 적용하는 방법에 대해 정리합니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    'javascript',\n    '3d',\n    '.gltf',\n    '.glb',\n    'model',\n    'animation',\n]\n\ncreatedAt: '2024-01-26 20:00:00'\nmodifiedHistories: []\n---\n\n# Model 에 Animation 효과 적용하기\n\nC4D 또는 Blender 를 사용하여 Model 을 만들고 Three.js 에 렌더링할 수 있게 되었습니다.\n\n이번 포스팅에서는 Model 에 Animation 효과를 적용하는 방법에 대해 알아보고자 합니다.\n\n\u003cbr /\u003e\n\n예시코드에서 사용한 Model 은 [상상력을 자극하는 고퀄리티 3D 인터랙티브 웹 제작 (최인 강사님)](https://coloso.co.kr/products/graphicdesign-choiin) 강좌 리소스를 사용하였습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## Model 의 Animation 을 적용하는 방법\n\nAnimation 은 2가지 방법으로 적용할 수 있습니다.\n\n* 첫번쨰 방법: Model 의 position, rotation, scale 등의 값을 직접 update 하는 방법\n* 두번째 방법: 3D Tool 에서 Model 에 적용한 Keyframe Animation 을 불러와서 Update 하는 방법\n\n\u003cbr /\u003e\n\n두가지 방법 모두 원리는 HTMLCanvasElement 를 사용한 Animation 을 적용하는 방법과 동일합니다.\n\n첫번째 방법은 가속도와 같은 자연스러운 효과를 구현하기 어렵지만, 두번째 방법을 사용하면 3D Tool 에서 정교하게 만든 Animation 을 사용할 수 있습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 예시 코드\n\n이번 포스팅은 Rocket Model 을 렌더링 한 시점부터 시작합니다.\n\n```js title=\"예시 코드\" showLineNumbers\n// three.js\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n\n    Color,\n    DirectionalLight,\n} from 'three';\nimport {\n    OrbitControls,\n} from 'three/examples/jsm/controls/OrbitControls';\nimport {\n    GLTFLoader,\n} from 'three/examples/jsm/loaders/GLTFLoader';\n// style\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { OrbitControls } */\nlet controls;\n\n//\n// core\n//\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n    $canvas.width = window.innerWidth;\n    $canvas.height = window.innerHeight;\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.shadowMap.enabled = true;\n}\n\nfunction initScene() {\n    scene = new Scene();\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n    camera.fov = 35;\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.position.set(0, 0, 30);\n\n    camera.updateProjectionMatrix();\n}\n\nfunction initControls($target) {\n    controls = new OrbitControls(camera, $target);\n    controls.enableDamping = true;\n}\n\n//\n// light\n//\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n\n    const light = new DirectionalLight(color, 1);\n    light.castShadow = true;\n    light.shadow.mapSize.set(2048, 2048);\n    light.shadow.radius = 8;\n    light.position.set(10, 10, 10);\n    light.lookAt(0, 0, 0);\n\n    scene.add(light);\n}\n\n//\n// model\n//\nfunction initRocketModel() {\n    const loader = new GLTFLoader();\n\n    loader.load('/gltf/rocket.glb', gltf =\u003e {\n        gltf.scene.position.set(0, -5, 5);\n        gltf.scene.traverse(child =\u003e {\n            if (!child.isMesh) {\n                return;\n            }\n\n            child.castShadow = true;\n            child.receiveShadow = true;\n            child.material.metalness = 0;\n        });\n\n        scene.add(gltf.scene);\n    });\n}\n\n//\n// executor\n//\nfunction render() {\n    window.requestAnimationFrame(render);\n\n    renderer.render(scene, camera);\n    controls.update();\n}\n\n(function init() {\n    const $canvas = initCanvas();\n\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n    initControls($canvas);\n\n    initDirectionalLight();\n\n    initRocketModel();\n\n    render();\n}());\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-26-01/2024-01-26-01-01.png\" alt=\"예시 코드 결과\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 첫번째 방법: Model 을 직접 변형하여 Animation 효과 구현하기\n\nGLTFLoader 를 사용하여 Model 을 불러옵니다.\n\n불러온 Model 의 position, roation, scale 을 변경하는 함수를 만들고, 매 Frame 을 렌더링할 때마다 update 시켜줍니다.\n\n\u003cbr /\u003e\n\n아래 코드는 Model 의 rotation.y 의 좌표값을 변경하여, 로켓 Model 이 회전하는 Animation 을 구현합니다.\n\n```js title=\"첫번째 방법: rocketModel global 변수 추가\" showLineNumbers {10, 33-34}\n// three.js\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n\n    Color,\n    DirectionalLight,\n\n    Mesh,\n} from 'three';\nimport {\n    OrbitControls,\n} from 'three/examples/jsm/controls/OrbitControls';\nimport {\n    GLTFLoader,\n} from 'three/examples/jsm/loaders/GLTFLoader';\n// style\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { OrbitControls } */\nlet controls;\n\n/** @type { Mesh } */\nlet rocketModel;\n```\n\n```js title=\"첫번쨰 방법 - Animation 구현\" showLineNumbers{93} {8, 25-34, 45}\n//\n// model\n//\nfunction initRocketModel() {\n    const loader = new GLTFLoader();\n\n    loader.load('/gltf/rocket.glb', gltf =\u003e {\n        rocketModel = gltf.scene;\n\n        gltf.scene.position.set(0, -5, 5);\n        gltf.scene.traverse(child =\u003e {\n            if (!child.isMesh) {\n                return;\n            }\n\n            child.castShadow = true;\n            child.receiveShadow = true;\n            child.material.metalness = 0;\n        });\n\n        scene.add(gltf.scene);\n    });\n}\n\n//\n// animation\n//\nfunction animateRocket() {\n    if (!rocketModel) {\n        return;\n    }\n\n    rocketModel.rotation.y += 0.1;\n}\n\n//\n// executor\n//\nfunction render() {\n    window.requestAnimationFrame(render);\n\n    renderer.render(scene, camera);\n    controls.update();\n\n    animateRocket();\n}\n```\n\n\u003cvideo width=\"100%\" height=\"auto\" preload=\"none\" autoPlay={true} loop={true} muted={true} controls={false}\u003e\n    \u003csource src=\"/markdownAssets/threejs/2024-01-26-01/2024-01-26-01-02.webm\" type=\"video/webm\" /\u003e\n    첫번쨰 방법 - Animation 구현\n\u003c/video\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 두번째 방법: 3D Model 의 Keyframe Animation 사용하기\n\n첫번쨰 방법으로는 복잡한 Animation 을 구현하기 어렵습니다.\n\n3D Tool 을 사용하여 Model 의 Keyframe Animation 을 만들 수 있으며, Model 이 가진 Animation 을 그대로 사용할 수 있으므로, 정교하고 자연스러운 Animation 을 연출할 수 있습니다.\n\n\u003cbr /\u003e\n\nGLTFLoader 를 사용하여 Model 을 불러오면, callback 을 통하여 gltf 객체에 접근할 수 있습니다.\n\ngltf 객체에는 animations 속성이 Model 의 Keyframe Animation 을 가지고 있습니다.\n\n\u003cbr /\u003e\n\ngltf 객체의 animations 를 사용하기 위해 `THREE.AnimationMixer` 객체를 생성합니다.\n\n아래는 `THREE.AnimationMixer` 를 사용하여 Animation 을 적용한 코드 입니다.\n\n```js title=\"두번째 방법 - AnimationMixer global 변수 정의\" showLineNumbers {12, 38-39}\n// three.js\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n\n    Color,\n    DirectionalLight,\n\n    Mesh,\n\n    AnimationMixer,\n} from 'three';\nimport {\n    OrbitControls,\n} from 'three/examples/jsm/controls/OrbitControls';\nimport {\n    GLTFLoader,\n} from 'three/examples/jsm/loaders/GLTFLoader';\n// style\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { OrbitControls } */\nlet controls;\n\n/** @type { Mesh } */\nlet rocketModel;\n\n/** @type { AnimationMixer } */\nlet animationMixer;\n```\n\n```js title=\"두번째 방법: Animation 구현\" showLineNumbers{98} {10-13, 40-44}\n//\n// model\n//\nfunction initRocketModel() {\n    const loader = new GLTFLoader();\n\n    loader.load('/gltf/rocket.glb', gltf =\u003e {\n        rocketModel = gltf.scene;\n\n        animationMixer = new AnimationMixer(rocketModel);\n        gltf.animations.forEach(clip =\u003e {\n            animationMixer.clipAction(clip).play();\n        });\n\n        gltf.scene.position.set(0, -5, 5);\n        gltf.scene.traverse(child =\u003e {\n            if (!child.isMesh) {\n                return;\n            }\n\n            child.castShadow = true;\n            child.receiveShadow = true;\n            child.material.metalness = 0;\n        });\n\n        scene.add(gltf.scene);\n    });\n}\n\n//\n// animation\n//\nfunction animateRocket() {\n    // if (!rocketModel) {\n    //     return;\n    // }\n\n    // rocketModel.rotation.y += 0.1;\n\n    if (!animationMixer) {\n        return;\n    }\n\n    animationMixer.update(1 / 60);\n}\n```\n\n\u003cvideo width=\"100%\" height=\"auto\" preload=\"none\" autoPlay={true} loop={true} muted={true} controls={false}\u003e\n    \u003csource src=\"/markdownAssets/threejs/2024-01-26-01/2024-01-26-01-03.webm\" type=\"video/webm\" /\u003e\n    두번쨰 방법 - Animation 구현\n\u003c/video\u003e\n\n\u003cbr /\u003e\n\n위 코드를 살펴 보겠습니다.\n\n먼저 `AnimationMixer` 타입 변수를 선언하고 있습니다.\n\n이는 `AnimationMixer` 인스턴스를 생성하는 곳과 사용하는 scope 가 달라서 global 변수로 선언합니다.\n\n\u003cbr /\u003e\n\n그리고 GLTFLoader 를 사용하여 gltf 파일을 로드하게 되면, `AnimationMixer` 인스턴스를 생성합니다.\n\n여기서 중요한 점은 `gltf.animations` 의 구성요소인 `animationClip` 객체를 `AnimationMixer` 에 모두 등록`(clipAction())` 해주고 `play()` 시켜주는 것 입니다.\n\n이렇게 등록하게 되면, Frame 을 그릴때 마다 호출하는 `animate()` 함수 내부에서 `AnimationMixer` 의 `update(프레임_증감_값)` 으로 다음 Frame 을 그리게 됩니다.\n\n결과적으로 `AnimationMixer` 에 등록한 Model 의 `animations` 속성을 렌더링하여, Animation 효과가 연출됩니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 추가: gltf.animations 구성\n\n* `AnimationClip` 타입: `gltf.animations` 를 구성하는 객체 타입\n\n\n\n\n\u003cbr /\u003e\n\n\n\n## 추가: AnimationClip 구성\n\n* `duration`: Animation 의 길이(`초` 단위 시간값)\n* `tracks`: Animation 을 구성하는 변화 데이터\n    * `VectorKeyframeTrack` 타입 객체: Model 의 위치를 변경하는 Track\n    * `QuaternionKeyframeTrack` 타입 객체: Model 을 회전시키는 Track\n    * `tracks` 하위의 타입은 Three.js 에서 변경하기 보다, 어떤 효과로 구성된 Animation 인지 파악하는 정도로만 사용하면 될 것 같습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\n원하는 Animation 을 구현하기 위해서는 3D Tool 사용방법도 익혀야 할 것 같습니다.\n\nModel 의 Animation 을 코드로 구현하는 것은 원하는 결과를 얻기에는 쉽지 않을 것으로 생각되었습니다.\n"])</script><script>self.__next_f.push([1,"1a:T25c2,"])</script><script>self.__next_f.push([1,"---\nid: 8\ntitle: 'Model (.gltf, .glb) 객체 구조파악 및 그림자 적용'\ndescription: 'Three.js 환경에 불러온 Model 객체의 주요 구성요소를 파악하고, 속성값을 변경하여 그림자를 만들어 봅니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    'javascript',\n    '3d',\n    '.gltf',\n    '.glb',\n    'model',\n    'traverse',\n    'shadow',\n]\n\ncreatedAt: '2024-01-21 16:00:00'\nmodifiedHistories: []\n---\n\n# Model (.gltf, .glb) 객체 구조파악 및 그림자 적용\n\n3D Tool (Cinema3D, Blender...) 에서 만든 Model 파일은 Three.js 에서 제공하는 `GLTFLoader` 를 사용하여 불러올 수 있습니다.\n\n이렇게 불러온 Model 객체에 원하는 연출을 적용하려면, 불러온 Model 객체의 속성값을 변경하며 설정해주어야 합니다.\n\n\u003cbr /\u003e\n\n예를들어 그림자 효과는 Three.js 환경에 불러온 Model 객체의 `castShadow` 또는 `receiveShadow` 를 `true` 로 설정해주어야 적용됩니다.\n\n뿐만아니라 렌더링 된 Model 의 Material 을 수정한다거나 하는 작업들을 통해서 **빛에 대한 Model 의 양감** 을 변경할 수도 있습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 예시코드\n\n\u003e [Model 다운로드 링크](https://polyhaven.com/a/coast_rocks_05)\n\n이번 포스팅의 예시코드는 위 모델을 렌더링한 시점입니다.\n\n```js title=\"예시코드\" showLineNumbers {63-64, 82-84, 92-98}\n// three.js\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n\n    Color,\n    DirectionalLight,\n} from 'three';\nimport {\n    OrbitControls,\n} from 'three/examples/jsm/controls/OrbitControls';\nimport {\n    GLTFLoader,\n} from 'three/examples/jsm/loaders/GLTFLoader';\n// style\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { OrbitControls } */\nlet controls;\n\n//\n// core\n//\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n    $canvas.width = window.innerWidth;\n    $canvas.height = window.innerHeight;\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.shadowMap.enabled = true;\n}\n\nfunction initScene() {\n    scene = new Scene();\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n    camera.fov = 35;\n    camera.aspect = window.innerWidth / window.innerHeight;\n\n    camera.position.set(-3, 3, 3);\n    camera.lookAt(0, 0, 0);\n\n    camera.updateProjectionMatrix();\n}\n\nfunction initControls($target) {\n    controls = new OrbitControls(camera, $target);\n    controls.enableDamping = true;\n}\n\n//\n// light\n//\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n    const light = new DirectionalLight(color, 0.75);\n\n    light.position.set(10, 10, 10);\n    light.castShadow = true;\n    light.shadow.mapSize.width = 2048;\n    light.shadow.mapSize.height = 2048;\n\n    scene.add(light);\n}\n\n//\n// mesh\n//\nfunction initCoastRocksMesh() {\n    const loader = new GLTFLoader();\n\n    loader.load('/gltf/coast-rocks-05/coast_rocks_05_4k.gltf', gltf =\u003e {\n        scene.add(gltf.scene);\n    });\n}\n\n//\n// executor\n//\nfunction render() {\n    window.requestAnimationFrame(render);\n\n    renderer.render(scene, camera);\n    controls.update();\n}\n\n(function init() {\n    const $canvas = initCanvas();\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n    initControls($canvas);\n\n    initDirectionalLight();\n\n    initCoastRocksMesh();\n\n    render();\n}());\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-21-01/2024-01-21-01-01.png\" alt=\"예시코드 결과\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## Model 객체 구성요소\n\n`GLTFLoader` 를 사용하여 불러온 Model 은 3D Tool 로 개발한 Model 의 정보를 포함하고 있습니다.\n\n3D Tool 에서 parent 와 children 구조를 사용하여 Model 을 만들었다면, Three.js 에서 불러온 Model 객체 역시 동일한 구조를 가지게 됩니다.\n\n그리고 Three.js 에서 활용하기 위한 추가적인 정보와 메소드 등을 가지고 있습니다.\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-21-01/2024-01-21-01-02.png\" alt=\"Model 객체\" /\u003e\n\n\u003cbr /\u003e\n\n* `animations`: 3D Tool 에서 만든 Animation 객체\n* `scene`: Model 의 Mesh 객체\n\n\u003cbr /\u003e\n\n이번 포스팅에서는 **scene** 속성의 일부를 살펴보겠습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## Model 객체의 **scene** 속성\n\nModel 객체의 Scene 속성은 **Group** type 이며, Model 의 최상위 Mesh 역할을 합니다.\n\n우리가 Three.js 에 렌더링할 때 사용했던 속성입니다.\n\n그리고 중첩된 **children** 속성으로 하위 Mesh 를 포함하고 있습니다.\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-21-01/2024-01-21-01-03.png\" alt=\"Model Scene 객체\" /\u003e\n\n\u003cbr /\u003e\n\n**children** 의 구성요소로 사용되는 대표적인 **type** 은 다음과 같습니다.\n\n* **Mesh** 타입: 3D Tool 에서 만든 Mesh 객체만이 이 타입의 인스턴스가 됩니다.\n* **Object3D** 타입: **Mesh 타입이 아닌 모든 객체** 가 이 타입의 인스턴스로 표현됩니다.\n    * 3D Tool 의 **Null Object (group)**\n    * 3D Tool 의 **대칭 생성(Symmetry)**, **부드러운 면 만들기(Subdivision surface)** 등의 유틸 객체\n\n\n\n\u003cbr /\u003e\n\n\n\n## Mesh 타입 객체의 주요 속성\n\n* `name`: 3D Tool 에서 명명한 이름입니다.\n* `isMesh`: `true` 값을 가지며, 이 객체가 **Mesh 타입 객체** 라는 것을 단언할 수 있는 상태값입니다.\n* `type`: 이 객체의 type 명입니다.\n* `material`: `Material` 객체 입니다.\n    * 그림자, 재질 등을 변경할 때 사용하게 될 속성(객체) 입니다.\n* `position`: Three.js 에 렌더링할 좌표값 입니다.\n* `rotation`: Three.js 에서 얼만큼 회전시켜서 렌더링할지 설정값 입니다.\n* `scale`: Three.js 상에서 얼만큼 확대/축소 할지에 대한 설정값 입니다.\n* `castShadow`: 그림자 생성 여부에 대한 설정 입니다.\n* `receiveShadow`: 다른 Mesh 의 그림자에 영향을 받을지에 대한 설정 입니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## `traverse` 메서드\n\nModel 은 복수의 Mesh 객체들로 구성될 수 있습니다.\n\n이는 **children** 속성으로 중첩된 구조를 갖습니다.\n\n만약 그림자 설정을 변경한다면, Model 을 구성하는 모든 Mesh 객체의 그림자 설정값을 변경해주어야 합니다.\n\n\u003cbr /\u003e\n\n3D Tool 에서 만든 Model 이 어떤 구조로 되어있는지 모든 구조를 파악하고 설정을 바꿔주는 것은 매우 어려워 보입니다.\n\n그래서 Model 객체의 **scene** 속성(객체) 는 `traverse()` 메서드를 제공합니다.\n\n\u003cbr /\u003e\n\n`traverse()` 메소드는 Model 을 구성하는 모든 **children** 을 깊은 탐색하는 기능을 수행합니다.\n\n즉, 그림자 설정을 변경한다면, `traverse()` 메소드를 사용하여 모든 하위 Mesh 에 설정을 일괄 변경할 수 있습니다.\n\n\u003cbr /\u003e\n\n탐색 대상이 되는 children 구성요소는 Mesh 타입이 아닐수도 있습니다.\n\n이때 Mesh 객체인지 식별하기 위해 `isMesh` 속성을 사용하게 됩니다.\n\n\u003cbr /\u003e\n\n아래 코드는 `traverse()` 메소드를 사용하여 그림자 설정을 활성화 하고 있습니다.\n\n```js title=\"traverse() 를 사용한 그림자 설정\" showLineNumbers{92} {5-12}\nfunction initCoastRocksMesh() {\n    const loader = new GLTFLoader();\n\n    loader.load('/gltf/coast-rocks-05/coast_rocks_05_4k.gltf', gltf =\u003e {\n        gltf.scene.traverse(obj =\u003e {\n            if (!obj.isMesh) {\n                return;\n            }\n\n            obj.castShadow = true;\n            obj.receiveShadow = true;\n        });\n\n        scene.add(gltf.scene);\n    });\n}\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-21-01/2024-01-21-01-04.png\" alt=\"traverse() 메소드\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 추가: 빛에 대한 Model 객체의 양감 설정하기\n\n`traverse()` 메소드를 사용하여 Mesh 객체의 **material** 속성을 일괄 변경할 수 있습니다.\n\nMesh 객체는 **material** 속성을 가지고 있으므로, 이를 사용하여 Mesh 의 양감을 변경할 수 있습니다.\n\n\u003cbr /\u003e\n\n양감은 Mesh 의 색상이 뚜렷하게 렌더링되는 경우에 풍부하게 연출됩니다.\n\nmaterial 의 `metalness` 값을 `0` 으로 설정하면, 주변 배경을 반사하는 것이 아닌, Mesh 본연의 색상에서 빛의 반사효과만 렌더링됩니다.\n\n\u003cbr /\u003e\n\n또한 `roughness` 값을 변경하여 빛이 얼마나 뚜렷하게 비춰질지 설정할 수도 있습니다.\n\n```js title=\"빛에 대한 Metal 객체의 양감 설정하기\" showLineNumbers{92} {12-13}\nfunction initCoastRocksMesh() {\n    const loader = new GLTFLoader();\n\n    loader.load('/gltf/coast-rocks-05/coast_rocks_05_4k.gltf', gltf =\u003e {\n        gltf.scene.traverse(obj =\u003e {\n            if (!obj.isMesh) {\n                return;\n            }\n\n            obj.castShadow = true;\n            obj.receiveShadow = true;\n            obj.material.metalness = 0;\n            obj.material.roughness = 0;\n        });\n\n        scene.add(gltf.scene);\n    });\n}\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\nModel 에 그림자 설정을 위한 코드는 `traverse()` 메소드를 사용하면 간단하게 적용할 수 있었습니다.\n\nModel 객체가 어떻게 구성되고, 설정을 변경하는 이유 등을 파악하는 것이 쉽지는 않았습니다.\n\n이번 포스팅에서 정리한 내용은 Three.js 전반에 필요한 개념으로 생각되어 성취감이 느껴집니다.\n"])</script><script>self.__next_f.push([1,"1b:T2000,"])</script><script>self.__next_f.push([1,"---\nid: 7\ntitle: 모델 파일을 Three.js 에 렌더링하기\ndescription: '.gltf 또는 .glb 확장자인 모델 파일을 Three.js 에 불러오고 렌더링하는 방법을 정리합니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    'javascript',\n    '3d',\n    'hdr',\n    '.gltf',\n    '.glb',\n    'model',\n]\n\ncreatedAt: '2024-01-10 23:50:00'\nmodifiedHistories: []\n---\n\n# 모델 파일을 Three.js 에 렌더링하기\n\n3D 모델 파일의 확장자는 아래와 같습니다.\n\n* .gltf\n    * 3D 모델 파일이며 JSON 형식의 데이터입니다.\n* .glb\n    * 3D 모델 파일이며 Binary 데이터입니다.\n    * **3D 모델을 렌더링하여 사용할 목적이라면, .glb 파일의 용량이 더 적으므로 적합합니다.**\n\n\u003cbr /\u003e\n\n이번 포스팅에서는 3D 모델 파일을 Three.js 에 렌더링하는 방법과 불러온 모델 객체를 수정하는 방법에 대해 정리하고자 합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 용어 정리\n\n### Luminance\n\nLuminance 는 **휘도** 라는 뜻을 가집니다.\n\nThree.js 에서는 **emissive** 가 **빛을 방출하는 정도에 대한 속성** 이지만, 3D Tool 중 Cinema4D 에서는 **Luminance** 로 표기되어 있습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 예시 코드\n\n이번 포스팅에서 사용할 예시 코드는 다음과 같습니다.\n\n```js title=\"예시 코드\" showLineNumbers\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n\n    Color,\n    DirectionalLight,\n    HemisphereLight,\n\n    SphereGeometry,\n    MeshStandardMaterial,\n    Mesh,\n} from 'three';\nimport {\n    OrbitControls,\n} from 'three/examples/jsm/controls/OrbitControls';\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { OrbitControls } */\nlet controls;\n\n//\n// core\n//\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n    $canvas.width = window.innerWidth;\n    $canvas.height = window.innerHeight;\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.shadowMap.enabled = true;\n}\n\nfunction initScene() {\n    scene = new Scene();\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n    camera.fov = 35;\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.position.set(0, 0, 2);\n\n    camera.updateProjectionMatrix();\n}\n\nfunction initControls($emitter) {\n    controls = new OrbitControls(camera, $emitter);\n    controls.enableDamping = true;\n}\n\n//\n// light\n//\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n\n    const light = new DirectionalLight(color);\n    light.position.set(1, 1, 1);\n    light.castShadow = true;\n\n    scene.add(light);\n}\n\nfunction initHemisphereLight() {\n    const skyColor = new Color('#fff');\n    const groundColor = new Color('#000');\n\n    const light = new HemisphereLight(\n        skyColor,\n        groundColor,\n        0.25\n    );\n\n    scene.add(light);\n}\n\n//\n// mesh\n//\nfunction initSphereMesh() {\n    const geometry = new SphereGeometry();\n    const material = new MeshStandardMaterial();\n    const sphere = new Mesh(geometry, material);\n\n    scene.add(sphere);\n}\n\n//\n// executor\n//\nfunction render() {\n    window.requestAnimationFrame(render);\n\n    renderer.render(scene, camera);\n    controls.update();\n}\n\nfunction init() {\n    const $canvas = initCanvas();\n\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n    initControls($canvas);\n\n    initDirectionalLight();\n    initHemisphereLight();\n\n    initSphereMesh();\n\n    render();\n}\n\ninit();\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## GLTFLoader 를 사용하여 3D 모델 파일 불러오기\n\n.glb 또는 .gltf 파일을 불러오기 위해서는 Loader 가 필요합니다.\n\n이 때 사용하는 Loader 는 GLTFLoader 인스턴스 입니다.\n\n아래는 .gltf 파일을 불러온 후, 불러온 모델 객체를 `console.log()` 로 출력하고 있습니다.\n\n```js title=\"GLTFLoader import 하기\" showLineNumbers{17}\nimport {\n    GLTFLoader,\n} from 'three/examples/jsm/loaders/GLTFLoader';\n```\n\n```js title=\"GLTFLoader 로 .gltf 파일 불러오기\" showLineNumbers{112}\nfunction initRubberDuck() {\n    const loader = new GLTFLoader();\n    loader.load('/gltf/rubberDuck/rubber_duck_toy_4k.gltf', gltf =\u003e {\n        console.group('onLoad()');\n        console.log('gltf: ', gltf);\n        console.groupEnd();\n    });\n}\n```\n\n```js title=\"iniRubberDuct 함수 호출\" showLineNumbers{131} {13}\nfunction init() {\n    const $canvas = initCanvas();\n\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n    initControls($canvas);\n\n    initDirectionalLight();\n    initHemisphereLight();\n\n    initSphereMesh();\n    initRubberDuck();\n\n    render();\n}\n```\n\n\u003cbr /\u003e\n\n부라우저 콘솔에서 확인하면, GLTFLoader 가 불러온 3D 모델 객체를 확인할 수 있습니다.\n\n\n\n## 불러온 3D 모델 객체 렌더링하기\n\n불러온 3D 모델 객체에는 **scene 속성** 이 있습니다.\n\n**scene 속성** 을 Mesh 와 동일하게 취급할 수 있습니다.\n\n따라서 기존의 sphere Mesh 를 `scene.add()` 메서드로 추가했던 것과 동일한 방법으로 `scene` 에 추가할 수 있습니다.\n\n```js title=\"3D 모델 객체 렌더링\" showLineNumbers{112} {8-9}\nfunction initRubberDuck() {\n    const loader = new GLTFLoader();\n    loader.load('/gltf/rubberDuck/rubber_duck_toy_4k.gltf', gltf =\u003e {\n        console.group('onLoad()');\n        console.log('gltf: ', gltf);\n        console.groupEnd();\n\n        gltf.scene.position.set(0, -0.15, 0);\n        scene.add(gltf.scene);\n    });\n}\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-10-01/2024-01-10-01-01.png\" alt=\"3D 모델 렌더링\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 추가: 불러온 3D 모델이 깨지는 현상\n\n3D 모델을 Three.js 에 렌더링했을 때, 깨지는 현상이 발생할 수 있습니다.\n\n이는 3D Tool(예: Cinema4D, Blender) 를 사용하여, 모델의 **Material** 을 수정하여 해결할 수 있습니다.\n\n가장 유력한 케이스는 **Material** 설정 중, **Alpha** 설정이 활성화된 경우 입니다.\n\n만약 **Alpha** 설정이 활성화되어 있었다면, 해제 후 export 한 파일을 사용해봅니다.\n\n\u003cbr /\u003e\n\nThree.js 는 브라우저 환경에서 동작하기 때문에 3D Tool 의 무거운 기능들은 지원하지 않습니다.\n\n이러한 현상이 나타난다면, **Material** 을 좀 더 가볍게 하면 해소할 수 있습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 3D 모델 객체 구조 살펴보기\n\nThree.js 에 불러온 3D 모델을 그대로 렌더링했을 때, 원하는 결과를 얻지 못할 가능성이 큽니다.\n\n특히 그림자 설정은 3D 모델을 개발할 때 설정하는 것이 아닌, Three.js 에 렌더링할 객체의 설정이 필요한 경우입니다.\n\n이러한 이유로 Three.js 에 불러온 3D 모델 객체의 주요 속성들을 수정하기 위해, 먼저 속성들을 살펴보겠습니다.\n\n\u003cbr /\u003e\n\nGLTFLoader 로 불러운 3D 모델을 gltf 로 칭하겠습니다.\n\ngltf 객체는 크게 다음과 같은 속성이 있습니다.\n\n* scene\n    * Mesh 처럼 다룰 수 있으며, 렌더링할 때도 사용합니다.\n* animations\n    * 애니메이션 객체 입니다.\n* children\n    * 3D Tool 로 개발할 때 만든 부모-자식 계층 입니다.\n* material\n    * 현재 Mesh 의 Material 설정입니다.\n\n\u003cbr /\u003e\n\ngltf 객체의 scene 과 children 의 중첩구조를 살펴보면 크게 2가지 타입으로 이루어져 있습니다.\n\n* Mesh\n    * 실제 Mesh 객체입니다.\n* Object3D\n    * Mesh 가 아닌 기타 타입입니다.\n    * 3D Tool 의 Symmetry(대칭복사), Subdivision(곡선생성) 등의 기능으로 만든 부분 (엄밀히 Mesh 는 아니기 때문)\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\n3D Mesh 파일(.glTF, .gbl) 을 불러온 상태에서는 빛 반사나 그림자와 같은 효과는 적용되지 않습니다.\n\n다음 포스팅에서는 3D Mesh 불러온 후, Mesh 내부 속성을 변경하는 방법을 알아보겠습니다.\n"])</script><script>self.__next_f.push([1,"1c:T3408,"])</script><script>self.__next_f.push([1,"---\nid: 6\ntitle: 배경화면 및 환경조명 설정하기\ndescription: '360도 이미지 확장자인 .hdr 파일을 사용하여 배경화면을 설정하고, 배경화면에 의한 환경조명 설정에 대한 정리입니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    'javascript',\n    '3d',\n    'hdr',\n    'background',\n    '3D 배경화면',\n    '환경조명',\n]\n\ncreatedAt: '2024-01-08 23:50:00'\nmodifiedHistories: []\n---\n\n# 배경화면 및 환경조명 설정하기\n\n지금까지는 배경이 없는 환경에서 물체를 렌더링하였습니다.\n\n3D 환경에서 배경화면을 설정하기 위해 360도 이미지 파일인 **.hdr (Hign Dynamic Range)** 파일을 설정해 보고자 합니다.\n\n\u003cbr /\u003e\n\n추가로 배경화면이 물체에 반사되는 환경조명까지 설정해 보겠습니다.\n\n환경조명을 설정하게 되면, 배경이 스틸에 반사되는 효과를 연출할 수 있습니다.\n\n이를 위해 **Material** 설정 방법에 대해서도 정리합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 예시 코드\n\n이번 포스팅에서 사용할 예시 코드는 다음과 같습니다.\n\n```js title=\"예시 코드\" showLineNumbers\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n\n    Color,\n\n    DirectionalLight,\n    DirectionalLightHelper,\n    HemisphereLight,\n    HemisphereLightHelper,\n\n    Mesh,\n    MeshStandardMaterial,\n\n    SphereGeometry,\n    PlaneGeometry,\n\n    VSMShadowMap,\n} from 'three';\nimport {\n    OrbitControls,\n} from 'three/examples/jsm/controls/OrbitControls';\n\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { OrbitControls } */\nlet controls;\n\n//\n// core\n//\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n    $canvas.width = window.innerWidth;\n    $canvas.height = window.innerHeight;\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.shadowMap.enabled = true;\n    renderer.shadowMap.type = VSMShadowMap;\n}\n\nfunction initScene() {\n    scene = new Scene();\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n    camera.fov = 75;\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.position.set(-3, 3, 5);\n\n    camera.updateProjectionMatrix();\n}\n\nfunction initControls($canvas) {\n    controls = new OrbitControls(camera, $canvas);\n    controls.enableDamping = true;\n}\n\n//\n// light\n//\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n\n    const light = new DirectionalLight(\n        color,\n        0.75\n    );\n    light.position.set(1, 1, 1);\n    light.castShadow = true;\n    light.shadow.blurSamples = 30;\n    light.shadow.radius = 12;\n\n    const helper = new DirectionalLightHelper(light);\n\n    scene.add(light);\n    scene.add(helper);\n}\n\nfunction initHemisphereLight() {\n    const skyColor = new Color('#fff');\n    const groundColor = new Color('#000');\n\n    const light = new HemisphereLight(\n        skyColor,\n        groundColor,\n        0.25\n    );\n\n    const helper = new HemisphereLightHelper(light);\n\n    scene.add(light);\n    scene.add(helper);\n}\n\n//\n// mesh\n//\nfunction initSphereMesh() {\n    const geometry = new SphereGeometry();\n    const material = new MeshStandardMaterial();\n    const sphere = new Mesh(geometry, material);\n    sphere.castShadow = true;\n\n    scene.add(sphere);\n}\n\nfunction initPlaneMesh() {\n    const geometry = new PlaneGeometry(10, 10);\n    const material = new MeshStandardMaterial();\n    const plane = new Mesh(geometry, material);\n    plane.position.set(0, -1, 0);\n    plane.rotation.set(Math.PI / -2, 0, 0);\n    plane.receiveShadow = true;\n\n    scene.add(plane);\n}\n\n//\n// executor\n//\nfunction render() {\n    window.requestAnimationFrame(render);\n\n    controls.update();\n    renderer.render(scene, camera);\n}\n\n(function init() {\n    const $canvas = initCanvas();\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n    initControls($canvas);\n\n    initDirectionalLight();\n    initHemisphereLight();\n\n    initSphereMesh();\n    initPlaneMesh();\n\n    render();\n\n    console.log('init()');\n}());\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## **.hdr** 파일이란?\n\nThree.js 는 3D 환경입니다.\n\n배경화면을 설정하려면 일반적인 2D 이미지를 사용해서는 연출할 수 없습니다.\n\n**.hdr (High Dynamic Range)** 확장자를 가진 파일은 360도 이미지 파일이며, 이 파일을 사용하여 3D 환경에 배경화면을 설정할 수 있습니다.\n\n\u003cbr /\u003e\n\n360도 배경화면은 아래의 플렛폼에서 오픈소스로 다운로드할 수 있습니다.\n\n* [polyhaven.com](https://polyhaven.com/hdris)\n\n\n\n\u003cbr /\u003e\n\n\n\n## 용어 정리\n\n이번 포스팅에서 사용하게될 컴퓨터 그래픽스 용어에 대해 간단하게 정리하고 가겠습니다.\n\n### Vertex\n\n3D 공간에서 가장 작은 단위인 **점** 을 말합니다.\n\n### Edge\n\n2개의 Vertex 를 연결하여 생성된 **선** 을 말합니다.\n\n### Polygon\n\n복수의 Edge 를 연결하여 만들어진 **면** 을 말합니다.\n\n가장 작은 Polygon 은 3개의 Edge 로 만들 수 있는 삼각형 입니다.\n\n### Mesh\n\n복수의 Polygon 으로 만들 수 있는 다각형으로, 지금까지 사용해보았던 Sphere, Box, Plane 등을 말합니다.\n\n### Texture\n\n[참고: 나무위키](https://namu.wiki/w/%ED%85%8D%EC%8A%A4%EC%B2%98)\n\n3D 물체의 표면에 2D 이미지를 입혀서 렌더링 하는 방식을 말합니다.\n\nMesh 를 구성하는 Polygon 이 많을수록 성능을 많이 사용하게 되는데, 이를 해소하기 위해 Mesh 의 표면에 2D 이미지를 입히는 방식의 렌더링 요소 입니다.\n\n### emissive\n\nemission 은 **(빛)방사** 라는 뜻을 가집니다.\n\n컴퓨터 그래픽스에서 **emissive** 라는 용어를 사용하는데, 이는 Mesh 가 광원이 되여 빛을 방출한다는 것을 말합니다.\n\n### (영단어) equirectangular\n\n정사각형\n\n### (영단어) reflection\n\n반사\n\n### (영단어) refraction\n\n굴절\n\n\n\n\u003cbr /\u003e\n\n\n\n## RGBELoader 를 사용하여 .hdr 파일을 Texture 로 만들기\n\n3D 공간 자체를 하나의 Mesh 라고 가정해 보겠습니다.\n\nThree.js 에서는 `Scene` 객체가 배경의 역할을 하고 있습니다.\n\n배경화면을 설정하기 위해서는 `Scene` 의 `background` 에 `Texture` 를 입혀서 표현할 수 있습니다.\n\n\u003cbr /\u003e\n\nThree.js 는 다양한 **DataTextureLoader** 를 제공하는데, Loader 를 사용하면 360도 이미지인 `.hdr` 파일을 읽어서 `Texture` 객체로 만들 수 있습니다.\n\n생성한 `Texture` 를 `Scene` 의 `background` 로 입혀주는 것으로 배경화면을 설정할 수 있습니다.\n\n[Three.js 공식문서 - DataTextureLoader](https://threejs.org/docs/#api/en/loaders/DataTextureLoader)\n\n\u003cbr /\u003e\n\n```js title=\"import 하기\" showLineNumbers {21, 27}\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n\n    Color,\n\n    DirectionalLight,\n    DirectionalLightHelper,\n    HemisphereLight,\n    HemisphereLightHelper,\n\n    Mesh,\n    MeshStandardMaterial,\n\n    SphereGeometry,\n    PlaneGeometry,\n\n    VSMShadowMap,\n\n    EquirectangularReflectionMapping,\n} from 'three';\nimport {\n    OrbitControls,\n} from 'three/examples/jsm/controls/OrbitControls';\nimport {\n    RGBELoader,\n} from 'three/examples/jsm/loaders/RGBELoader';\n```\n\n```js title=\"Scene 에 배경화면 설정하기\" showLineNumbers{68} {4-9}\nfunction initScene() {\n    scene = new Scene();\n\n    const loader = new RGBELoader();\n    loader.load('/hrd/background.hdr', texture =\u003e {\n        texture.mapping = EquirectangularReflectionMapping;\n\n        scene.background = texture;\n    });\n}\n```\n\n\u003cbr /\u003e\n\n먼저 import 부분을 살펴보겠습니다.\n\n**EquirectangularReflectionMapping** 은 Texture 의 mapping 방식을 제공하는 **객체** 입니다.\n\nTexture 객체의 `mapping` 속성에 **EquirectangularReflectionMapping** 객체를 대입하는 것으로 mapping 방식을 설정하게 됩니다.\n\n\u003cbr /\u003e\n\nThree.js 에서 제공하는 Texture mapping 방식은 여러가지가 있습니다.\n\n[Three.js 공식문서 - Texture Constants](https://threejs.org/docs/index.html?q=texture#api/en/constants/Textures)\n\n* UVMapping (default)\n* CubeReflectionMapping \n* CubeRefractionMapping\n* EquirectangularReflectionMapping\n* EquirectangularRefractionMapping \n* CubeUVReflectionMapping\n\n\u003cbr /\u003e\n\n위에서 사용한 **EquirectangularReflectionMapping** 은 **environment map** 에 사용하는 Texture mapping 방식 입니다.\n\n이 mapping 방식을 사용하게 되면 `.hdr` 이미지가 마치 배경처럼 렌더링됩니다.\n\n\u003cbr /\u003e\n\nTexture 의 mapping 방식을 설정해준 뒤, **Scene** 의 `background` 속성에 Texture 를 대입하면 배경화면이 렌더링된 것을 볼 수 있습니다.\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-08-01/2024-01-08-01-01.png\" alt=\"배경화면 설정\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 환경조명 설정\n\n빛이 있어야 물체가 렌더링 됩니다.\n\n지금까지는 DirectionalLight 나 HemisphereLight 처럼 조명 객체를 생성하여 빛을 만들었습니다.\n\n이번에는 조명을 모두 제거하고, 환경조명으로 렌더링하고자 합니다.\n\n\u003cbr /\u003e\n\n**Scene** 의 `environment` 속성에 환경조명으로 사용할 Texture 를 대입하여 설정할 수 있습니다.\n\n`background` 로 사용했던 Texture 를 환경조명으로도 사용하도록 해보겠습니다.\n\n```js title=\"환경조명 설정하기\" showLineNumbers{68} {9}\nfunction initScene() {\n    scene = new Scene();\n\n    const loader = new RGBELoader();\n    loader.load('/hdr/background.hdr', texture =\u003e {\n        texture.mapping = EquirectangularReflectionMapping;\n\n        scene.background = texture;\n        scene.environment = texture;\n    });\n}\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-08-01/2024-01-08-01-02.png\" alt=\"환경조명 설정하기\" /\u003e\n\n\u003cbr /\u003e\n\n환경조명으로 설정한 Texture 의 밝은 부분과 어두운 부분이 조명의 세기로 적용되어 배경화면과 자연스러운 연출이 됩니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 배경화면을 반사하는 Mesh 만들기\n\nSphere 와 Plane Mesh 를 렌더링하고 있습니다.\n\n현재는 각 Mesh 에 설정한 **MeshStandardMaterial** 색상 그대로 렌더링되는 상태입니다.\n\n이번에는 Mesh 의 Material 에 설정을 추가하여, 배경화면이 Mesh 에 비추어지는 효과를 연출해 보겠습니다.\n\n\u003cbr /\u003e\n\nMesh 의 외관은 Material 에 의해 렌더링 결과가 달라집니다.\n\nMaterial 은 Mesh 의 색상이나 질감을 표현하는 객체입니다.\n\n배경화면을 반사하는 Mesh 를 만들기 위해서는 Material 설정을 사용하여 구현할 수 있습니다.\n\n```js title=\"배경화면을 반사하는 Mesh 설정하기\" showLineNumbers{134} {3-8}\nfunction initSphereMesh() {\n    const geometry = new SphereGeometry();\n    const material = new MeshStandardMaterial({\n        color: new Color('#fff'),\n        roughness: 0,\n        metalness: 1,\n        // emissive: Color('#000'),\n    });\n    const sphere = new Mesh(geometry, material);\n    sphere.castShadow = true;\n\n    scene.add(sphere);\n}\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-08-01/2024-01-08-01-03.png\" alt=\"Material 설정\" /\u003e\n\n\u003cbr /\u003e\n\n**MeshStandardMaterial** 생성자 params 를 사용하여 Material 를 설정하고 있습니다.\n\nparams 의 각 속성은 다음고 같은 설정을 가집니다.\n\n* `color`: \n    * Material 자체의 색상입니다. (Mesh 의 색상이 됩니다.)\n* `roughness`: \n    * 배경화면을 반사하는 Mesh 의 질감을 얼만큼 거칠게 표현할지에 대한 설정입니다.\n    * `0` 설정 시, 배경화면이 깔끔하게 반사됩니다.\n    * `1` 설정 시, 반사되는 배경화면이 분간하기 어려울 정도로 어글어져서 렌더링됩니다.\n* `metalness`:\n    * 매탈 재질처럼 보이는 정도를 설정합니다.\n    * `0` 설정 시, 메탈 느낌 보다는 플라스틱 느낌이 강하며, 함께 설정한 `color` 의 비중이 더 크게 렌더링됩니다.\n    * `1` 설정 시, 함께 설정한 `color` 는 거의 보이지 않고, 메탈 느낌으로 렌더링됩니다.\n* `emissive`:\n    * Mesh(Material) 이 방출하는 빛의 색상을 설정합니다.\n    * `밝은색` 설정 시, 광원처럼 밝은 빛을 내며, 자신의 그림자가 거의 생기지 않습니다.\n    * `어두운색` 설정 시, 발광하는 빛이 거의 없으며, 자신의 그림자가 비교적 선명하게 생깁니다.\n    * 일반적으로 활용도가 떨어지는 설정이라서, 잘 사용하지 않습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\nMaterial 설정을 통해 배경화면을 반사하는 효과를 연출해 보았습니다.\n\n이번에 사용한 반사효과는 배경화면만을 반사하고, Mesh 간의 반사는 렌더링되지 않습니다.\n\n**Post Processing** 기능을 사용하면, 거울처럼 다른 Mesh 와 상호작용하며 반사하는 연출이 가능해집니다.\n\n이 부분은 차후 정리할 예정입니다.\n\n[Three.js 공식문서 - 거울효과 예시](https://threejs.org/examples/?q=mirror#webgl_mirror)\n"])</script><script>self.__next_f.push([1,"1d:T2c06,"])</script><script>self.__next_f.push([1,"---\nid: 5\ntitle: 그림자 표현하기\ndescription: '그림자 설정방법과 특징에 대해 정리합니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    'javascript',\n    '3d',\n    'shadow',\n]\n\ncreatedAt: '2024-01-07 23:50:00'\nmodifiedHistories: []\n---\n\n# 그림자 표현하기\n\n그림자를 표현하기 위해서는 물체와 조명의 각도, 그림자의 크기, 형태 등의 상호작용 연산이 필요합니다.\n\n그래서 Three.js 의 그림자 설정의 기본값은 모두 미사용으로 설정되어 있습니다.\n\n이 덕분에 개발자가 원하는 조명과 원하는 물체의 그림자를 직접 지정하여 표현할 수 있습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 예시 코드\n\n이전 포스팅에서 바닥(땅) 을 만들었던 코드에 그림자 설정을 추가해 보겠습니다.\n\n```js title=\"예시 코드\" showLineNumbers\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n\n    Mesh,\n    MeshStandardMaterial,\n    SphereGeometry,\n    PlaneGeometry,\n\n    Color,\n    HemisphereLight,\n    HemisphereLightHelper,\n    DirectionalLight,\n    DirectionalLightHelper,\n} from 'three';\nimport {\n    OrbitControls,\n} from 'three/examples/jsm/controls/OrbitControls';\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { OrbitControls } */\nlet controls;\n\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n    $canvas.width = window.innerWidth;\n    $canvas.height = window.innerHeight;\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\nfunction initScene() {\n    scene = new Scene();\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n    camera.fov = 35;\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.position.set(0, 0, 12);\n\n    camera.updateProjectionMatrix();\n}\n\nfunction initControls($canvas) {\n    controls = new OrbitControls(camera, $canvas);\n    controls.enableDamping = true;\n}\n\nfunction initHemisphereLight() {\n    const skyColor = new Color('#fff');\n    const groundColor = new Color('#000');\n    const light = new HemisphereLight(\n        skyColor,\n        groundColor,\n        0.75\n    );\n\n    const helper = new HemisphereLightHelper(light);\n\n    scene.add(light);\n    scene.add(helper);\n}\n\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n    const light = new DirectionalLight(color);\n    light.position.set(2, 2, 2);\n\n    const helper = new DirectionalLightHelper(light);\n\n    scene.add(light);\n    scene.add(helper);\n}\n\nfunction initSphereMesh() {\n    const geometry = new SphereGeometry();\n    const material = new MeshStandardMaterial();\n    const sphere = new Mesh(geometry, material);\n\n    scene.add(sphere);\n}\n\nfunction initPlaneMesh() {\n    const geometry = new PlaneGeometry(10, 10);\n    const material = new MeshStandardMaterial();\n    const plane = new Mesh(geometry, material);\n    plane.position.set(0, -1, 0);\n    plane.rotation.set(\n        Math.PI * -0.5,\n        0,\n        0\n    );\n\n    scene.add(plane);\n}\n\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n}\n\nfunction render() {\n    window.requestAnimationFrame(render);\n\n    renderer.render(scene, camera);\n    controls.update();\n}\n\n(function init() {\n    const $canvas = initCanvas();\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n    initControls($canvas);\n\n    initHemisphereLight();\n    initDirectionalLight();\n\n    initSphereMesh();\n    initPlaneMesh();\n\n    render();\n}());\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 그림자 종류\n\nThree.js 에서 제공하는 그림자는 크게 2가지로 볼 수 있습니다.\n\n* Hard Shadow: 선명하며 거친 그림자를 표현합니다.\n* Soft Shadow: 부드러운 그림자를 표현합니다.\n\n\u003cbr /\u003e\n\nSoft Shadow 는 그림자에 Blur 를 적용하여 부드럽게 표현합니다.\n\n주의할 점은 Blur 값을 크게 설정할수록 부드럽게 표현하지만, 사용자 PC 의 연산량이 커진다는 것 입니다.\n\n\u003cbr /\u003e\n\nThree.js 의 그림자 설정은 다음과 같은 과정으로 만들 수 있습니다.\n\n1. Hard Shadow 설정하기\n2. Soft Shadow 설정 추가하기\n\n\n\n\u003cbr /\u003e\n\n\n\n## 그림자 설정이 필요한 인스턴스들\n\n그림자를 표현하려면 몇가지 설정을 함께 해주어야 합니다.\n\n아래는 그림자 설정이 필요한 인스턴스들 입니다.\n\n* WebGLRenderer 인스턴스\n* Light 인스턴스\n* Mesh 인스턴스\n\n\n\n\u003cbr /\u003e\n\n\n\n## WebGLRenderer 에 shadow 설정하기\n\nWebGLRenderer 는 **ShadowMap** 이라는 메커니즘을 제공합니다.\n\n지금은 컴퓨터 그래픽스에서 그림자를 표현하는 여러 알고리즘 중 한가지 라는 것 정도로 정리하고자 합니다.\n\n* WebGLRenderer shadowMap 은 그림자를 이미지로 생성한 후, 그림자를 씌우는 방식으로 동작합니다.\n\n\u003cbr /\u003e\n\n아래 코드는 WebGLRenderer 가 그림자를 표현하도록 설정합니다.\n\n```js title=\"WebGLRenderer 그림자 사용 설정\" showLineNumbers{111} {7}\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.shadowMap.enabled = true;\n}\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## Light 와 Mesh 의 그림자 설정 (Hard Shadow)\n\nLight 와 Mesh 의 그림자 설정 속성은 동일한 인터페이스를 가집니다.\n\n그림자 설정 속성은 크게 두가지가 있습니다.\n\n* 그림자를 만들어내는 설정: `castShadow`\n* 다른 Mesh 의 그림자를 받는 설정: `receiveShadow`\n\n\u003cbr /\u003e\n\nLight 가 비추는 빛은 다른 Mesh 에 의해 그림자를 생성하게 됩니다.\n\n그러므로 Light 의 **castShadow** 를 `true` 로 설정해줍니다.\n\n```js title=\"DirectionalLight shadow 설정\" showLineNumbers{78} {5}\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n    const light = new DirectionalLight(color);\n    light.position.set(2, 2, 2);\n    light.castShadow = true;\n\n    const helper = new DirectionalLightHelper(light);\n\n    scene.add(light);\n    scene.add(helper);\n}\n```\n\n\u003cbr /\u003e\n\n빛에 의해 그림자를 만들어내는 Mesh 역시 그림자를 생성하므로, **caseShadow** 를 `true` 로 설정해줍니다.\n\n```js title=\"Sphere Mesh shadow 설정\" showLineNumbers{90} {5}\nfunction initSphereMesh() {\n    const geometry = new SphereGeometry();\n    const material = new MeshStandardMaterial();\n    const sphere = new Mesh(geometry, material);\n    sphere.castShadow = true;\n\n    scene.add(sphere);\n}\n```\n\n\u003cbr /\u003e\n\n바닥(땅) 을 표현한 Plane Mesh 는 다른 Mesh 의 그림자를 받게 되므로, **receiveShadow** 를 `true` 로 설정해줍니다.\n\n```js title=\"Plane Mesh shadow 설정\" showLineNumbers{99} {12}\nfunction initPlaneMesh() {\n    const geometry = new PlaneGeometry(10, 10);\n    const material = new MeshStandardMaterial();\n    const plane = new Mesh(geometry, material);\n    plane.position.set(0, -1, 0);\n    plane.rotation.set(\n        Math.PI * -0.5,\n        0,\n        0\n    );\n\n    plane.receiveShadow = true;\n\n    scene.add(plane);\n}\n```\n\n\u003cbr /\u003e\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-07-02/2024-01-07-02-01.png\" alt=\"Hard Shadow\" /\u003e\n\n\u003cbr /\u003e\n\n지금까지 설정하여 만들어낸 그림자는 **Hard Shadow** 입니다.\n\nBlur 처리를 하지 않기 때문에 선명한 그림자가 그려지고, 곡선에서 픽셀이 보이는 특징이 있습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## Soft Shadow 설정 추가하기\n\nHard Shadow 설정을 한 후, WebGLRenderer 의 `shadowMap.type` 을 `VSMShadowMap` 으로 설정하므로써 Soft Shadow 로 표현됩니다.\n\n```js title=\"VSMShadowMap import 하기\" showLineNumbers {16}\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n\n    Mesh,\n    MeshStandardMaterial,\n    SphereGeometry,\n    PlaneGeometry,\n\n    Color,\n    HemisphereLight,\n    HemisphereLightHelper,\n    DirectionalLight,\n    DirectionalLightHelper,\n    VSMShadowMap,\n} from 'three';\n```\n\n```js title=\"Soft Shadow\" showLineNumbers{116} {8}\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.shadowMap.enabled = true;\n    renderer.shadowMap.type = VSMShadowMap;\n}\n```\n\n\u003cbr /\u003e\n\n위 코드에서 사용한 `VSMShadowMap` 이외에도 다른 종류의 shadowMap 을 사용할 수도 있습니다. (이번 포스팅에서는 `VSMShadowMap` 을 사용합니다.)\n\n[Three.js 공식 문서 - WebGLRenderer.shadowMap](https://threejs.org/docs/index.html?q=webglRenderer#api/en/renderers/WebGLRenderer.shadowMap)\n\n* BasicShadowMap\n* PCFShadowMap (default)\n* PCFSoftShadowMap\n* VSMShadowMap\n\n\u003cbr /\u003e\n\n위 설정을 추가한 후, 결과를 확인하면 Hard Shadow 와 다른점이 없어 보입니다.\n\n이는 그림자를 생성하는 Light 의 **Blur 정도** 와 **번지는 영역의 Radius** 를 변경하면서 부드러움이 달라지는 것을 확인할 수 있습니다.\n\n```js title=\"DirectionalLight 의 Blur 와 Radius 설정\" showLineNumbers{79} {6-7}\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n    const light = new DirectionalLight(color);\n    light.position.set(2, 2, 2);\n    light.castShadow = true;\n    light.shadow.blurSamples = 30;\n    light.shadow.radius = 12;\n\n    const helper = new DirectionalLightHelper(light);\n\n    scene.add(light);\n    scene.add(helper);\n}\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-07-02/2024-01-07-02-02.png\" alt=\"Soft Shadow\" /\u003e\n\n\u003cbr /\u003e\n\nLight 의 shadow 설정 시, 주의할 사항은 다음과 같습니다.\n\n* `shadow.blurSamples`: 값이 커질수록 부드러운 그림자를 표현하지만, 필요 성능이 높아집니다.\n* `shadow.radius`: 값이 너무 작으면 화면이 깨지는 현상이 있으므로, **10 이상** 설정을 권장합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 추가: VSMShadowMap 에 대하여\n\nSoft Shadow 를 표현하기 위해 VSMShadowMaper 을 사용해 보았습니다.\n\nVSMShadowMap 은 곡선에 대한 그림자를 부드럽게 표현할 수 있는 특징을 가졌습니다.\n\n그래서 지금까지 실습했던 Shpere Mesh 의 그림자를 부드럽게 표현할 수 있었습니다.\n\n\u003cbr /\u003e\n\n만약 Sphere Mesh 가 아닌 Box Mesh 에 VSMShadowMap 을 적용한다면, 그림자가 드리우지 않아야 하는 영역까지 침범하는 현상을 볼 수 있습니다.\n\n이는 VSMShadowMap 의 Blur 처리가 되면서 번지는 그림자가 렌더링된 결과 입니다.\n\n\u003cbr /\u003e\n\n화면 구성에 Box Mesh 가 많다면, VSMShadowMap 을 사용했을 때 오히려 지저분한 그림자가 만들어질 수 있다는 점을 고려하여 선택해야 합니다.\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-07-02/2024-01-07-02-03.png\" alt=\"VSMShadow 단점\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\n그림자는 조명과 물제의 상호연산을 사용하기 때문에 연산량이 많이 필요하다고 합니다.\n\n그래서 그림자를 최소한으로 사용할 수 있도록 여러가지 설정을 분리시켜놓은 느낌이 들었습니다.\n\nThree.js 를 활용할 때, 그림자 설정이 성능 최적화 대상이라는 것을 알게 되었습니다.\n"])</script><script>self.__next_f.push([1,"1e:T1a79,"])</script><script>self.__next_f.push([1,"---\nid: 4\ntitle: 평평한 바닥(땅) 만들기 (Plane Mesh)\ndescription: '바닥을 표현하기 위해 Plane Mesh 를 생성합니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    'javascript',\n    '3d',\n    'plane',\n]\n\ncreatedAt: '2024-01-07 23:20:00'\nmodifiedHistories: []\n---\n\n# 평평한 바닥(땅) 만들기 (Plane Mesh)\n\n이번 포스팅에서는 바닥(땅) 을 만들어 보겠습니다.\n\nThree.js 에서는 바닥(땅) 을 **Plane Mesh** 로 만들 수 있습니다.\n\n다음 포스팅에서 다룰 그림자를 표현하려면, 바닥(땅) 이 있어야 하므로 별도의 포스팅으로 분리하게 되었습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 예시 코드\n\n이번 포스팅에서 사용할 예시 코드는 다음과 같습니다.\n\n```js title=\"예시 코드\" showLineNumbers {96}\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n\n    Mesh,\n    MeshStandardMaterial,\n    SphereGeometry,\n\n    Color,\n    HemisphereLight,\n    HemisphereLightHelper,\n    DirectionalLight,\n    DirectionalLightHelper,\n} from 'three';\nimport {\n    OrbitControls,\n} from 'three/examples/jsm/controls/OrbitControls';\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { OrbitControls } */\nlet controls;\n\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n    $canvas.width = window.innerWidth;\n    $canvas.height = window.innerHeight;\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\nfunction initScene() {\n    scene = new Scene();\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n    camera.fov = 35;\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.position.set(0, 0, 12);\n\n    camera.updateProjectionMatrix();\n}\n\nfunction initControls($canvas) {\n    controls = new OrbitControls(camera, $canvas);\n    controls.enableDamping = true;\n}\n\nfunction initHemisphereLight() {\n    const skyColor = new Color('#fff');\n    const groundColor = new Color('#000');\n    const light = new HemisphereLight(\n        skyColor,\n        groundColor,\n        0.75\n    );\n\n    const helper = new HemisphereLightHelper(light);\n\n    scene.add(light);\n    scene.add(helper);\n}\n\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n    const light = new DirectionalLight(color);\n    light.position.set(2, 2, 2);\n\n    const helper = new DirectionalLightHelper(light);\n\n    scene.add(light);\n    scene.add(helper);\n}\n\nfunction initSphereMesh() {\n    const geometry = new SphereGeometry();\n    const material = new MeshStandardMaterial();\n    const sphere = new Mesh(geometry, material);\n\n    scene.add(sphere);\n}\n\n// 여기에 Plane Mesh(바닥) 을 생성하는 함수를 구현할 예정입니다.\n\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n}\n\nfunction render() {\n    window.requestAnimationFrame(render);\n\n    renderer.render(scene, camera);\n    controls.update();\n}\n\n(function init() {\n    const $canvas = initCanvas();\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n    initControls($canvas);\n\n    initHemisphereLight();\n    initDirectionalLight();\n\n    initSphereMesh();\n\n    render();\n}());\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## Plane Mesh 생성 함수 만들기\n\nPlane Mesh 는 **PlaneGeometry** class 를 사용하여 생성할 수 있습니다.\n\n```js title=\"PlaneGeometry class import 하기\" showLineNumbers {9}\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n\n    Mesh,\n    MeshStandardMaterial,\n    SphereGeometry,\n    PlaneGeometry,\n\n    Color,\n    HemisphereLight,\n    HemisphereLightHelper,\n    DirectionalLight,\n    DirectionalLightHelper,\n} from 'three';\n```\n\n```js title=\"initPlaneMesh() 함수 구현하기\" showLineNumbers{97}\nfunction initPlaneMesh() {\n    const geometry = new PlaneGeometry();\n    const material = new MeshStandardMaterial();\n    const plane = new Mesh(geometry, material);\n    plane.position.set(0, -1, 0);\n\n    scene.add(plane);\n}\n```\n\n```js title=\"initPlaneMesh 함수 호출하기\" showLineNumbers{120} {12}\n(function init() {\n    const $canvas = initCanvas();\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n    initControls($canvas);\n\n    initHemisphereLight();\n    initDirectionalLight();\n\n    initSphereMesh();\n    initPlaneMesh();\n\n    render();\n}());\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-07-01/2024-01-07-01-01.png\" alt=\"PlaneMesh\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## Plane Mesh 회전 및 크기 변경하기\n\n위 코드를 실행하면, Sphere 하부에 사각형 물체가 렌더링됩니다.\n\n**width**, **height**, **rotation** 을 변경하여 바닥(땅) 처럼 보이도록 설정해 보겠습니다.\n\n```js title=\"initPlaneMesh() 함수 구현하기\" showLineNumbers{97} {2, 6-10}\nfunction initPlaneMesh() {\n    const geometry = new PlaneGeometry(5, 5);\n    const material = new MeshStandardMaterial();\n    const plane = new Mesh(geometry, material);\n    plane.position.set(0, -1, 0);\n    plane.rotation.set(\n        Math.PI * -0.5, \n        0, \n        0\n    );\n\n    scene.add(plane);\n}\n```\n\n\u003cbr /\u003e\n\nPlaneGeometry class 는 생성자에 **width** 와 **height** 를 넘겨주어 크기를 설정할 수 있습니다.\n\n```js title=\"width, height 설정\" showLineNumbers{98}\nconst geometry = new PlaneGeometry(5, 5);\n```\n\n\u003cbr /\u003e\n\n그리고 Plane Mesh 인스턴스의 `rotation.set()` 메소드를 사용하여 회전시킬 수 있습니다.\n\n회전시킬 값은 **Radian** 으로 넘겨주어야 하므로, **Math.PI** 를 사용합니다.\n\n```js title=\"회전 시키기\" showLineNumbers{102} {2}\nplane.rotation.set(\n    Math.PI * -0.5, \n    0, \n    0\n);\n```\n\n위 코드에서 X축 회전으로 `Math.PI * -0.5` 를 주었는데, 이는 아래와 같은 Plane Mesh 의 특성으로 고려한 것입니다.\n\n* Plane Mesh 는 한쪽면만 렌더링되는 단면 물체 입니다.\n* 렌더링되지 않는 반대쪽 면에는 그림자가 드리우지 않습니다.\n\n\u003cbr /\u003e\n\n이렇게 실행한 결과는 다음과 같습니다.\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-07-01/2024-01-07-01-02.png\" alt=\"PlaneMesh 설정\" /\u003e\n\n\u003cbr /\u003e\n\n카메라를 회전시켜서 Plane Mesh 의 반대쪽 면을 보면, 렌더링되지 않은 결과를 볼 수 있습니다.\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-07-01/2024-01-07-01-03.png\" alt=\"PlaneMesh 반대면\" /\u003e\n\n\n\n## 마치며\n\nPlane Mesh 를 생성하여 바닥(땅) 을 만들 수 있게 되었습니다.\n\n다음 포스팅에서는 바닥(땅) 에 그림자를 표현하여, 조명과 물체의 자연스러운 연출 방법을 정리해 보겠습니다.\n"])</script><script>self.__next_f.push([1,"1f:T2eef,"])</script><script>self.__next_f.push([1,"---\nid: 3\ntitle: 조명 종류와 설정\ndescription: '조명 종류와 설정 방법에 대해 정리합니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    'javascript',\n    '3d',\n    'light',\n]\n\ncreatedAt: '2024-01-06 23:00:00'\nmodifiedHistories: []\n---\n\n# 조명 종류와 설정\n\nThree.js 는 조명이 없으면 검은 화면만 보이게 됩니다.\n\n이번 포스팅에서는 조명의 종류와 특징, 설정 방법에 대해 정리하고자 합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 조명 종류\n\n조명의 종류는 다음과 같습니다.\n\n* DirectionalLight\n* PointLight\n* AmbientLight\n* HemisphereLight\n\n그리고 개발환경에서 조명의 광원 위치를 파악하기 쉽게 도와주는 **Helper class** 가 있습니다.\n\n자세한 사항은 각 조명과 함께 정리하겠습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 예시 코드\n\n이번 포스팅에서 사용할 예시 코드는 다음과 같습니다.\n\n```js title=\"예시 코드\" showLineNumbers {94}\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n\n    SphereGeometry,\n    MeshStandardMaterial,\n    Mesh,\n\n    Color,\n\n    DirectionalLight,\n    DirectionalLightHelper,\n} from 'three';\nimport './style.css';\nimport {\n    OrbitControls,\n} from 'three/examples/jsm/controls/OrbitControls';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { OrbitControls } */\nlet controls;\n\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n    $canvas.width = window.innerWidth;\n    $canvas.height = window.innerHeight;\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n}\n\nfunction initScene() {\n    scene = new Scene();\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n    camera.fov = 35;\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.position.set(0, 0, 10);\n\n    camera.updateProjectionMatrix();\n}\n\nfunction initControls($canvas) {\n    controls = new OrbitControls(camera, $canvas);\n    controls.enableDamping = true;\n}\n\nfunction createSphere() {\n    const geometry = new SphereGeometry();\n    const material = new MeshStandardMaterial();\n    const sphere = new Mesh(geometry, material);\n\n    return sphere;\n}\n\nfunction render() {\n    requestAnimationFrame(render);\n\n    renderer.render(scene, camera);\n    controls.update();\n}\n\nfunction init() {\n    const $canvas = initCanvas();\n\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n    initControls($canvas);\n\n    const sphere = createSphere();\n    scene.add(sphere);\n\n    // 여기에서 `조명 설정` 함수를 호출하며 실습할 예정입니다.\n\n    render();\n}\n\ninit();\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## DirectionalLight\n\nDirectionalLight 는 **광원** 에서 **특정 지점(lookAt(좌표))** 로 비추는 **단방향 조명** 입니다.\n\n물체에 비추는 빛의 양은 광원과의 거리와 무관한 빛의 세기(intensity) 설정값이 적용됩니다.\n\n\u003cbr /\u003e\n\n```js title=\"DirectionalLight import 하기\" showLineNumbers\nimport {\n    DirectionalLight,\n} from 'three';\n```\n\n```js title=\"DirectionalLight\" showLineNumbers{83} {9, 14-18}\nfunction init() {\n    initRenderer(initCanvas());\n    initCamera();\n    initScene();\n\n    const sphere = createSphere();\n    scene.add(sphere);\n\n    initDirectionalLight();\n\n    render();\n}\n\nfunction initDirectionalLight() {\n    const light = new DirectionalLight();\n    light.position.set(1, 1, 1);\n    scene.add(light);\n}\n\ninit();\n```\n\n\u003cbr /\u003e\n\nDirectionalLight 생성자에 인자로 **Color 객체** 를 넘겨주어 빛의 색상을 변경할 수 있습니다.\n\n**Color** 는 Three.js 에서 제공하는 class 이며, Three.js 의 색상관련 설정은 **Color 인스턴스** 를 받습니다.\n\n```js title=\"Color import 하기\" showLineNumbers\nimport {\n    Color,\n} from 'three';\n```\n\n```js title=\"DirectionalLight 색상 설정하기\" showLineNumbers{83} {15}\nfunction init() {\n    initRenderer(initCanvas());\n    initCamera();\n    initScene();\n\n    const sphere = createSphere();\n    scene.add(sphere);\n\n    initDirectionalLight();\n\n    render();\n}\n\nfunction initDirectionalLight() {\n    const color = new Color('#f0f400');\n    const light = new DirectionalLight(color);\n    light.position.set(1, 1, 1);\n\n    scene.add(light);\n}\n\ninit();\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-06-01/2024-01-06-01-01.png\" alt=\"DirectionalLight\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n### DirectionalLightHelper\n\nDirectionalLight 의 광원을 표기해주는 기능을 사용해 보겠습니다.\n\nDirectionalLightHelper 인스턴스를 생성한 후, `scene.add()` 를 사용하여 등록해 줍니다.\n\n```js title=\"DirectionalLightHelper import 하기\" showLineNumbers {3}\nimport {\n    DirectionalLight,\n    DirectionalLightHelper,\n} from 'three';\n```\n\n```js title=\"DirectionalLight 색상 설정하기\" showLineNumbers{83} {20-21}\nfunction init() {\n    initRenderer(initCanvas());\n    initCamera();\n    initScene();\n\n    const sphere = createSphere();\n    scene.add(sphere);\n\n    initDirectionalLight();\n\n    render();\n}\n\nfunction initDirectionalLight() {\n    const color = new Color('#f0f400');\n    const light = new DirectionalLight(color);\n    light.position.set(1, 1, 1);\n    scene.add(light);\n\n    const helper = new DirectionalLightHelper(light);\n    scene.add(helper);\n}\n\ninit();\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-06-01/2024-01-06-01-02.png\" alt=\"DirectionalLightHelper\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 빛의 세기(intensity) 설정하기\n\n조명은 빛의 세기(intensity) 가 있습니다.\n\nThree.js 의 모든 조명에도 빛의 세기(intensity) 를 설정할 수 있습니다.\n\n빛의 세기 값은 **0 ~ 1** 값으로 설정합니다.\n\n아래 코드는 DirectionalLight 에 빛의 세기(intensity) 를 0.75 로 설정하고 있습니다.\n\n```js title=\"DirectionalLight 색상 설정하기\" showLineNumbers{83} {18}\nfunction init() {\n    initRenderer(initCanvas());\n    initCamera();\n    initScene();\n\n    const sphere = createSphere();\n    scene.add(sphere);\n\n    initDirectionalLight();\n\n    render();\n}\n\nfunction initDirectionalLight() {\n    const color = new Color('#f0f400');\n    const light = new DirectionalLight(\n        color, \n        0.75\n    );\n    light.position.set(1, 1, 1);\n    scene.add(light);\n\n    const helper = new DirectionalLightHelper(light);\n    scene.add(helper);\n}\n\ninit();\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## PointLight\n\n전등처럼 한 점에서 빛을 방사하는 조명 입니다.\n\n사용방법은 다음과 같습니다.\n\n```js title=\"PointLight import 하기\" showLineNumbers\nimport {\n    PointLight,\n    PointLightHelper,\n} from 'three';\n```\n\n```js title=\"PointLight 색상 설정하기\" showLineNumbers{83} {9, 14-25}\nfunction init() {\n    initRenderer(initCanvas());\n    initCamera();\n    initScene();\n\n    const sphere = createSphere();\n    scene.add(sphere);\n\n    initPointLight();\n\n    render();\n}\n\nfunction initPointLight() {\n    const color = new Color('#f0f400');\n    const light = new PointLight(\n        color,\n        0.75 // 빛의 세기(intensity)\n    );\n    light.position.set(1, 1, 1);\n    scene.add(light);\n\n    const helper = new PointLightHelper(light);\n    scene.add(helper);\n}\n\ninit();\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-06-01/2024-01-06-01-03.png\" alt=\"PointLight\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## AmbientLight\n\nAmbient 는 `주변` 이라는 뜻을 가지고 있습니다.\n\nAmbientLight 는 특정한 광원이 없고, 모든 영역에 동일하게 비추는 조명입니다.\n\n즉 `(x, y, z)` 에 관계없이 동일한 빛을 비춥니다.\n\n\u003cbr /\u003e\n\nAmbientLight 가 적용된 결과를 확인하기 위해, PointLight 와 함께 사용해 보겠습니다.\n\n```js title=\"PointLight import 하기\" showLineNumbers {5}\nimport {\n    PointLight,\n    PointLightHelper,\n\n    AmbientLight,\n} from 'three';\n```\n\n```js title=\"PointLight 색상 설정하기\" showLineNumbers{83} {10, 28-35}\nfunction init() {\n    initRenderer(initCanvas());\n    initCamera();\n    initScene();\n\n    const sphere = createSphere();\n    scene.add(sphere);\n\n    initPointLight();\n    initAmbientLight();\n\n    render();\n}\n\nfunction initPointLight() {\n    const color = new Color('#f0f400');\n    const light = new PointLight(\n        color,\n        0.75 // 빛의 세기(intensity)\n    );\n    light.position.set(1, 1, 1);\n    scene.add(light);\n\n    const helper = new PointLightHelper(light);\n    scene.add(helper);\n}\n\nfunction initAmbientLight() {\n    const color = new Color('#fff');\n    const light = new AmbientLight(\n        color,\n        0.25, // 빛의 세기(intensity)\n    );\n    scene.add(light);\n}\n\ninit();\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-06-01/2024-01-06-01-04.png\" alt=\"AmbientLight\" /\u003e\n\n\u003cbr /\u003e\n\n그리고 AmbientLight 는 모든 영역에 비추는 조명이므로, **Helper class 가 없다는 특징** 이 있습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## HemisphereLight\n\nHemisphereLight 는 위쪽(skyColor) 와 아래쪽(groundColor) 를 인자로 받고, 그라데이션으로 비추는 조명입니다.\n\n일반적으로 기본 조명으로 사용하는데, 이는 Three.js 특성 때문입니다.\n\n* 조명이 없으면, 물체(Mesh) 는 보이지 않는 검은 화면만 렌더링 됩니다.\n* 다른 조명에 의해 생기는 그림자를 좀 더 자연스럽고 부드럽게 만들어줍니다.\n\n\u003cbr /\u003e\n\n아래 코드는 HemisphereLight 와 DirectionalLight 를 조합한 예시 입니다.\n\n```js title=\"PointLight import 하기\" showLineNumbers {5-6}\nimport {\n    DirectionalLight,\n    DirectionalLightHelper,\n\n    HemisphereLight,\n    HemisphereLightHelper,\n} from 'three';\n```\n\n```js title=\"PointLight 색상 설정하기\" showLineNumbers{83} {10, 28-40}\nfunction init() {\n    initRenderer(initCanvas());\n    initCamera();\n    initScene();\n\n    const sphere = createSphere();\n    scene.add(sphere);\n\n    initDirectionalLight();\n    initHemisphereLight();\n\n    render();\n}\n\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n    const light = new DirectionalLight(\n        color,\n        0.75 // 빛의 세기(intensity)\n    );\n    light.position.set(1, 1, 1);\n    scene.add(light);\n\n    const helper = new PointLightHelper(light);\n    scene.add(helper);\n}\n\nfunction initHemisphereLight() {\n    const skyColor = new Color('#fff');\n    const groundColor = new Color('#000');\n    const light = new HemisphereLight(\n        skyColor,\n        groundColor,\n        0.25, // 빛의 세기(intensity)\n    );\n    scene.add(light);\n\n    const helper = new HemisphereLightHelper(light);\n    scene.add(helper);\n}\n\ninit();\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-06-01/2024-01-06-01-05.png\" alt=\"Hemisphere\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\n일반적으로 DirectionalLight 와 HemisphereLight 를 조합하여 기본 조명을 구성합니다.\n\n각 설정은 다음과 같습니다.\n\n```js title=\"일반적인 조명 설정\" showLineNumbers\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n    const light = new DirectionalLight(\n        color,\n        0.75 // HemispherLight 보다 0.5 강하게 설정합니다.\n    );\n    scene.add(light);\n}\n\nfunction initHemisphereLight() {\n    const skyColor = new Color('#fff');\n    const groundColor = new Color('#000');\n    const light = new HemisphereLight(\n        skyColor,\n        groundColor,\n        0.25 // DirectionalLight 보다 0.5 약하게 설정합니다.\n    );\n    scene.add(light);\n}\n```\n\n\u003cbr /\u003e\n\nHemisphereLight 를 사용하므로써 그림자 부분이 검은색으로 보이지 않도록 해주며, 좀 더 자연스러운 조명을 연출할 수 있습니다.\n\n그리고 PointLight 는 특정 물체를 강조하거나 효과를 주기위해 주로 사용합니다.\n\n\u003cbr /\u003e\n\nThree.js 는 개발 능력뿐만 아니라 사물을 표현하는 예술 능력도 필요하겠다는 느낌이 듭니다. 😱\n"])</script><script>self.__next_f.push([1,"20:T3ac1,"])</script><script>self.__next_f.push([1,"---\nid: 2\ntitle: 카메라 설정 (PerspectiveCamera)\ndescription: 'Three.js 의 카메라인 PerspectiveCamera 설정에 대한 포스팅입니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    'javascript',\n    '3d',\n    'camera',\n]\n\ncreatedAt: '2024-01-01 23:50:00'\nmodifiedHistories: []\n---\n\n# 카메라 설정 (PerspectiveCamera)\n\nThree.js 가 `\u003ccanvas /\u003e` 에 실제로 렌더링하는 부분은 `카메라 (PerspectiveCamera)` 가 비추는 영역입니다.\n\n이번 포스팅에서는 카메라 설정과 효과, 사용자 인터렉션 적용 방법에 대해 정리해 보겠습니다.\n\n이번 포스팅에서는 아래의 코드를 시작점으로 사용하겠습니다.\n\n```js title=\"샘플 코드\" showLineNumbers\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    Scene,\n    DirectionalLight,\n\n    BoxGeometry,\n    MeshPhongMaterial,\n    Mesh,\n} from 'three';\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { Scene } */\nlet scene;\n\n(function init() {\n    const $canvas = initCanvas();\n\n    initRenderer($canvas);\n\n    const light = createLight();\n    const boxMesh = createBoxMesh();\n\n    initCamera();\n    initScene(light, boxMesh);\n\n    render();\n\n    console.log('시작');\n}());\n\nfunction render() {\n    renderer.render(scene, camera);\n\n    window.requestAnimationFrame(render);\n}\n\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\n/**\n * @param { HTMLCanvasElement } $canvas \n */\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.setSize(\n        window.innerWidth,\n        window.innerHeight\n    );\n}\n\nfunction createLight() {\n    const light = new DirectionalLight();\n    light.position.set(1, 2, 3);\n\n    return light;\n}\n\nfunction createBoxMesh() {\n    const boxGeometry = new BoxGeometry();\n    const boxMaterial = new MeshPhongMaterial();\n\n    return new Mesh(boxGeometry, boxMaterial);\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera(\n        45,\n        window.innerWidth / window.innerHeight\n    );\n\n    camera.position.set(0, 0, 5);\n}\n\nfunction initScene(...items) {\n    scene = new Scene();\n\n    items.forEach(item =\u003e {\n        scene.add(item);\n    });\n}\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## PerspectiveCamera 생성자 params\n\n카메라 생성자 params 를 사용하여 초기 설정을 할 수 있습니다.\n\n```ts title=\"PerspectiveCamera 생성자 함수\" showLineNumbers\nclass PerspectiveCamera {\n    constructor(\n        fov?: number,\n        aspect?: number,\n        near?: number,\n        far?: number\n    );\n}\n```\n\n* fov (Field of View): 시야각 (화각)\n    * fov 설정값이 클수록 먼 거리에서 보는 느낌이 납니다.\n    * fov 설정값이 커질수록 **투시에 따른 왜곡현상** 이 도드라지게 나타납니다.\n* aspect: 카메라 종횡비 (aspect radio)\n    * 카메라의 가로, 세로 비율값 입니다.\n* near: (Near clipping)\n    * 카메라를 기준으로 가까운 물체(Mesh) 에 대한 렌더링 잘라내기 설정값 입니다.\n* far: (Far clipping)\n    * 카메라를 기준으로 먼 물체(Mesh) 에 대한 렌더링 잘라내기 설정값 입니다.\n\n\u003cbr /\u003e\n\n위 설정들은 PerspectiveCamera 생성자를 통해서도 설정할 수 있고, 객체를 생성한 후 설정을 변경할 수도 있습니다.\n\n만약 객체를 생성한 후 설정을 변경한다면, 카메라 메소드인 **updateProjectionMatrix()** 함수를 호출하여야 실제 렌더링에 반영됩니다.\n\n아래 코드는 PerspectiveCamera 객체를 생성한 후, 카메라 설정을 변경하고 있습니다.\n\n```js title=\"카메라 객체 설정값 변경하기\" showLineNumbers {88, 89, 92}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    Scene,\n    DirectionalLight,\n\n    BoxGeometry,\n    MeshPhongMaterial,\n    Mesh,\n} from 'three';\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { Scene } */\nlet scene;\n\n(function init() {\n    const $canvas = initCanvas();\n\n    initRenderer($canvas);\n\n    const light = createLight();\n    const boxMesh = createBoxMesh();\n\n    initCamera();\n    initScene(light, boxMesh);\n\n    render();\n\n    console.log('시작');\n}());\n\nfunction render() {\n    renderer.render(scene, camera);\n\n    window.requestAnimationFrame(render);\n}\n\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\n/**\n * @param { HTMLCanvasElement } $canvas \n */\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.setSize(\n        window.innerWidth,\n        window.innerHeight\n    );\n}\n\nfunction createLight() {\n    const light = new DirectionalLight();\n    light.position.set(1, 2, 3);\n\n    return light;\n}\n\nfunction createBoxMesh() {\n    const boxGeometry = new BoxGeometry();\n    const boxMaterial = new MeshPhongMaterial();\n\n    return new Mesh(boxGeometry, boxMaterial);\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera(\n        // 45,\n        // window.innerWidth / window.innerHeight\n    );\n\n    camera.fov = 45;\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.position.set(0, 0, 3);\n\n    camera.updateProjectionMatrix();\n}\n\nfunction initScene(...items) {\n    scene = new Scene();\n\n    items.forEach(item =\u003e {\n        scene.add(item);\n    });\n}\n```\n\n\u003cbr /\u003e\n\n위 코드의 실행 결과로 BoxMesh 의 단면을 볼 수 있습니다.\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-01-01/2024-01-01-01-01.png\" alt=\"실행 결과\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 카메라의 주시 좌표값 변경하기\n\n현재는 BoxMesh 의 단면만을 비추고 있어서 마치 2D 인것 처럼 보입니다.\n\n카메라의 위치와 카메라의 주시 좌표값을 변경하면, 물체를 다각도에서 다양한 구도로 렌더링할 수 있습니다.\n\n\u003cbr /\u003e\n\n먼저 카메라의 위치를 (1, 1, 2) 로 변경해 보겠습니다.\n\n```js title=\"카메라 position 변경\" showLineNumbers{82} {6}\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n\n    camera.fov = 45;\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.position.set(1, 1, 2);\n\n    camera.updateProjectionMatrix();\n}\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-01-01/2024-01-01-01-02.png\" alt=\"실행 결과\" /\u003e\n\n\u003cbr /\u003e\n\n카메라의 position 만을 변경한 결과, BoxMesh 의 일부분만 렌더링되고 있습니다.\n\n이는 카메라의 주시 좌표값을 설정하지 않아서 카메라 위치에서 정면을 주시하고 있기 때문입니다.\n\n카메라 객체의 `lookAt()` 메소드를 사용하면, 카메라의 위치인 position 에서 특정 좌표를 주시하게 됩니다.\n\nBoxMesh 가 카메라의 중앙에 오도록 하기위해, BoxMesh 의 position 위치값인 (0, 0, 0) 으로 카메라 주시 좌표를 설정해 보겠습니다.\n\n```js title=\"카메라 position 변경\" showLineNumbers{82} {8}\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n\n    camera.fov = 45;\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.position.set(1, 1, 2);\n\n    camera.lookAt(0, 0, 0);\n\n    camera.updateProjectionMatrix();\n}\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-01-01/2024-01-01-01-03.png\" alt=\"실행 결과\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 카메라 fov 와 position 설정에 따른 왜곡 현상\n\nfov(Field of View) 값이 커질수록 멀리서 보는 느낌으로 렌더링됩니다.\n\n이는 물체가 더 작게 보이는 결과를 볼 수 있습니다.\n\n\u003cbr /\u003e\n\n만약 fov 를 큰 값으로 설정하여 물체가 작게 보이도록 한 후, 카메라의 위치를 물체와 가깝게 설정하면 어떻게 될까요?\n\n이는 카메라의 **왜곡 현상** 에 의해 좀 더 렌즈의 굴곡이 커지게 됩니다.\n\nfov 와 position 의 관계를 표현해 보면 다음과 같습니다.\n\n* fov 작게 설정, position 멀리 설정\n    * 왜곡 현상이 적어집니다.\n* fov 크게 설정, position 가깝게 설정\n    * 왜곡 현상이 커집니다.\n\n\u003cbr /\u003e\n\n실제 왜곡 현상의 차이를 확인하기 위해 두가지 설정을 비교해 보겠습니다.\n\n* 첫번째 설정: **fov 작게, position 멀리** 설정\n* 두번째 설정: **fov 크게, position 가깝게** 설정\n\n```js title=\"fov 작게, position 멀리 설정\" showLineNumbers{82} {5-6}\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.fov = 45;\n    camera.position.set(2, 2, 2);\n\n    camera.lookAt(0, 0, 0);\n\n    camera.updateProjectionMatrix();\n}\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-01-01/2024-01-01-01-04.png\" alt=\"실행 결과\" /\u003e\n\n\u003cbr /\u003e\u003cbr /\u003e\n\n```js title=\"fov 크게, position 가깝게 설정\" showLineNumbers{82} {5-6}\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.fov = 90;\n    camera.position.set(1, 1, 1);\n\n    camera.lookAt(0, 0, 0);\n\n    camera.updateProjectionMatrix();\n}\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-01-01/2024-01-01-01-05.png\" alt=\"실행 결과\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 추가: 마우스를 사용하여 카메라 제어하기\n\nThree.js 는 여러가지 Addons 를 제공합니다.\n\n이 중 **OrbitControls** 객체를 사용하면, 마우스를 사용하여 카메라를 제어하는 기능을 제공할 수 있습니다.\n\n\u003cbr /\u003e\n\nOrbitControls 는 **PerspectiveCamera 의 Addon** 개념으로 사용하게 되며, 카메라의 제어를 담당하게 됩니다.\n\n주의할 점은 PerspectiveCamera 의 `lookAt()` 메소드를 함께 사용하게 되면, 카메라 제어에 충돌이 발생하는 현상입니다.\n\n그러므로 OrbitControls 를 사용하려면, `lookAt()` 메소드는 꼭 제거해 주는 것이 좋습니다.\n\n\u003cbr /\u003e\n\n먼저 OrbitControls 의 생성자를 살펴보면 다음과 같습니다.\n\n```ts\nclass OrbitControls {\n    constructor(\n        object: Camera, \n        domElement?: HTMLElement\n    );\n}\n```\n\n* object: 제어할 카메라 객체\n* domElement: 마우스 이벤트를 발생시킬 HTMLElement\n\n\u003cbr /\u003e\n\nPerspectiveCamera 에 OrbitControls 를 적용하는 `initControls()` 함수를 추가해 보겠습니다.\n\n```js title=\"OrbitControls 로 카메라 제어하기\" showLineNumbers {11-13, 25-26, 37, 45, 103-108}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    Scene,\n    DirectionalLight,\n\n    BoxGeometry,\n    MeshPhongMaterial,\n    Mesh,\n} from 'three';\nimport {\n    OrbitControls,\n} from 'three/examples/jsm/controls/OrbitControls'\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { OrbitControls } */\nlet controls;\n\n(function init() {\n    const $canvas = initCanvas();\n\n    initRenderer($canvas);\n\n    const light = createLight();\n    const boxMesh = createBoxMesh();\n\n    initCamera();\n    initControls($canvas);\n    initScene(light, boxMesh);\n\n    render();\n}());\n\nfunction render() {\n    renderer.render(scene, camera);\n    controls.update();\n\n    window.requestAnimationFrame(render);\n}\n\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\n/**\n * @param { HTMLCanvasElement } $canvas \n */\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.setSize(\n        window.innerWidth,\n        window.innerHeight\n    );\n}\n\nfunction createLight() {\n    const light = new DirectionalLight();\n    light.position.set(1, 2, 3);\n\n    return light;\n}\n\nfunction createBoxMesh() {\n    const boxGeometry = new BoxGeometry();\n    const boxMaterial = new MeshPhongMaterial();\n\n    return new Mesh(boxGeometry, boxMaterial);\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.fov = 45;\n    camera.position.set(2, 2, 2);\n\n    camera.fov = 90;\n    camera.position.set(1, 1, 1);\n\n    camera.lookAt(0, 0, 0);\n\n    camera.updateProjectionMatrix();\n}\n\n/**\n * @param { HTMLElement } $targetElement \n */\nfunction initControls($targetElement) {\n    controls = new OrbitControls(camera, $targetElement);\n}\n\nfunction initScene(...items) {\n    scene = new Scene();\n\n    items.forEach(item =\u003e {\n        scene.add(item);\n    });\n}\n```\n\n\u003cbr /\u003e\n\nOrbitControls 를 카메라에 설치하게 되면 아래와 같은 마우스 인터렉션을 사용할 수 있습니다.\n\n* 마우스 좌클릭 - 드래그\n    * 카메라 주시 좌표를 회전 중심점으로 하여, **드래그 반대 방향으로 카메라를 회전** 시킵니다.\n    * 결과적으로 카메라가 고정된 상태에서 **바라보는 물체가 회전** 하게 됩니다.\n* 마우스 휠\n    * 확대, 축소 동작을 합니다.\n* 마우스 우클릭 - 드래그\n    * **드래그 반대 방향으로 카메라의 위치를 이동** 시킵니다.\n    * 결과적으로 카메라가 고정된 상태에서 **바라보는 물체가 이동** 하게 됩니다.\n\n\u003cbr /\u003e\n\nOrbitControls 객체의 설정을 사용하여, 특정 마우스 인터렉션의 사용 여부를 설정할 수 있습니다.\n\n이 설정 프로퍼티들은 `enable` 을 접두사로 사용하고 있습니다.\n\n* `enableRotate`: `false` 값을 대입하면, 회전기능을 막습니다.\n* `enableZoom`: `false` 값을 대입하면 확대, 축소 기능을 막습니다.\n* `enablePan`: `false` 값을 대입하면 이동 기능을 막습니다.\n\n\u003cbr /\u003e\n\n추가로 `enableDamping` 에 `true` 값을 대입하게 되면, 카메라의 모든 인터렉션에 감속도가 적용되어 **카메라의 부드러운 움직임이 연출** 됩니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\n일전에 HTML Canvas API 를 스터디하면서, 도형에 대한 인터렉션이나 애니메이션을 구현해본 적이 있습니다.\n\n물체의 튕김이나 가속도, 감속도를 구현해 보려는 시도를 했었지만, 제가 구현한 결과물은 너무나 어색했습니다.\n\nThree.js 의 인터렉션은 OrbitControls 하나를 접했을 뿐인데, 부드러운 3D 엔진에 그저 놀라울 뿐입니다.\n\n\u003cbr /\u003e\n\n하지만 실제 구현할 기획에 따라 엔진의 물리 효과를 커스터마이징을 할 수 있어야 자연스러운 결과물이 나올 것 같습니다.\n\nOrbitControls 가 제공하는 효과는 마치 물속의 부력이 작용하는 것처럼 느껴졌습니다.\n\nThree.js 의 기본 사용법과 원리를 이해한 후, 물리 엔진 커스터마이징에 대해서도 도전해 보고 싶어졌습니다.\n"])</script><script>self.__next_f.push([1,"21:T5077,"])</script><script>self.__next_f.push([1,"---\nid: 1\ntitle: Three.js 설치 및 실행\ndescription: 'Three.js 를 사용하기 위한 설치와 첫번째 화면을 그려봅니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    'javascript',\n    '3d',\n]\n\ncreatedAt: '2023-12-31 22:47:00'\nmodifiedHistories: []\n---\n\n# Three.js 설치 및 실행\n\n일반적인 웹페이지는 2D 기반으로 구현합니다.\n\n이러한 웹페이지는 서비스를 제공하거나 정보 공유를 목적으로 충분합니다.\n\n만약 이렇게 보편적으로 사용하는 2D 웹페이지에 3D 환경을 더한다면, 서비스나 제품의 브렌딩에 차별점을 줄 수 있을 것 같습니다.\n\n\u003cbr /\u003e\n\nThree.js 를 스터디하며, 이 블로그의 Profile 페이지를 구현하는 것을 첫번째 목표로 하여 포스팅을 해보려 합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## Vite 프로젝트 생성하기\n\nThree.js 를 사용하기 위해, VanillaJS 환경의 프로젝트를 생성해 보겠습니다.\n\nWebpack 을 사용하여 프로젝트를 만들어도 되지만, 프로젝트 구성에 투자되는 리소스가 많아지므로, Vite 를 사용하여 프로젝트를 생성해보겠습니다.\n\n```bash title=\"Vite 프로젝트 생성\"\nyarn create vite --template vanilla my-threejs\n\ncd my-threejs\n\nyarn install\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## Three.js 설치하기\n\n프로젝트를 생성한 후, Three.js 를 설치합니다.\n\n```bash title=\"Three.js 설치\"\nyarn install three\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## Three.js 기본 구조 구성하기\n\nThree.js 는 **WebGL** 을 기반으로 동작합니다.\n\n이는 **HTML Canvas API** 를 사용하여 그리는 방식입니다.\n\nThree.js 로 화면을 그리기 위한 기본 과정을 살펴보면 다음과 같습니다.\n\n1. `\u003ccanvas /\u003e` 태그 생성\n2. **WebGLRenderer** 객체 생성\n3. 카메라 생성\n4. 조명 생성\n5. **Scene** 객체 생성\n6. 위에서 생성한 객체들을 조합하여 **WebGLRenderer** 에 적용\n7. `requestAnimationFrame()` 을 사용하여 `\u003ccanvas /\u003e` 렌더링\n\n\u003cbr /\u003e\n\n위 과정은 아래와 같이 함수를 생성하여 구현해 보겠습니다.\n\n1. `init()` 함수 만들기: 1번 ~ 6번 과정을 처리합니다.\n2. `render()` 함수 만들기: 7번 과정을 처리합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 1. `\u003ccanvas /\u003e` 태그 생성\n\n먼저 Three.js 를 렌더링할 `\u003ccanvas /\u003e` 태그를 생성하는 로직을 구현해 보겠습니다.\n\n```js title=\"main.js\" showLineNumber\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n}\n\ninit();\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 2. **WebGLRenderer** 객체 생성\n\n**WebGLRenderer** 객체는 Three.js 의 코어 역할을 합니다.\n\n위에서 생성한 `\u003ccanvas /\u003e` 를 인자로 넘겨주어 렌더링 대상을 지정해 줍니다.\n\n```js title=\"main.js\" showLineNumbers {2, 5-6, 15-18}\nimport {\n    WebGLRenderer,\n} from 'three';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    // 2. WebGLRenderer 객체 생성\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n    });\n}\n\ninit();\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 3. 카메라 생성\n\nThree.js 가 실제로 화면에 렌더링하는 것은 `Camera` 가 비추는 곳이 됩니다.\n\n따라서 Three.js 에 사용할 카메라 객체를 생성해 줍니다.\n\n```js title=\"main.js\" showLineNumbers {3, 9-10, 24-25}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n} from 'three';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    // 2. `WebGLRenderer` 객체 생성\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n    });\n\n    // 3. 카메라 생성\n    camera = new PerspectiveCamera();\n}\n\ninit();\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 4. 조명 생성\n\n이번에는 조명 객체인 **DirectionalLight** 객체를 생성해 보겠습니다.\n\n현실 세계에서도 빛이 있어야 물체를 볼 수 있듯이, Three.js 에서도 조명이 있어야 물체가 렌더링 됩니다.\n\n조명은 여러가지가 있는데, 이 중 햇빛처럼 직선의 일정한 양의 빛을 나타내는 **DirectionalLight** 객체를 사용해 보겠습니다.\n\n```js title=\"main.js\" showLineNumbers {4, 28-29}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    DirectionalLight,\n} from 'three';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    // 2. `WebGLRenderer` 객체 생성\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n    });\n\n    // 3. 카메라 생성\n    camera = new PerspectiveCamera();\n\n    // 4. 조명 생성\n    const light = new DirectionalLight();\n}\n\ninit();\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 5. **Scene** 객체 생성\n\n무대는 `Scene` 객체로 만들 수 있습니다.\n\n`Scene` 객체는 `add()` 메서드를 사용하여 위에서 만들었던 조명과 물체(Mesh)들을 적용할 수 있습니다.\n\n\u003cbr /\u003e\n\n`Scene` 객체를 생성하고 조명을 적용해 보겠습니다.\n\n```js title=\"main.js\" showLineNumbers {5, 14-15, 35-37}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    DirectionalLight,\n    Scene,\n} from 'three';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { Scene } */\nlet scene;\n\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    // 2. `WebGLRenderer` 객체 생성\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n    });\n\n    // 3. 카메라 생성\n    camera = new PerspectiveCamera();\n\n    // 4. 조명 생성\n    const light = new DirectionalLight();\n\n    // 5. `Scene` 객체 생성\n    scene = new Scene();\n    scene.add(light);\n}\n\ninit();\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용\n\n이제 Three.js 를 실행하여 화면을 그릴 준비가 되었습니다.\n\n**WebGLRenderer** 는 **Scene(무대)** 와 **카메라** 를 사용하여 화면을 그리는 역할을 하게 됩니다.\n\n```js title=\"main.js\" showLineNumbers {39-40}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    DirectionalLight,\n    Scene,\n} from 'three';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { Scene } */\nlet scene;\n\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    // 2. `WebGLRenderer` 객체 생성\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n    });\n\n    // 3. 카메라 생성\n    camera = new PerspectiveCamera();\n\n    // 4. 조명 생성\n    const light = new DirectionalLight();\n\n    // 5. `Scene` 객체 생성\n    scene = new Scene();\n    scene.add(light);\n\n    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용\n    renderer.render(scene, camera);\n}\n\ninit();\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 7. `requestAnimationFrame()` 을 사용하여 `\u003ccanvas /\u003e` 렌더링\n\n이번에는 `init()` 의 마지막에 호출할 `render()` 함수를 만들고, Three.js 를 실행하여 브라우저에서 결과를 확인해 보겠습니다.\n\n추가할 `render()` 함수는 `requestAnimationFrame()` 을 사용하여 `render()` 함수를 재귀 호출하도록 하는데, 이는 브라우저에서 **60fps 로 실행하며 화면을 업데이트** 하게 됩니다.\n\n```js title=\"main.js\" showLineNumbers {42-43, 46-50}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    DirectionalLight,\n    Scene,\n} from 'three';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { Scene } */\nlet scene;\n\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    // 2. `WebGLRenderer` 객체 생성\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n    });\n\n    // 3. 카메라 생성\n    camera = new PerspectiveCamera();\n\n    // 4. 조명 생성\n    const light = new DirectionalLight();\n\n    // 5. `Scene` 객체 생성\n    scene = new Scene();\n    scene.add(light);\n\n    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용\n    renderer.render(scene, camera);\n\n    // 7. requestAnimationFrame() 을 사용하여 \u003ccanvas /\u003e 렌더링\n    render();\n}\n\nfunction render() {\n    renderer.render(scene, camera);\n\n    requestAnimationFrame(render);\n}\n\ninit();\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 추가: Scene 에 SphereMesh 추가하기\n\n지금까지 작성한 코드를 실행하면, 검은색 화면만 보이게 됩니다.\n\n이는 실제로 화면에 그릴 물체(Mesh) 가 없기 때문에 그릴 대상이 없는 현상입니다.\n\n\u003cbr /\u003e\n\n위에서 구성한 Three.js 가 잘 동작하는지 테스트를 위해 구형 물체(Sphere Mesh) 를 생성하고, 적용해 보겠습니다.\n\n```js title=\"main.js\" showLineNumbers {7-9, 48-49, 61-67}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    DirectionalLight,\n    Scene,\n\n    SphereGeometry,\n    MeshPhongMaterial,\n    Mesh,\n} from 'three';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { Scene } */\nlet scene;\n\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    // 2. `WebGLRenderer` 객체 생성\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n    });\n\n    // 3. 카메라 생성\n    camera = new PerspectiveCamera();\n    camera.position.set(0, 0, 10);\n\n    // 4. 조명 생성\n    const light = new DirectionalLight();\n    light.position.set(1, 1, 1);\n\n    // 5. `Scene` 객체 생성\n    scene = new Scene();\n    scene.add(light);\n\n    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용\n    renderer.render(scene, camera);\n\n    // 추가: Schene 에 SphereMesh 추가하기\n    createSphereMesh();\n\n    // 7. requestAnimationFrame() 을 사용하여 \u003ccanvas /\u003e 렌더링\n    render();\n}\n\nfunction render() {\n    renderer.render(scene, camera);\n\n    requestAnimationFrame(render);\n}\n\nfunction createSphereMesh() {\n    const sphere_geometry = new SphereGeometry();\n    const sphere_material = new MeshPhongMaterial();\n    const sphere_mesh = new Mesh(sphere_geometry, sphere_material);\n\n    scene.add(sphere_mesh);\n}\n\ninit();\n```\n\n\u003cbr /\u003e\n\n`createSphereMesh()` 함수에서 3가지 객체를 생성하고 있습니다.\n\n이는 컴퓨터 그래픽스에서 3D 물체를 표현하기 위한 요소들 입니다.\n\n* Geometry: 색이 없는 모델링 객체\n* Material: 모델링 객체의 색상 또는 질감\n* Mesh: Geometry 와 Material 을 합친 결과 모델링 객체\n\n`sphere_mesh` 객체의 `add()` 메소드를 사용하여 **Geometry** 와 **Material** 을 합쳐서 하나의 **Mesh** 를 만들 수 있게 됩니다.\n\n\u003cbr /\u003e\n\n지금까지 작성한 코드를 실행하면 다음과 같은 결과물을 볼 수 있습니다.\n\n\u003cimg src=\"/markdownAssets/threejs/2023-12-31-01/2023-12-31-01-01.png\" alt=\"Threejs 실행 결과\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 추가: `\u003ccanvas /\u003e` 를 전체화면으로 설정하기\n\n위 결과물을 확인하면, `\u003ccanvas /\u003e` 요소가 inline 으로 렌더링되고 있습니다.\n\n이는 **WebGLRenderer** 객체의 **size** 를 조정하여 전체화면으로 설정할 수 있습니다.\n\n그리고 `\u003ccanvas /\u003e` 의 기본 스타일인 `display: inline` 을 `display: block` 으로 변경합니다.\n\n```css title=\"style.css\" showLineNumbers\n* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\ncanvas {\n    display: block;\n}\n```\n\n```js title=\"main.js\" showLineNumbers {11, 33-36}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    DirectionalLight,\n    Scene,\n\n    SphereGeometry,\n    MeshPhongMaterial,\n    Mesh,\n} from 'three';\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { Scene } */\nlet scene;\n\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    // 2. `WebGLRenderer` 객체 생성\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n    });\n    renderer.setSize(\n        window.innerWidth,\n        window.innerHeight\n    );\n\n    // 3. 카메라 생성\n    camera = new PerspectiveCamera();\n    camera.position.set(0, 0, 10);\n\n    // 4. 조명 생성\n    const light = new DirectionalLight();\n    light.position.set(1, 1, 1);\n\n    // 5. `Scene` 객체 생성\n    scene = new Scene();\n    scene.add(light);\n\n    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용\n    renderer.render(scene, camera);\n\n    // 추가: Schene 에 SphereMesh 추가하기\n    createSphereMesh();\n\n    // 7. requestAnimationFrame() 을 사용하여 \u003ccanvas /\u003e 렌더링\n    render();\n}\n\nfunction render() {\n    renderer.render(scene, camera);\n\n    requestAnimationFrame(render);\n}\n\nfunction createSphereMesh() {\n    const sphere_geometry = new SphereGeometry();\n    const sphere_material = new MeshPhongMaterial();\n    const sphere_mesh = new Mesh(sphere_geometry, sphere_material);\n\n    scene.add(sphere_mesh);\n}\n\ninit();\n```\n\n\u003cbr /\u003e\n\n이렇게 적용한 결과는 다음과 같습니다.\n\n\u003cimg src=\"/markdownAssets/threejs/2023-12-31-01/2023-12-31-01-02.png\" alt=\"전체화면 적용\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 추가: 찌그러진 화면 보정하기\n\nScene 에 추가한 모델링은 구(Sphere) 입니다.\n\n하지만 결과 화면에서 보여지는 구는 타원형으로 보여집니다.\n\n원인은 아래와 같습니다. \n\n* **카메라의 종횡비(aspect radio)** 설정을 하지 않았으므로, 기본값인 **1** 로 설정됨\n* 브라우저의 종횡비가 1:1 이 아닌 상태에서 `\u003ccanvas /\u003e` 를 전체화면으로 늘리면서 발생하는 화면 늘어짐\n\n\u003cbr /\u003e\n\n이를 해결하기 위해 **카메라의 종횡비(aspect radio)** 를 설정해줍니다.\n\n```js title=\"main.js\" showLineNumbers {39-42}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    DirectionalLight,\n    Scene,\n\n    SphereGeometry,\n    MeshPhongMaterial,\n    Mesh,\n} from 'three';\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { Scene } */\nlet scene;\n\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    // 2. `WebGLRenderer` 객체 생성\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n    });\n    renderer.setSize(\n        window.innerWidth,\n        window.innerHeight\n    );\n\n    // 3. 카메라 생성\n    camera = new PerspectiveCamera(\n        45,\n        window.innerWidth / window.innerHeight\n    );\n    camera.position.set(0, 0, 10);\n\n    // 4. 조명 생성\n    const light = new DirectionalLight();\n    light.position.set(1, 1, 1);\n\n    // 5. `Scene` 객체 생성\n    scene = new Scene();\n    scene.add(light);\n\n    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용\n    renderer.render(scene, camera);\n\n    // 추가: Schene 에 SphereMesh 추가하기\n    createSphereMesh();\n\n    // 7. requestAnimationFrame() 을 사용하여 \u003ccanvas /\u003e 렌더링\n    render();\n}\n\nfunction render() {\n    renderer.render(scene, camera);\n\n    requestAnimationFrame(render);\n}\n\nfunction createSphereMesh() {\n    const sphere_geometry = new SphereGeometry();\n    const sphere_material = new MeshPhongMaterial();\n    const sphere_mesh = new Mesh(sphere_geometry, sphere_material);\n\n    scene.add(sphere_mesh);\n}\n\ninit();\n```\n\n\u003cbr /\u003e\n\n`PerspectiveCamera` 생성자에 인자로 2가지를 넘겨주었습니다.\n\n인자 타입은 다음과 같습니다.\n\n```ts title=\"Perspective 생성자의 인자\"\nclass PerspectiveCamera {\n    constructor(\n        fov: number,\n        aspect: number\n    ) {\n        // ...\n    }\n}\n```\n\n**fov (Field of View)** 는 **카메라의 왜곡 정도값**을 말합니다.\n\n이는 **렌즈 배율** 과 **Sensor-size** 에 대한 연산값이며, **화각을 수치화** 한 것입니다.\n\n값이 클수록 멀리서 보는 느낌의 효과가 발생합니다.\n\n\u003cbr /\u003e\n\n두번째 인자인 **aspect** 는 **카메라 종횡비(aspect ratio)** 에 대한 설정입니다.\n\n화면의 **가로 / 세로** 비율을 나타내므로, `window.innerWidth / window.innerHeight` 로 값을 도출할 수 있습니다.\n\n\u003cbr /\u003e\n\n이렇게 설정한 결과물은 아래와 같습니다.\n\n\u003cimg src=\"/markdownAssets/threejs/2023-12-31-01/2023-12-31-01-03.png\" alt=\"전체화면 적용\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 추가: **계단 효과** 보정하기\n\n모니터는 Pixel 에 RGB 를 발사하여 화면을 그립니다.\n\n이 Pixel 은 정사각형 모양이기 때문에 곡선을 렌더링하게 되면 마치 계단처럼 각진 곡선으로 표현됩니다.\n\n**WebGLRenderer** 객체를 생성하며 options 를 통해 계단 효과를 보정할 수 있습니다.\n\n\u003cbr /\u003e\n\n컴퓨터 그래픽스에서 계단 효과를 해소하는 기법을 간단하게 설명하면, 곡선이 아닌 부분을 흐림(blur) 처리하여 마치 자연스러운 곡선처럼 표현해 줍니다.\n\n이러한 기법을 **Anti-Aliasing** 이라고 합니다.\n\n```js title=\"main.js\" showLineNumbers {32}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    DirectionalLight,\n    Scene,\n\n    SphereGeometry,\n    MeshPhongMaterial,\n    Mesh,\n} from 'three';\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { Scene } */\nlet scene;\n\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    // 2. `WebGLRenderer` 객체 생성\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n    renderer.setSize(\n        window.innerWidth,\n        window.innerHeight\n    );\n\n    // 3. 카메라 생성\n    camera = new PerspectiveCamera(\n        45,\n        window.innerWidth / window.innerHeight\n    );\n    camera.position.set(0, 0, 10);\n\n    // 4. 조명 생성\n    const light = new DirectionalLight();\n    light.position.set(1, 1, 1);\n\n    // 5. `Scene` 객체 생성\n    scene = new Scene();\n    scene.add(light);\n\n    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용\n    renderer.render(scene, camera);\n\n    // 추가: Schene 에 SphereMesh 추가하기\n    createSphereMesh();\n\n    // 7. requestAnimationFrame() 을 사용하여 \u003ccanvas /\u003e 렌더링\n    render();\n}\n\nfunction render() {\n    renderer.render(scene, camera);\n\n    requestAnimationFrame(render);\n}\n\nfunction createSphereMesh() {\n    const sphere_geometry = new SphereGeometry();\n    const sphere_material = new MeshPhongMaterial();\n    const sphere_mesh = new Mesh(sphere_geometry, sphere_material);\n\n    scene.add(sphere_mesh);\n}\n\ninit();\n```\n\n\n\n## 마치며\n\nThree.js 를 실행하기 위한 최소 구성요소를 구현해 보았습니다.\n\n뭔가 복잡해 보이지만 현실 세계의 무대를 만드는 것과 유사한 개념으로 만들고 있습니다.\n\n* `WebGLRenderer`: 무대를 구성할 건물\n* `Scene`: 무대\n* `PerspectiveCamera`: 카메라\n* `DirectionalLight`: 조명\n* `Mesh`: 배경, 배우, 소품\n\n\u003cbr /\u003e\n\nThree.js 를 처음 시작하며 제가 느낀 어려움으로는 컴퓨터 그래픽스 개념과 카메라에 대한 이해였습니다.\n\n단순히 Three.js 사용법을 익히는 것만으로 원하는 결과물을 얻기는 어려워 보입니다.\n\n지금까지의 코딩에 비해 학습 난이도는 높지만, 새로운 성취감과 즐거움이 기대됩니다.\n"])</script><script>self.__next_f.push([1,"f:[\"$\",\"$L10\",null,{\"featuredMarkdownFileDataList\":[{\"category\":\"threejs\",\"slug\":\"2024-01-28-01\",\"href\":\"/blog/threejs/2024-01-28-01\",\"frontmatter\":{\"id\":10,\"title\":\"Gamma, GammFactor, sRGB 정리\",\"description\":\"디지털 환경에서 색상을 표현하는데 사용되는 일부 개념들을 정리합니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":true,\"tags\":[\"threejs\",\"gamma\",\"gamma factor\",\"sRGB\"],\"createdAt\":\"$D2024-01-28T18:00:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$11\"}],\"commonMarkdownFileDataList\":[{\"category\":\"threejs\",\"slug\":\"2024-02-29-01\",\"href\":\"/blog/threejs/2024-02-29-01\",\"frontmatter\":{\"id\":16,\"title\":\"Particle 로 반딧불이 표현하기\",\"description\":\"3D 환경에서 반딧불이나 별을 표현할 때 Particle 을 활용합니다. 매우 많은 입자들로 표현하는 Particle 을 어떻게 구현하는지 정리하고자 합니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"3D\",\"Particle\",\"BufferGeometry\",\"PointsMaterial\",\"Points\"],\"createdAt\":\"$D2024-02-29T20:00:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$12\"},{\"category\":\"threejs\",\"slug\":\"2024-02-12-01\",\"href\":\"/blog/threejs/2024-02-12-01\",\"frontmatter\":{\"id\":15,\"title\":\"Material 의 map, bumpMap, normalMap\",\"description\":\"Material 의 표현 방식과 울퉁불퉁한 재질을 처리하는 방식을 정리합니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"3D\",\"Material\",\"Texture\",\"map\",\"bumpMap\",\"normalMap\"],\"createdAt\":\"$D2024-02-12T15:17:30.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$13\"},{\"category\":\"threejs\",\"slug\":\"2024-02-06-01\",\"href\":\"/blog/threejs/2024-02-06-01\",\"frontmatter\":{\"id\":14,\"title\":\"click 이벤트에 animation 연동하기\",\"description\":\"특정 버튼을 click 했을 때 animation 을 실행하는 방법을 정리합니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"3D\",\"mouse event\",\"click interaction\",\"animation\",\"AnimationMixer\",\"AnimationClip\",\"AnimationAction\"],\"createdAt\":\"$D2024-02-06T15:00:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$14\"},{\"category\":\"threejs\",\"slug\":\"2024-02-03-02\",\"href\":\"/blog/threejs/2024-02-03-02\",\"frontmatter\":{\"id\":13,\"title\":\"Model 에 Click Event 적용하기 (추가: ToneMapping, light.shadow.camera)\",\"description\":\"Canvas 에 렌더링된 Model 에 Click 인터렉션을 적용 해봅니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"3D\",\"mouse event\",\"click interaction\"],\"createdAt\":\"$D2024-02-03T16:00:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$15\"},{\"category\":\"threejs\",\"slug\":\"2024-02-03-01\",\"href\":\"/blog/threejs/2024-02-03-01\",\"frontmatter\":{\"id\":13,\"title\":\"(Issue) 조명이 어둡게 보이는 현상\",\"description\":\"강좌의 결과물에 비해 실습 결과물의 밝기가 어둡게 렌더링되는 현상이 발생하였습니다. 현상 원인과 해결 방법에 대해 정리하고자 합니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"3D\",\"DirectionalLgith\",\"HemisphereLight\",\"intensity\"],\"createdAt\":\"$D2024-02-03T14:00:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$16\"},{\"category\":\"threejs\",\"slug\":\"2024-01-30-01\",\"href\":\"/blog/threejs/2024-01-30-01\",\"frontmatter\":{\"id\":12,\"title\":\"키보드를 사용하여 카메라 이동 인터렉션 만들기\",\"description\":\"키보드 입력에 대한 event listener 를 사용하여 카메라를 이동할 수 있는 인터렉션을 구현해 봅니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"3D\",\"keyboard event\",\"camera\",\"interaction\"],\"createdAt\":\"$D2024-01-30T18:00:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$17\"},{\"category\":\"threejs\",\"slug\":\"2024-01-28-02\",\"href\":\"/blog/threejs/2024-01-28-02\",\"frontmatter\":{\"id\":11,\"title\":\"canvas 크기 설정 및 material 렌더링 side 설정\",\"description\":\"사용자 모니터 대응을 위한 WebGLRenderer 설정과 material 의 렌더링 side 설정에 대해 정리합니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"setSize()\",\"setPixelRatio()\",\"material\",\"FrontSide\",\"BackSide\",\"DoubleSide\"],\"createdAt\":\"$D2024-01-28T23:00:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$18\"},{\"category\":\"threejs\",\"slug\":\"2024-01-26-01\",\"href\":\"/blog/threejs/2024-01-26-01\",\"frontmatter\":{\"id\":9,\"title\":\"Model 에 Animation 효과 적용하기\",\"description\":\"Model 파일인 .gltf, .glb 에 Animation 을 적용하는 방법에 대해 정리합니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"javascript\",\"3d\",\".gltf\",\".glb\",\"model\",\"animation\"],\"createdAt\":\"$D2024-01-26T20:00:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$19\"},{\"category\":\"threejs\",\"slug\":\"2024-01-21-01\",\"href\":\"/blog/threejs/2024-01-21-01\",\"frontmatter\":{\"id\":8,\"title\":\"Model (.gltf, .glb) 객체 구조파악 및 그림자 적용\",\"description\":\"Three.js 환경에 불러온 Model 객체의 주요 구성요소를 파악하고, 속성값을 변경하여 그림자를 만들어 봅니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"javascript\",\"3d\",\".gltf\",\".glb\",\"model\",\"traverse\",\"shadow\"],\"createdAt\":\"$D2024-01-21T16:00:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$1a\"},{\"category\":\"threejs\",\"slug\":\"2024-01-10-01\",\"href\":\"/blog/threejs/2024-01-10-01\",\"frontmatter\":{\"id\":7,\"title\":\"모델 파일을 Three.js 에 렌더링하기\",\"description\":\".gltf 또는 .glb 확장자인 모델 파일을 Three.js 에 불러오고 렌더링하는 방법을 정리합니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"javascript\",\"3d\",\"hdr\",\".gltf\",\".glb\",\"model\"],\"createdAt\":\"$D2024-01-10T23:50:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$1b\"},{\"category\":\"threejs\",\"slug\":\"2024-01-08-01\",\"href\":\"/blog/threejs/2024-01-08-01\",\"frontmatter\":{\"id\":6,\"title\":\"배경화면 및 환경조명 설정하기\",\"description\":\"360도 이미지 확장자인 .hdr 파일을 사용하여 배경화면을 설정하고, 배경화면에 의한 환경조명 설정에 대한 정리입니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"javascript\",\"3d\",\"hdr\",\"background\",\"3D 배경화면\",\"환경조명\"],\"createdAt\":\"$D2024-01-08T23:50:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$1c\"},{\"category\":\"threejs\",\"slug\":\"2024-01-07-02\",\"href\":\"/blog/threejs/2024-01-07-02\",\"frontmatter\":{\"id\":5,\"title\":\"그림자 표현하기\",\"description\":\"그림자 설정방법과 특징에 대해 정리합니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"javascript\",\"3d\",\"shadow\"],\"createdAt\":\"$D2024-01-07T23:50:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$1d\"},{\"category\":\"threejs\",\"slug\":\"2024-01-07-01\",\"href\":\"/blog/threejs/2024-01-07-01\",\"frontmatter\":{\"id\":4,\"title\":\"평평한 바닥(땅) 만들기 (Plane Mesh)\",\"description\":\"바닥을 표현하기 위해 Plane Mesh 를 생성합니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"javascript\",\"3d\",\"plane\"],\"createdAt\":\"$D2024-01-07T23:20:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$1e\"},{\"category\":\"threejs\",\"slug\":\"2024-01-06-01\",\"href\":\"/blog/threejs/2024-01-06-01\",\"frontmatter\":{\"id\":3,\"title\":\"조명 종류와 설정\",\"description\":\"조명 종류와 설정 방법에 대해 정리합니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"javascript\",\"3d\",\"light\"],\"createdAt\":\"$D2024-01-06T23:00:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$1f\"},{\"category\":\"threejs\",\"slug\":\"2024-01-01-01\",\"href\":\"/blog/threejs/2024-01-01-01\",\"frontmatter\":{\"id\":2,\"title\":\"카메라 설정 (PerspectiveCamera)\",\"description\":\"Three.js 의 카메라인 PerspectiveCamera 설정에 대한 포스팅입니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"javascript\",\"3d\",\"camera\"],\"createdAt\":\"$D2024-01-01T23:50:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$20\"},{\"category\":\"threejs\",\"slug\":\"2023-12-31-01\",\"href\":\"/blog/threejs/2023-12-31-01\",\"frontmatter\":{\"id\":1,\"title\":\"Three.js 설치 및 실행\",\"description\":\"Three.js 를 사용하기 위한 설치와 첫번째 화면을 그려봅니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"javascript\",\"3d\"],\"createdAt\":\"$D2023-12-31T22:47:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$21\"}]}]\n"])</script><script>self.__next_f.push([1,""])</script></body></html><style data-styled="" data-styled-version="6.1.0"></style>