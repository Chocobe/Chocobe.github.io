<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/0c7e3e2387401c47-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" as="image" href="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg" fetchPriority="high"/><link rel="stylesheet" href="/_next/static/css/6566b64e7f0e478f.css" crossorigin="" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-14bcfdf71a1473f7.js" crossorigin=""/><script src="/_next/static/chunks/fd9d1056-9fe3c6d0c60c86d8.js" async="" crossorigin=""></script><script src="/_next/static/chunks/472-cf3134408a61a609.js" async="" crossorigin=""></script><script src="/_next/static/chunks/main-app-b1972c4cdd2be6d3.js" async="" crossorigin=""></script><script src="/_next/static/chunks/576-dc377cf448834f03.js" async=""></script><script src="/_next/static/chunks/251-ef7560cc4f7a9f6d.js" async=""></script><script src="/_next/static/chunks/app/layout-5bdea2f994faa404.js" async=""></script><script src="/_next/static/chunks/08ffe114-a8e3ed06beefbf38.js" async=""></script><script src="/_next/static/chunks/48507feb-6de01ca04009bb96.js" async=""></script><script src="/_next/static/chunks/39209d7c-a33d4549f726b4ab.js" async=""></script><script src="/_next/static/chunks/128-a9a4b8134fdbdc1d.js" async=""></script><script src="/_next/static/chunks/app/page-2a9b84f80b166504.js" async=""></script><title>Chocobe Blog v2</title><meta name="description" content="Frontend 기술 블로그 입니다."/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" crossorigin="" noModule=""></script><style data-styled="" data-styled-version="6.1.0">*{margin:0;padding:0;box-sizing:border-box;font-family:"Pretendard Variable",sans-serif;}/*!sc*/
body{width:100vw;height:100vh;overflow:hidden;}/*!sc*/
data-styled.g1[id="sc-global-eqoFij1"]{content:"sc-global-eqoFij1,"}/*!sc*/
.bogipj{display:flex;flex-wrap:wrap;gap:20px;}/*!sc*/
.bogipj >.navItem{padding:0 8px;color:#222;font-size:16px;line-height:24px;font-weight:500;}/*!sc*/
data-styled.g2[id="sc-4612defa-0"]{content:"bogipj,"}/*!sc*/
.fiXfoi{position:sticky;top:0;z-index:1;background-color:#E8F3F3;}/*!sc*/
.fiXfoi >.innerWrapper{margin:0 auto;padding:24px 20px 20px;width:100%;max-width:1200px;display:grid;grid-template-columns:repeat(3, 1fr);}/*!sc*/
.fiXfoi >.innerWrapper >.logoLink{display:flex;justify-content:center;align-items:flex-end;gap:4px;}/*!sc*/
.fiXfoi >.innerWrapper >.logoLink >.chocobe{padding:8px 4px 0;color:#fff;font-size:28px;line-height:20px;font-weight:600;background-color:#00AAA1;}/*!sc*/
.fiXfoi >.innerWrapper >.logoLink >.fe-blog{position:relative;color:#222;font-size:16px;line-height:16px;font-weight:600;}/*!sc*/
.fiXfoi >.innerWrapper >.logoLink >.fe-blog::before{content:'';width:4px;height:4px;display:block;position:absolute;bottom:2px;right:-6px;border-radius:50%;background-color:#00AAA1;}/*!sc*/
.fiXfoi >.innerWrapper >.headerActionsWrapper{display:flex;justify-content:flex-end;}/*!sc*/
data-styled.g3[id="sc-2b4c7cfd-0"]{content:"fiXfoi,"}/*!sc*/
.gWzijn{height:0;min-height:100%;}/*!sc*/
data-styled.g4[id="sc-6cb25f84-0"]{content:"gWzijn,"}/*!sc*/
.gwGyTj{display:flex;border-radius:8px;box-shadow:1px 3px 6px 0 rgba(0, 0, 0, 0.2);overflow:hidden;transition:all 0.18s ease;}/*!sc*/
.gwGyTj >.thumbnailWrapper{flex-shrink:0;width:40%;height:auto;position:relative;}/*!sc*/
.gwGyTj >.thumbnailWrapper >.thumbnail{object-fit:cover;object-position:center;}/*!sc*/
.gwGyTj >.cardBody{flex:1;padding:20px 16px;width:100%;position:relative;color:#fff;}/*!sc*/
.gwGyTj >.cardBody >.hoverDecorator{width:50%;height:32px;position:absolute;top:0;right:0;transform:translate(100%, -100%);transition:all 0.18s ease-in-out;background-color:#fdd835;pointer-events:none;}/*!sc*/
.gwGyTj >.cardBody >.hoverDecorator::after{content:'';width:50%;height:50px;display:block;position:absolute;top:8px;right:8px;transform:translate(100%, 100%);transition:all 0.18s ease-in-out;transition-delay:0.09s;background-color:#009189;}/*!sc*/
.gwGyTj >.cardBody >.category{color:#592EA9;font-size:16px;line-height:24px;font-weight:600;}/*!sc*/
.gwGyTj >.cardBody >.title{margin-top:20px;color:#232536;font-size:24px;line-height:30px;font-weight:700;}/*!sc*/
.gwGyTj >.cardBody >.date{margin-top:16px;color:#4C4C4C;font-size:14px;line-height:22px;font-weight:500;}/*!sc*/
.gwGyTj >.cardBody >.description{margin-top:16px;color:#6D6E76;font-size:16px;line-height:24px;font-weight:400;white-space:pre-line;display:-webkit-box;overflow:hidden;-webkit-box-orient:vertical;-webkit-line-clamp:2;}/*!sc*/
.gwGyTj >.cardBody >.readMoreLink{margin-top:32px;padding:16px 48px;display:none;color:#fff;font-size:18px;line-height:28px;font-weight:700;background-color:#009189;}/*!sc*/
.gwGyTj:not([data-variant=featured]):hover{box-shadow:3px 6px 12px 0 rgba(0, 0, 0, 0.5);cursor:pointer;}/*!sc*/
.gwGyTj:not([data-variant=featured]):hover >.cardBody >.hoverDecorator{transform:translate(0, 0);}/*!sc*/
.gwGyTj:not([data-variant=featured]):hover >.cardBody >.hoverDecorator::after{transform:translate(0, 0);}/*!sc*/
.gwGyTj[data-variant=featured]{flex-flow:row-reverse;border-radius:0;box-shadow:none;}/*!sc*/
.gwGyTj[data-variant=featured] >.thumbnailWrapper{border-radius:8px;overflow:hidden;}/*!sc*/
.gwGyTj[data-variant=featured] >.cardBody >.hoverDecorator{display:none;}/*!sc*/
.gwGyTj[data-variant=featured] >.cardBody >.title{font-size:36px;line-height:40px;}/*!sc*/
.gwGyTj[data-variant=featured] >.cardBody >.description{display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:2;overflow:hidden;white-space:pre-line;}/*!sc*/
.gwGyTj[data-variant=featured] >.cardBody >.readMoreLink{display:inline-block;}/*!sc*/
.gwGyTj[data-variant=featured]:hover{box-shadow:none;}/*!sc*/
data-styled.g7[id="sc-ae8c9e8b-0"]{content:"gwGyTj,"}/*!sc*/
.hoTFrx{width:100%;position:relative;border:1px solid #D9D9D9;overflow:hidden;}/*!sc*/
.hoTFrx >.decoratorYellow{width:45%;height:35%;position:absolute;top:0;right:0;transform:translate(100%, -100%);transition:all 0.18s ease-in-out;transition-delay:0.09s;background-color:#fff;}/*!sc*/
.hoTFrx >.decoratorGreen{width:100%;height:100%;position:absolute;top:0;left:0;transform:translate(-100%, 100%);transition:all 0.18s ease-in-out;background-color:#fff;}/*!sc*/
.hoTFrx >.content{padding:16px;width:100%;height:100%;position:sticky;top:0;left:0;}/*!sc*/
.hoTFrx >.content >.iconWrapper{padding:12px;width:fit-content;height:fit-content;color:#232536;border-radius:8px;background-color:#FBF6EA;transition:all 0.18s ease-in-out;}/*!sc*/
.hoTFrx >.content >.category{margin-top:16px;color:#232536;font-size:24px;line-height:36px;font-weight:700;transition:all 0.18s ease-in-out;}/*!sc*/
.hoTFrx >.content >.description{margin-top:8px;color:#6D6E76;font-size:16px;line-height:24px;font-weight:400;}/*!sc*/
.hoTFrx:hover{border-color:transparent;}/*!sc*/
.hoTFrx:hover >.decoratorYellow{background-color:#FFD050;transform:translate(0, 0);}/*!sc*/
.hoTFrx:hover >.decoratorGreen{background-color:#009189;transform:translate(-8px, 8px);}/*!sc*/
.hoTFrx:hover >.content >.iconWrapper{color:#009189;background-color:#FBF6EA;}/*!sc*/
.hoTFrx:hover >.content >.category{color:#fff;}/*!sc*/
.hoTFrx:hover >.content >.description{color:#eee;}/*!sc*/
data-styled.g9[id="sc-59513bf2-0"]{content:"hoTFrx,"}/*!sc*/
.kRxxxQ{display:flex;flex-wrap:wrap;gap:20px;}/*!sc*/
.kRxxxQ >.categoryItem{flex:1;min-width:300px;display:inline-block;}/*!sc*/
data-styled.g10[id="sc-1b3db0c2-0"]{content:"kRxxxQ,"}/*!sc*/
.kzwff{padding-bottom:20px;display:flex;flex-direction:column;gap:40px;}/*!sc*/
.kzwff >.featuredSection{padding:40px 0;background-color:#F2F8F7;}/*!sc*/
.kzwff >.featuredSection >.sectionContent{margin-left:auto;margin-right:auto;max-width:980px;}/*!sc*/
.kzwff >.commonSection{margin-left:auto;margin-right:auto;padding:0 40px;width:100%;max-width:calc(980px + (40px * 2));}/*!sc*/
.kzwff >.commonSection >.sectionHeader{display:flex;align-items:flex-start;gap:4px;border-bottom:4px solid #D9D9D9;}/*!sc*/
.kzwff >.commonSection >.sectionHeader >.sectionTitle{color:#232536;font-size:18px;line-height:24px;font-weight:700;}/*!sc*/
.kzwff >.commonSection >.sectionContent{margin-top:8px;}/*!sc*/
data-styled.g11[id="sc-3e8c62b1-0"]{content:"kzwff,"}/*!sc*/
</style></head><body class="__className_7bb6ba"><div class="w-full
            h-full
            overflow-y-scroll
            overflow-x-auto"><header class="sc-2b4c7cfd-0 fiXfoi"><div class="innerWrapper"><nav class="sc-4612defa-0 bogipj"><a class="navItem" href="/profile">Profile</a></nav><a class="logoLink" href="/"><span class="chocobe">Chocobe</span><span class="fe-blog">FE Blog</span></a></div></header><div style="min-height:calc(100% - 72px)" class="sc-6cb25f84-0 gWzijn"><div class="sc-3e8c62b1-0 kzwff"><section class="featuredSection"><div class="sc-ae8c9e8b-0 gwGyTj sectionContent" data-variant="featured"><figure class="thumbnailWrapper"><img alt="&quot;node:fs&quot; 테스트 하기" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">jest</div><div class="title">&quot;node:fs&quot; 테스트 하기</div><div class="date">작성일: </div><div class="description">node 모듈중 File System 기능, "fs" 를 테스트하는 방법에 대해 정리합니다.</div><a class="readMoreLink" href="/blog/jest/2023-12-17-01">Read More</a></div></div></section><section class="commonSection"><div class="sectionHeader"><svg stroke="currentColor" fill="none" stroke-width="2px" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="sectionIcon" height="20px" width="20px" xmlns="http://www.w3.org/2000/svg"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M9 6l11 0"></path><path d="M9 12l11 0"></path><path d="M9 18l11 0"></path><path d="M5 6l0 .01"></path><path d="M5 12l0 .01"></path><path d="M5 18l0 .01"></path></svg><div class="sectionTitle">All Categories</div></div><div class="sc-1b3db0c2-0 kRxxxQ sectionContent"><div role="listitem" class="sc-59513bf2-0 hoTFrx categoryItem"><div class="decoratorYellow"></div><div class="decoratorGreen"></div><div class="content"><div class="iconWrapper"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="20px" width="20px" xmlns="http://www.w3.org/2000/svg"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M20 4l-2 14.5l-6 2l-6 -2l-2 -14.5z"></path><path d="M7.5 8h3v8l-2 -1"></path><path d="M16.5 8h-2.5a.5 .5 0 0 0 -.5 .5v3a.5 .5 0 0 0 .5 .5h1.423a.5 .5 0 0 1 .495 .57l-.418 2.93l-2 .5"></path></svg></div><div class="category">Javascript</div><div class="description">Javascript 에 대한 보강할 부분들을 정리합니다.</div></div></div><div role="listitem" class="sc-59513bf2-0 hoTFrx categoryItem"><div class="decoratorYellow"></div><div class="decoratorGreen"></div><div class="content"><div class="iconWrapper"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="20px" width="20px" xmlns="http://www.w3.org/2000/svg"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M6.306 8.711c-2.602 .723 -4.306 1.926 -4.306 3.289c0 2.21 4.477 4 10 4c.773 0 1.526 -.035 2.248 -.102"></path><path d="M17.692 15.289c2.603 -.722 4.308 -1.926 4.308 -3.289c0 -2.21 -4.477 -4 -10 -4c-.773 0 -1.526 .035 -2.25 .102"></path><path d="M6.305 15.287c-.676 2.615 -.485 4.693 .695 5.373c1.913 1.105 5.703 -1.877 8.464 -6.66c.387 -.67 .733 -1.339 1.036 -2"></path><path d="M17.694 8.716c.677 -2.616 .487 -4.696 -.694 -5.376c-1.913 -1.105 -5.703 1.877 -8.464 6.66c-.387 .67 -.733 1.34 -1.037 2"></path><path d="M12 5.424c-1.925 -1.892 -3.82 -2.766 -5 -2.084c-1.913 1.104 -1.226 5.877 1.536 10.66c.386 .67 .793 1.304 1.212 1.896"></path><path d="M12 18.574c1.926 1.893 3.821 2.768 5 2.086c1.913 -1.104 1.226 -5.877 -1.536 -10.66c-.375 -.65 -.78 -1.283 -1.212 -1.897"></path><path d="M11.5 12.866a1 1 0 1 0 1 -1.732a1 1 0 0 0 -1 1.732z"></path></svg></div><div class="category">React</div><div class="description">React 를 사용하며 마주친 이슈나 생각을 정리하고자 합니다.</div></div></div><div role="listitem" class="sc-59513bf2-0 hoTFrx categoryItem"><div class="decoratorYellow"></div><div class="decoratorGreen"></div><div class="content"><div class="iconWrapper"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="20px" width="20px" xmlns="http://www.w3.org/2000/svg"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M9 15v-6l7.745 10.65a9 9 0 1 1 2.255 -1.993"></path><path d="M15 12v-3"></path></svg></div><div class="category">Nextjs</div><div class="description">SSR 과 CSR 을 자유롭게 사용할 수 있는 Nextjs 에 대한 정리입니다.</div></div></div><div role="listitem" class="sc-59513bf2-0 hoTFrx categoryItem"><div class="decoratorYellow"></div><div class="decoratorGreen"></div><div class="content"><div class="iconWrapper"><svg stroke="currentColor" fill="currentColor" stroke-width="0" role="img" viewBox="0 0 24 24" height="20px" width="20px" xmlns="http://www.w3.org/2000/svg"><title></title><path d="M22.251 11.82a3.117 3.117 0 0 0-2.328-3.01L22.911 0H8.104L11.1 8.838a3.116 3.116 0 0 0-2.244 2.988c0 1.043.52 1.967 1.313 2.536a8.279 8.279 0 0 1-1.084 1.244 8.14 8.14 0 0 1-2.55 1.647c-.834-.563-1.195-1.556-.869-2.446a3.11 3.11 0 0 0-.91-6.08 3.117 3.117 0 0 0-3.113 3.113c0 .848.347 1.626.903 2.182-.048.097-.097.195-.146.299-.465.959-.993 2.043-1.195 3.259-.403 2.432.257 4.384 1.849 5.489A5.093 5.093 0 0 0 5.999 24c1.827 0 3.682-.917 5.475-1.807 1.279-.632 2.599-1.292 3.898-1.612.48-.118.98-.187 1.508-.264 1.07-.153 2.175-.312 3.168-.89a4.482 4.482 0 0 0 2.182-3.091c.174-.994 0-1.994-.444-2.87.298-.48.465-1.042.465-1.647zm-1.355 0c0 .965-.785 1.75-1.75 1.75a1.753 1.753 0 0 1-1.085-3.126l.007-.007c.056-.042.118-.084.18-.125 0 0 .008 0 .008-.007.028-.014.055-.035.083-.05.007 0 .014-.006.021-.006.028-.014.063-.028.097-.042.035-.014.07-.027.098-.041.007 0 .013-.007.02-.007.028-.007.056-.021.084-.028.007 0 .02-.007.028-.007.034-.007.062-.014.097-.02h.007l.104-.022c.007 0 .02 0 .028-.007.028 0 .055-.007.083-.007h.035c.035 0 .07-.007.111-.007h.09c.028 0 .05 0 .077.007h.014c.055.007.111.014.167.028a1.766 1.766 0 0 1 1.396 1.723zM10.043 1.39h10.93l-2.509 7.4c-.104.02-.208.055-.312.09l-2.64-5.385-2.648 5.35c-.104-.034-.216-.055-.327-.076l-2.494-7.38zm4.968 9.825a3.083 3.083 0 0 0-.938-1.668l1.438-2.904 1.452 2.967c-.43.43-.743.98-.868 1.605H15.01zm-3.481-1.098c.034-.007.062-.014.097-.02h.02c.029-.008.056-.008.084-.015h.028c.028 0 .049-.007.076-.007h.271c.028 0 .049.007.07.007.014 0 .02 0 .035.007.027.007.048.007.076.014.007 0 .014 0 .028.007l.097.02h.007c.028.008.056.015.083.029.007 0 .014.007.028.007.021.007.049.014.07.027.007 0 .014.007.02.007.028.014.056.021.084.035h.007a.374.374 0 0 1 .09.049h.007c.028.014.056.034.084.048.007 0 .007.007.013.007.028.014.05.035.077.049l.007.007c.083.062.16.132.236.201l.007.007a1.747 1.747 0 0 1 .48 1.209 1.752 1.752 0 0 1-3.502 0 1.742 1.742 0 0 1 1.32-1.695zm-6.838-.049c.966 0 1.751.786 1.751 1.751s-.785 1.751-1.75 1.751-1.752-.785-1.752-1.75.786-1.752 1.751-1.752zm16.163 6.025a3.07 3.07 0 0 1-1.508 2.133c-.758.438-1.689.577-2.669.716a17.29 17.29 0 0 0-1.64.291c-1.445.355-2.834 1.05-4.182 1.717-1.724.854-3.35 1.66-4.857 1.66a3.645 3.645 0 0 1-2.154-.688c-1.529-1.056-1.453-3.036-1.272-4.12.167-1.015.632-1.966 1.077-2.877.028-.055.049-.104.077-.16.152.056.312.098.479.126-.264 1.473.486 2.994 1.946 3.745l.264.139.284-.104c1.216-.431 2.342-1.133 3.336-2.071a9.334 9.334 0 0 0 1.445-1.716c.16.027.32.034.48.034a3.117 3.117 0 0 0 3.008-2.327h1.167a3.109 3.109 0 0 0 3.01 2.327c.576 0 1.11-.16 1.57-.43.18.52.236 1.063.139 1.605z"></path></svg></div><div class="category">Jest</div><div class="description">Jest 를 사용한 유닛 테스트 관련 정리입니다.</div></div></div><div role="listitem" class="sc-59513bf2-0 hoTFrx categoryItem"><div class="decoratorYellow"></div><div class="decoratorGreen"></div><div class="content"><div class="iconWrapper"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="20px" width="20px" xmlns="http://www.w3.org/2000/svg"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 22l-5 -19l19 5.5z"></path><path d="M12.573 17.58l-6.152 -1.576l8.796 -9.466l1.914 6.64"></path><path d="M12.573 17.58l-1.573 -6.58l6.13 2.179"></path><path d="M9.527 4.893l1.473 6.107l-6.31 -1.564z"></path></svg></div><div class="category">Three.js</div><div class="description">3D 웹페이지 개발을 위한 Three.js 스터디 포스팅 입니다.</div></div></div><div role="listitem" class="sc-59513bf2-0 hoTFrx categoryItem"><div class="decoratorYellow"></div><div class="decoratorGreen"></div><div class="content"><div class="iconWrapper"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 640 512" height="20px" width="20px" xmlns="http://www.w3.org/2000/svg"><path d="M320 32c-8.1 0-16.1 1.4-23.7 4.1L15.8 137.4C6.3 140.9 0 149.9 0 160s6.3 19.1 15.8 22.6l57.9 20.9C57.3 229.3 48 259.8 48 291.9v28.1c0 28.4-10.8 57.7-22.3 80.8c-6.5 13-13.9 25.8-22.5 37.6C0 442.7-.9 448.3 .9 453.4s6 8.9 11.2 10.2l64 16c4.2 1.1 8.7 .3 12.4-2s6.3-6.1 7.1-10.4c8.6-42.8 4.3-81.2-2.1-108.7C90.3 344.3 86 329.8 80 316.5V291.9c0-30.2 10.2-58.7 27.9-81.5c12.9-15.5 29.6-28 49.2-35.7l157-61.7c8.2-3.2 17.5 .8 20.7 9s-.8 17.5-9 20.7l-157 61.7c-12.4 4.9-23.3 12.4-32.2 21.6l159.6 57.6c7.6 2.7 15.6 4.1 23.7 4.1s16.1-1.4 23.7-4.1L624.2 182.6c9.5-3.4 15.8-12.5 15.8-22.6s-6.3-19.1-15.8-22.6L343.7 36.1C336.1 33.4 328.1 32 320 32zM128 408c0 35.3 86 72 192 72s192-36.7 192-72L496.7 262.6 354.5 314c-11.1 4-22.8 6-34.5 6s-23.5-2-34.5-6L143.3 262.6 128 408z"></path></svg></div><div class="category">LLMOps</div><div class="description">LLMOps 를 통해 AI 와 가까워지기 위한 정리입니다.</div></div></div></div></section><section class="commonSection"><div class="sectionHeader"><svg stroke="currentColor" fill="none" stroke-width="2px" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="sectionIcon" height="20px" width="20px" xmlns="http://www.w3.org/2000/svg"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M9 6l11 0"></path><path d="M9 12l11 0"></path><path d="M9 18l11 0"></path><path d="M5 6l0 .01"></path><path d="M5 12l0 .01"></path><path d="M5 18l0 .01"></path></svg><div class="sectionTitle">All Blog Posts</div></div><div class="sectionContent flex flex-col gap-[20px]"><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="구조 분해 할당의 기본값 지정, null 은 사용 불가!" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">javascript</div><div class="title">구조 분해 할당의 기본값 지정, null 은 사용 불가!</div><div class="date">작성일: </div><div class="description">구조 분해 할당의 기본값 설정은 Nullish(undefined 와 null) 가 아닌, 오직 undefined 일 때만 적용됩니다.</div><a class="readMoreLink" href="/blog/javascript/2023-12-21-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="AWS S3 를 사용한 PDF 뷰어 구현시, Metadata 설정" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">javascript</div><div class="title">AWS S3 를 사용한 PDF 뷰어 구현시, Metadata 설정</div><div class="date">작성일: </div><div class="description">AWS S3 에 업로드한 PDF 파일이 렌더링되지 않고 다운로드 되는 이슈에 대한 정리 입니다.</div><a class="readMoreLink" href="/blog/javascript/2023-12-30-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="Nextjs 의 useRouter mock 정의하기" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">jest</div><div class="title">Nextjs 의 useRouter mock 정의하기</div><div class="date">작성일: </div><div class="description">Nextjs 의 useRouter 를 사용하는 컴포넌트를 테스트하기 위한 방법을 정리합니다.</div><a class="readMoreLink" href="/blog/jest/2024-01-06-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="&quot;styled-components&quot; 로 구현한 컴포넌트 테스트하기" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">jest</div><div class="title">&quot;styled-components&quot; 로 구현한 컴포넌트 테스트하기</div><div class="date">작성일: </div><div class="description">"styled-components" 를 사용한 컴포넌트를 테스트하기 위한 환경설정에 대해 알아봅니다.</div><a class="readMoreLink" href="/blog/jest/2023-12-26-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="&quot;jest.fn()&quot; 으로 함수 테스트하기" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">jest</div><div class="title">&quot;jest.fn()&quot; 으로 함수 테스트하기</div><div class="date">작성일: </div><div class="description">컴포넌트 props 로 넘겨주는 함수를 테스트하는 방법으로 "jest.fn()" 사용방법에 대한 정리 입니다.</div><a class="readMoreLink" href="/blog/jest/2023-12-23-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="LLMOps 와 친해지기 1 - 용어 정리" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">llmops</div><div class="title">LLMOps 와 친해지기 1 - 용어 정리</div><div class="date">작성일: </div><div class="description">AI 학습 모델인 Large Language Model 에 대한 정리입니다.</div><a class="readMoreLink" href="/blog/llmops/2023-12-16-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt=".DS_Store not found 에러" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">nextjs</div><div class="title">.DS_Store not found 에러</div><div class="date">작성일: </div><div class="description">Nextjs 빌드 시, .DS_Store 파일을 찾을 수 없다는 에러를 마주하게 되었습니다.</div><a class="readMoreLink" href="/blog/nextjs/2024-01-01-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="Nextjs 프로젝트의 유닛 테스트" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">nextjs</div><div class="title">Nextjs 프로젝트의 유닛 테스트</div><div class="date">작성일: </div><div class="description">유닛 테스트를 위해 Jest 와 @testing-library 설치 및 설정에 대한 정리 입니다.</div><a class="readMoreLink" href="/blog/nextjs/2023-12-16-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="Custom Hook 으로 분리하며 발생한 실수" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">react</div><div class="title">Custom Hook 으로 분리하며 발생한 실수</div><div class="date">작성일: </div><div class="description">Custom Hook 으로 분리한 useEffect 가 여러번 호출 케이스 중 한가지를 정리합니다.</div><a class="readMoreLink" href="/blog/react/2023-12-19-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="그림자 표현하기" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">그림자 표현하기</div><div class="date">작성일: </div><div class="description">그림자 설정방법과 특징에 대해 정리합니다.</div><a class="readMoreLink" href="/blog/threejs/2024-01-07-02">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="평평한 바닥(땅) 만들기 (Plane Mesh)" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">평평한 바닥(땅) 만들기 (Plane Mesh)</div><div class="date">작성일: </div><div class="description">바닥을 표현하기 위해 Plane Mesh 를 생성합니다.</div><a class="readMoreLink" href="/blog/threejs/2024-01-07-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="조명 종류와 설정" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">조명 종류와 설정</div><div class="date">작성일: </div><div class="description">조명 종류와 설정 방법에 대해 정리합니다.</div><a class="readMoreLink" href="/blog/threejs/2024-01-06-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="카메라 설정 (PerspectiveCamera)" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">카메라 설정 (PerspectiveCamera)</div><div class="date">작성일: </div><div class="description">Three.js 의 카메라인 PerspectiveCamera 설정에 대한 포스팅입니다.</div><a class="readMoreLink" href="/blog/threejs/2024-01-01-01">Read More</a></div></div></div></section></div></div></div><script src="/_next/static/chunks/webpack-14bcfdf71a1473f7.js" crossorigin="" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/0c7e3e2387401c47-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/6566b64e7f0e478f.css\",\"style\",{\"crossOrigin\":\"\"}]\n0:\"$L3\"\n"])</script><script>self.__next_f.push([1,"4:I[3728,[],\"\"]\n6:I[9928,[],\"\"]\n7:I[9248,[\"576\",\"static/chunks/576-dc377cf448834f03.js\",\"251\",\"static/chunks/251-ef7560cc4f7a9f6d.js\",\"185\",\"static/chunks/app/layout-5bdea2f994faa404.js\"],\"\"]\n8:I[179,[\"576\",\"static/chunks/576-dc377cf448834f03.js\",\"251\",\"static/chunks/251-ef7560cc4f7a9f6d.js\",\"185\",\"static/chunks/app/layout-5bdea2f994faa404.js\"],\"\"]\n9:I[6962,[\"576\",\"static/chunks/576-dc377cf448834f03.js\",\"251\",\"static/chunks/251-ef7560cc4f7a9f6d.js\",\"185\",\"static/chunks/app/layout-5bdea2f994faa404.js\"],\"\"]\na"])</script><script>self.__next_f.push([1,":I[6954,[],\"\"]\nb:I[7264,[],\"\"]\n"])</script><script>self.__next_f.push([1,"3:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/6566b64e7f0e478f.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]],[\"$\",\"$L4\",null,{\"buildId\":\"wDuWL0psubaLEaPs4XGSE\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/\",\"initialTree\":[\"\",{\"children\":[\"__PAGE__\",{}]},\"$undefined\",\"$undefined\",true],\"initialHead\":[false,\"$L5\"],\"globalErrorComponent\":\"$6\",\"children\":[null,[\"$\",\"html\",null,{\"lang\":\"ko\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_7bb6ba\",\"children\":[\"$\",\"div\",null,{\"className\":\"w-full\\n            h-full\\n            overflow-y-scroll\\n            overflow-x-auto\",\"children\":[\"$\",\"$L7\",null,{\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"$L9\",null,{\"style\":{\"minHeight\":\"calc(100% - 72px)\"},\"children\":[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"childProp\":{\"current\":[\"$Lc\",\"$Ld\",null],\"segment\":\"__PAGE__\"},\"styles\":null}]}]]}]}]}]}],null]}]]\n"])</script><script>self.__next_f.push([1,"5:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Chocobe Blog v2\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"Frontend 기술 블로그 입니다.\"}],[\"$\",\"link\",\"4\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"5\",{\"name\":\"next-size-adjust\"}]]\nc:null\n"])</script><script>self.__next_f.push([1,"e:I[463,[\"281\",\"static/chunks/08ffe114-a8e3ed06beefbf38.js\",\"465\",\"static/chunks/48507feb-6de01ca04009bb96.js\",\"306\",\"static/chunks/39209d7c-a33d4549f726b4ab.js\",\"576\",\"static/chunks/576-dc377cf448834f03.js\",\"251\",\"static/chunks/251-ef7560cc4f7a9f6d.js\",\"128\",\"static/chunks/128-a9a4b8134fdbdc1d.js\",\"931\",\"static/chunks/app/page-2a9b84f80b166504.js\"],\"\"]\nf:T162a,"])</script><script>self.__next_f.push([1,"---\nid: 1\ntitle: '\"node:fs\" 테스트 하기'\ndescription: 'node 모듈중 File System 기능, \"fs\" 를 테스트하는 방법에 대해 정리합니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: true\ntags: [\n    'mock-fs',\n    'fs',\n    'node:fs',\n    'jest',\n    '@testing-library',\n    '유닛 테스트',\n]\n\ncreatedAt: '2023-12-17 15:33:00'\nmodifiedHistories: []\n---\n\n\n# \"node:fs\" 테스트 하기\n\nNextjs 를 사용하게 되면서 SSG(static site generators) 와 SSR(server side rendering) 을 사용하게 되었습니다.\n\n덕분에 CSR(client side rendering) 의 단점인 SEO 를 해소할 수 있게 되었습니다.\n\nSSG(static site generators) 와 SSR(server side rendering) 을 사용하게 되면, **node** 모듈들을 사용할 수 있습니다.\n\n이번 포스팅은 **node:fs** 를 사용하는 코드의 유닛 테스트 방법에 대해 정리합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## Jest 에서 안내하는 built-in modules 테스트\n\n* 참고: [[Jest 공식문서] Mocking Node modules](https://jestjs.io/docs/manual-mocks#mocking-node-modules)\n\n\u003cbr /\u003e\n\nJest 공식문서에 의하면, built-in modules 를 테스트하기 위해 몇가지 사전준비가 필요합니다.\n\n1. **node_modules** 와 인접한 경로에 **__mocks__** 폴더 만들기\n2. 테스트할 built-in module 과 동일한 이름의 파일(**fs.js**) 을 **__mocks__** 하위에 만들기\n3. **fs.js** 파일 구현하기\n    1. `jest.createMockFromModule('fs')` 를 호출하여 mock 적용하기\n    2. `fs` 의 메시드 중, 테스트 대상이 사용하는 모든 메서드에 mock 구현\n4. 유닛 테스트 파일에서 `jest.mock('fs')` 로 mock 적용하기\n\n\u003cbr /\u003e\n\n위 과정을 모두 구현할 수도 있지만, 좀 더 편리한 방법을 찾아본 결과 **mock-fs** 라는 라이브러리를 찾게 되었습니다.\n\n**mock-fs** 는 Jest 에서 안내하는 \"node:fs\" 테스트 준비 과정을 제공합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## **mock-fs** 설치하기\n\n만약 **Typescript** 를 사용한다면, **@types/mock-fs** 모듈도 함께 설치합니다.\n\n```bash title=\"Javascript 사용 시\" \nyarn add -D mock-fs\n```\n\n```bash title=\"Typescript 사용 시\"\nyarn add -D mock-fs @types/mock-fs\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## **node:fs** 테스크 코드 작성하기\n\n* 참고: [mock-fs 공식 문서](https://github.com/tschaub/mock-fs?tab=readme-ov-file#mock-fs)\n* 참고: [[지나가던 개발자]jest와 mock-fs로 fs 유닛 테스트하기](https://znagadeon.dev/post/test-fs/index.html)\n\n\u003cbr /\u003e\n\n**mock-fs** 를 사용하게 되면 아래의 2가지 작업이 필요합니다.\n\n* `jest.beforeEach()`: **mock-fs** 를 사용한 file system mockup\n* `jest.afterEach()`: **mock-fs** 해제\n\n\u003cbr /\u003e\n\n먼저 테스트 준비를 위한 mockup 을 구현하면 다음과 같습니다.\n\n```typescript showLineNumbers\nimport mock from 'mock-fs';\n\ndescribe('mock-fs 를 사용한 \"node:fs\" 테스트', () =\u003e {\n    beforeEach(() =\u003e {\n        mock({\n            '경로1': {\n                '하위_경로1': {\n                    '파일_1.mdx': '파일 내용 mockup',\n                    '파일_2.mdx': '파일 내용 mockup',\n                },\n            },\n            '경로2/경로3': {\n                '하위_경로2': {\n                    // 빈 폴더\n                },\n            },\n        });\n    });\n});\n```\n\n\u003cbr /\u003e\n\n이제 **node:fs** 는 mockup 에서 정의한 mock file system 을 사용하게 됩니다.\n\n```typescript {22} showLineNumbers\nimport fs from 'node:fs/promises';\nimport mock from 'mock-fs';\n\ndescribe('mock-fs 를 사용한 \"node:fs\" 테스트', () =\u003e {\n    beforeEach(() =\u003e {\n        mock({\n            '경로1': {\n                '하위_경로1': {\n                    '파일_1.mdx': '파일 내용 mockup',\n                    '파일_2.mdx': '파일 내용 mockup',\n                },\n            },\n            '경로2/경로3': {\n                '하위_경로2': {\n                    // 빈 폴더\n                },\n            },\n        });\n    });\n\n    it('\"node:fs\" 를 사용하여 파일을 가져올 수 있다.', async () =\u003e {\n        const fileNameList = await fs.readdir('경로1/하위_경로1');\n\n        expect(fileNameList).toEqual([\n            '파일_1.mdx',\n            '파일_2.mdx',\n        ]);\n    });\n});\n```\n\n\u003cbr /\u003e\n\n마지막으로 **mock-fs** 를 해제할 수 있도록 `jest.afterEach()` 를 작성하면 \"node:fs\" 유닛 테스트는 작성완료 됩니다.\n\n```typescript {21} showLineNumbers\nimport fs from 'node:fs/promises';\nimport mock from 'mock-fs';\n\ndescribe('mock-fs 를 사용한 \"node:fs\" 테스트', () =\u003e {\n    beforeEach(() =\u003e {\n        mock({\n            '경로1': {\n                '하위_경로1': {\n                    '파일_1.mdx': '파일 내용 mockup',\n                    '파일_2.mdx': '파일 내용 mockup',\n                },\n            },\n            '경로2/경로3': {\n                '하위_경로2': {\n                    // 빈 폴더\n                },\n            },\n        });\n    });\n\n    afterEach(mock.restore);\n\n    it('\"node:fs\" 를 사용하여 파일을 가져올 수 있다.', async () =\u003e {\n        const fileNameList = await fs.readdir('경로1/하위_경로1');\n\n        expect(fileNameList).toEqual([\n            '파일_1.mdx',\n            '파일_2.mdx',\n        ]);\n    });\n});\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\n이번 포스팅에서는 built-in modules 중 \"fs\" 를 테스트하는 방법에 대해 정리해 보았습니다.\n\n\"fs\" 가 아닌 다른 module 에 대한 테스트를 한다면, 결국은 Jest 공식문서에서 안내하는 mockup 방법도 사용해 보아야 할 것 같습니다.\n"])</script><script>self.__next_f.push([1,"10:T5076,"])</script><script>self.__next_f.push([1,"---\nid: 1\ntitle: Three.js 설치 및 실행\ndescription: 'Three.js 를 사용하기 위한 설치와 첫번째 화면을 그려봅니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: true\ntags: [\n    'threejs',\n    'javascript',\n    '3d',\n]\n\ncreatedAt: '2023-12-31 22:47:00'\nmodifiedHistories: []\n---\n\n# Three.js 설치 및 실행\n\n일반적인 웹페이지는 2D 기반으로 구현합니다.\n\n이러한 웹페이지는 서비스를 제공하거나 정보 공유를 목적으로 충분합니다.\n\n만약 이렇게 보편적으로 사용하는 2D 웹페이지에 3D 환경을 더한다면, 서비스나 제품의 브렌딩에 차별점을 줄 수 있을 것 같습니다.\n\n\u003cbr /\u003e\n\nThree.js 를 스터디하며, 이 블로그의 Profile 페이지를 구현하는 것을 첫번째 목표로 하여 포스팅을 해보려 합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## Vite 프로젝트 생성하기\n\nThree.js 를 사용하기 위해, VanillaJS 환경의 프로젝트를 생성해 보겠습니다.\n\nWebpack 을 사용하여 프로젝트를 만들어도 되지만, 프로젝트 구성에 투자되는 리소스가 많아지므로, Vite 를 사용하여 프로젝트를 생성해보겠습니다.\n\n```bash title=\"Vite 프로젝트 생성\"\nyarn create vite --template vanilla my-threejs\n\ncd my-threejs\n\nyarn install\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## Three.js 설치하기\n\n프로젝트를 생성한 후, Three.js 를 설치합니다.\n\n```bash title=\"Three.js 설치\"\nyarn install three\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## Three.js 기본 구조 구성하기\n\nThree.js 는 **WebGL** 을 기반으로 동작합니다.\n\n이는 **HTML Canvas API** 를 사용하여 그리는 방식입니다.\n\nThree.js 로 화면을 그리기 위한 기본 과정을 살펴보면 다음과 같습니다.\n\n1. `\u003ccanvas /\u003e` 태그 생성\n2. **WebGLRenderer** 객체 생성\n3. 카메라 생성\n4. 조명 생성\n5. **Scene** 객체 생성\n6. 위에서 생성한 객체들을 조합하여 **WebGLRenderer** 에 적용\n7. `requestAnimationFrame()` 을 사용하여 `\u003ccanvas /\u003e` 렌더링\n\n\u003cbr /\u003e\n\n위 과정은 아래와 같이 함수를 생성하여 구현해 보겠습니다.\n\n1. `init()` 함수 만들기: 1번 ~ 6번 과정을 처리합니다.\n2. `render()` 함수 만들기: 7번 과정을 처리합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 1. `\u003ccanvas /\u003e` 태그 생성\n\n먼저 Three.js 를 렌더링할 `\u003ccanvas /\u003e` 태그를 생성하는 로직을 구현해 보겠습니다.\n\n```js title=\"main.js\" showLineNumber\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n}\n\ninit();\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 2. **WebGLRenderer** 객체 생성\n\n**WebGLRenderer** 객체는 Three.js 의 코어 역할을 합니다.\n\n위에서 생성한 `\u003ccanvas /\u003e` 를 인자로 넘겨주어 렌더링 대상을 지정해 줍니다.\n\n```js title=\"main.js\" showLineNumbers {2, 5-6, 15-18}\nimport {\n    WebGLRenderer,\n} from 'three';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    // 2. WebGLRenderer 객체 생성\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n    });\n}\n\ninit();\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 3. 카메라 생성\n\nThree.js 가 실제로 화면에 렌더링하는 것은 `Camera` 가 비추는 곳이 됩니다.\n\n따라서 Three.js 에 사용할 카메라 객체를 생성해 줍니다.\n\n```js title=\"main.js\" showLineNumbers {3, 9-10, 24-25}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n} from 'three';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    // 2. `WebGLRenderer` 객체 생성\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n    });\n\n    // 3. 카메라 생성\n    camera = new PerspectiveCamera();\n}\n\ninit();\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 4. 조명 생성\n\n이번에는 조명 객체인 **DirectionalLight** 객체를 생성해 보겠습니다.\n\n현실 세계에서도 빛이 있어야 물체를 볼 수 있듯이, Three.js 에서도 조명이 있어야 물체가 렌더링 됩니다.\n\n조명은 여러가지가 있는데, 이 중 햇빛처럼 직선의 일정한 양의 빛을 나타내는 **DirectionalLight** 객체를 사용해 보겠습니다.\n\n```js title=\"main.js\" showLineNumbers {4, 28-29}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    DirectionalLight,\n} from 'three';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    // 2. `WebGLRenderer` 객체 생성\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n    });\n\n    // 3. 카메라 생성\n    camera = new PerspectiveCamera();\n\n    // 4. 조명 생성\n    const light = new DirectionalLight();\n}\n\ninit();\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 5. **Scene** 객체 생성\n\n무대는 `Scene` 객체로 만들 수 있습니다.\n\n`Scene` 객체는 `add()` 메서드를 사용하여 위에서 만들었던 조명과 물체(Mesh)들을 적용할 수 있습니다.\n\n\u003cbr /\u003e\n\n`Scene` 객체를 생성하고 조명을 적용해 보겠습니다.\n\n```js title=\"main.js\" showLineNumbers {5, 14-15, 35-37}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    DirectionalLight,\n    Scene,\n} from 'three';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { Scene } */\nlet scene;\n\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    // 2. `WebGLRenderer` 객체 생성\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n    });\n\n    // 3. 카메라 생성\n    camera = new PerspectiveCamera();\n\n    // 4. 조명 생성\n    const light = new DirectionalLight();\n\n    // 5. `Scene` 객체 생성\n    scene = new Scene();\n    scene.add(light);\n}\n\ninit();\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용\n\n이제 Three.js 를 실행하여 화면을 그릴 준비가 되었습니다.\n\n**WebGLRenderer** 는 **Scene(무대)** 와 **카메라** 를 사용하여 화면을 그리는 역할을 하게 됩니다.\n\n```js title=\"main.js\" showLineNumbers {39-40}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    DirectionalLight,\n    Scene,\n} from 'three';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { Scene } */\nlet scene;\n\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    // 2. `WebGLRenderer` 객체 생성\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n    });\n\n    // 3. 카메라 생성\n    camera = new PerspectiveCamera();\n\n    // 4. 조명 생성\n    const light = new DirectionalLight();\n\n    // 5. `Scene` 객체 생성\n    scene = new Scene();\n    scene.add(light);\n\n    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용\n    renderer.render(scene, camera);\n}\n\ninit();\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 7. `requestAnimationFrame()` 을 사용하여 `\u003ccanvas /\u003e` 렌더링\n\n이번에는 `init()` 의 마지막에 호출할 `render()` 함수를 만들고, Three.js 를 실행하여 브라우저에서 결과를 확인해 보겠습니다.\n\n추가할 `render()` 함수는 `requestAnimationFrame()` 을 사용하여 `render()` 함수를 재귀 호출하도록 하는데, 이는 브라우저에서 **60fps 로 실행하며 화면을 업데이트** 하게 됩니다.\n\n```js title=\"main.js\" showLineNumbers {42-43, 46-50}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    DirectionalLight,\n    Scene,\n} from 'three';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { Scene } */\nlet scene;\n\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    // 2. `WebGLRenderer` 객체 생성\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n    });\n\n    // 3. 카메라 생성\n    camera = new PerspectiveCamera();\n\n    // 4. 조명 생성\n    const light = new DirectionalLight();\n\n    // 5. `Scene` 객체 생성\n    scene = new Scene();\n    scene.add(light);\n\n    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용\n    renderer.render(scene, camera);\n\n    // 7. requestAnimationFrame() 을 사용하여 \u003ccanvas /\u003e 렌더링\n    render();\n}\n\nfunction render() {\n    renderer.render(scene, camera);\n\n    requestAnimationFrame(render);\n}\n\ninit();\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 추가: Scene 에 SphereMesh 추가하기\n\n지금까지 작성한 코드를 실행하면, 검은색 화면만 보이게 됩니다.\n\n이는 실제로 화면에 그릴 물체(Mesh) 가 없기 때문에 그릴 대상이 없는 현상입니다.\n\n\u003cbr /\u003e\n\n위에서 구성한 Three.js 가 잘 동작하는지 테스트를 위해 구형 물체(Sphere Mesh) 를 생성하고, 적용해 보겠습니다.\n\n```js title=\"main.js\" showLineNumbers {7-9, 48-49, 61-67}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    DirectionalLight,\n    Scene,\n\n    SphereGeometry,\n    MeshPhongMaterial,\n    Mesh,\n} from 'three';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { Scene } */\nlet scene;\n\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    // 2. `WebGLRenderer` 객체 생성\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n    });\n\n    // 3. 카메라 생성\n    camera = new PerspectiveCamera();\n    camera.position.set(0, 0, 10);\n\n    // 4. 조명 생성\n    const light = new DirectionalLight();\n    light.position.set(1, 1, 1);\n\n    // 5. `Scene` 객체 생성\n    scene = new Scene();\n    scene.add(light);\n\n    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용\n    renderer.render(scene, camera);\n\n    // 추가: Schene 에 SphereMesh 추가하기\n    createSphereMesh();\n\n    // 7. requestAnimationFrame() 을 사용하여 \u003ccanvas /\u003e 렌더링\n    render();\n}\n\nfunction render() {\n    renderer.render(scene, camera);\n\n    requestAnimationFrame(render);\n}\n\nfunction createSphereMesh() {\n    const sphere_geometry = new SphereGeometry();\n    const sphere_material = new MeshPhongMaterial();\n    const sphere_mesh = new Mesh(sphere_geometry, sphere_material);\n\n    scene.add(sphere_mesh);\n}\n\ninit();\n```\n\n\u003cbr /\u003e\n\n`createSphereMesh()` 함수에서 3가지 객체를 생성하고 있습니다.\n\n이는 컴퓨터 그래픽스에서 3D 물체를 표현하기 위한 요소들 입니다.\n\n* Geometry: 색이 없는 모델링 객체\n* Material: 모델링 객체의 색상 또는 질감\n* Mesh: Geometry 와 Material 을 합친 결과 모델링 객체\n\n`sphere_mesh` 객체의 `add()` 메소드를 사용하여 **Geometry** 와 **Material** 을 합쳐서 하나의 **Mesh** 를 만들 수 있게 됩니다.\n\n\u003cbr /\u003e\n\n지금까지 작성한 코드를 실행하면 다음과 같은 결과물을 볼 수 있습니다.\n\n\u003cimg src=\"/markdownAssets/threejs/2023-12-31-01/2023-12-31-01-01.png\" alt=\"Threejs 실행 결과\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 추가: `\u003ccanvas /\u003e` 를 전체화면으로 설정하기\n\n위 결과물을 확인하면, `\u003ccanvas /\u003e` 요소가 inline 으로 렌더링되고 있습니다.\n\n이는 **WebGLRenderer** 객체의 **size** 를 조정하여 전체화면으로 설정할 수 있습니다.\n\n그리고 `\u003ccanvas /\u003e` 의 기본 스타일인 `display: inline` 을 `display: block` 으로 변경합니다.\n\n```css title=\"style.css\" showLineNumbers\n* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\ncanvas {\n    display: block;\n}\n```\n\n```js title=\"main.js\" showLineNumbers {11, 33-36}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    DirectionalLight,\n    Scene,\n\n    SphereGeometry,\n    MeshPhongMaterial,\n    Mesh,\n} from 'three';\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { Scene } */\nlet scene;\n\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    // 2. `WebGLRenderer` 객체 생성\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n    });\n    renderer.setSize(\n        window.innerWidth,\n        window.innerHeight\n    );\n\n    // 3. 카메라 생성\n    camera = new PerspectiveCamera();\n    camera.position.set(0, 0, 10);\n\n    // 4. 조명 생성\n    const light = new DirectionalLight();\n    light.position.set(1, 1, 1);\n\n    // 5. `Scene` 객체 생성\n    scene = new Scene();\n    scene.add(light);\n\n    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용\n    renderer.render(scene, camera);\n\n    // 추가: Schene 에 SphereMesh 추가하기\n    createSphereMesh();\n\n    // 7. requestAnimationFrame() 을 사용하여 \u003ccanvas /\u003e 렌더링\n    render();\n}\n\nfunction render() {\n    renderer.render(scene, camera);\n\n    requestAnimationFrame(render);\n}\n\nfunction createSphereMesh() {\n    const sphere_geometry = new SphereGeometry();\n    const sphere_material = new MeshPhongMaterial();\n    const sphere_mesh = new Mesh(sphere_geometry, sphere_material);\n\n    scene.add(sphere_mesh);\n}\n\ninit();\n```\n\n\u003cbr /\u003e\n\n이렇게 적용한 결과는 다음과 같습니다.\n\n\u003cimg src=\"/markdownAssets/threejs/2023-12-31-01/2023-12-31-01-02.png\" alt=\"전체화면 적용\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 추가: 찌그러진 화면 보정하기\n\nScene 에 추가한 모델링은 구(Sphere) 입니다.\n\n하지만 결과 화면에서 보여지는 구는 타원형으로 보여집니다.\n\n원인은 아래와 같습니다. \n\n* **카메라의 종횡비(aspect radio)** 설정을 하지 않았으므로, 기본값인 **1** 로 설정됨\n* 브라우저의 종횡비가 1:1 이 아닌 상태에서 `\u003ccanvas /\u003e` 를 전체화면으로 늘리면서 발생하는 화면 늘어짐\n\n\u003cbr /\u003e\n\n이를 해결하기 위해 **카메라의 종횡비(aspect radio)** 를 설정해줍니다.\n\n```js title=\"main.js\" showLineNumbers {39-42}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    DirectionalLight,\n    Scene,\n\n    SphereGeometry,\n    MeshPhongMaterial,\n    Mesh,\n} from 'three';\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { Scene } */\nlet scene;\n\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    // 2. `WebGLRenderer` 객체 생성\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n    });\n    renderer.setSize(\n        window.innerWidth,\n        window.innerHeight\n    );\n\n    // 3. 카메라 생성\n    camera = new PerspectiveCamera(\n        45,\n        window.innerWidth / window.innerHeight\n    );\n    camera.position.set(0, 0, 10);\n\n    // 4. 조명 생성\n    const light = new DirectionalLight();\n    light.position.set(1, 1, 1);\n\n    // 5. `Scene` 객체 생성\n    scene = new Scene();\n    scene.add(light);\n\n    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용\n    renderer.render(scene, camera);\n\n    // 추가: Schene 에 SphereMesh 추가하기\n    createSphereMesh();\n\n    // 7. requestAnimationFrame() 을 사용하여 \u003ccanvas /\u003e 렌더링\n    render();\n}\n\nfunction render() {\n    renderer.render(scene, camera);\n\n    requestAnimationFrame(render);\n}\n\nfunction createSphereMesh() {\n    const sphere_geometry = new SphereGeometry();\n    const sphere_material = new MeshPhongMaterial();\n    const sphere_mesh = new Mesh(sphere_geometry, sphere_material);\n\n    scene.add(sphere_mesh);\n}\n\ninit();\n```\n\n\u003cbr /\u003e\n\n`PerspectiveCamera` 생성자에 인자로 2가지를 넘겨주었습니다.\n\n인자 타입은 다음과 같습니다.\n\n```ts title=\"Perspective 생성자의 인자\"\nclass PerspectiveCamera {\n    constructor(\n        fov: number,\n        aspect: number\n    ) {\n        // ...\n    }\n}\n```\n\n**fov (Field of View)** 는 **카메라의 왜곡 정도값**을 말합니다.\n\n이는 **렌즈 배율** 과 **Sensor-size** 에 대한 연산값이며, **화각을 수치화** 한 것입니다.\n\n값이 클수록 멀리서 보는 느낌의 효과가 발생합니다.\n\n\u003cbr /\u003e\n\n두번째 인자인 **aspect** 는 **카메라 종횡비(aspect ratio)** 에 대한 설정입니다.\n\n화면의 **가로 / 세로** 비율을 나타내므로, `window.innerWidth / window.innerHeight` 로 값을 도출할 수 있습니다.\n\n\u003cbr /\u003e\n\n이렇게 설정한 결과물은 아래와 같습니다.\n\n\u003cimg src=\"/markdownAssets/threejs/2023-12-31-01/2023-12-31-01-03.png\" alt=\"전체화면 적용\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 추가: **계단 효과** 보정하기\n\n모니터는 Pixel 에 RGB 를 발사하여 화면을 그립니다.\n\n이 Pixel 은 정사각형 모양이기 때문에 곡선을 렌더링하게 되면 마치 계단처럼 각진 곡선으로 표현됩니다.\n\n**WebGLRenderer** 객체를 생성하며 options 를 통해 계단 효과를 보정할 수 있습니다.\n\n\u003cbr /\u003e\n\n컴퓨터 그래픽스에서 계단 효과를 해소하는 기법을 간단하게 설명하면, 곡선이 아닌 부분을 흐림(blur) 처리하여 마치 자연스러운 곡선처럼 표현해 줍니다.\n\n이러한 기법을 **Anti-Aliasing** 이라고 합니다.\n\n```js title=\"main.js\" showLineNumbers {32}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    DirectionalLight,\n    Scene,\n\n    SphereGeometry,\n    MeshPhongMaterial,\n    Mesh,\n} from 'three';\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { Scene } */\nlet scene;\n\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    // 2. `WebGLRenderer` 객체 생성\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n    renderer.setSize(\n        window.innerWidth,\n        window.innerHeight\n    );\n\n    // 3. 카메라 생성\n    camera = new PerspectiveCamera(\n        45,\n        window.innerWidth / window.innerHeight\n    );\n    camera.position.set(0, 0, 10);\n\n    // 4. 조명 생성\n    const light = new DirectionalLight();\n    light.position.set(1, 1, 1);\n\n    // 5. `Scene` 객체 생성\n    scene = new Scene();\n    scene.add(light);\n\n    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용\n    renderer.render(scene, camera);\n\n    // 추가: Schene 에 SphereMesh 추가하기\n    createSphereMesh();\n\n    // 7. requestAnimationFrame() 을 사용하여 \u003ccanvas /\u003e 렌더링\n    render();\n}\n\nfunction render() {\n    renderer.render(scene, camera);\n\n    requestAnimationFrame(render);\n}\n\nfunction createSphereMesh() {\n    const sphere_geometry = new SphereGeometry();\n    const sphere_material = new MeshPhongMaterial();\n    const sphere_mesh = new Mesh(sphere_geometry, sphere_material);\n\n    scene.add(sphere_mesh);\n}\n\ninit();\n```\n\n\n\n## 마치며\n\nThree.js 를 실행하기 위한 최소 구성요소를 구현해 보았습니다.\n\n뭔가 복잡해 보이지만 현실 세계의 무대를 만드는 것과 유사한 개념으로 만들고 있습니다.\n\n* `WebGLRenderer`: 무대를 구성할 건물\n* `Scene`: 무대\n* `PerspectiveCamera`: 카메라\n* `DirectionalLight`: 조명\n* `Mesh`: 배경, 배우, 소품\n\n\u003cbr /\u003e\n\nThree.js 를 처음 시작하며 제가 느낀 어려움으로는 컴퓨터 그래픽스 개념과 카메라에 대한 이해였습니다.\n\n단순히 Three.js 사용법을 익히는 것만으로 원하는 결과물을 얻기는 어려워 보입니다.\n\n지금까지의 코딩에 비해 학습 난이도는 높지만, 새로운 성취감과 즐거움이 기대됩니다.\n"])</script><script>self.__next_f.push([1,"11:T1171,"])</script><script>self.__next_f.push([1,"---\nid: 1\ntitle: 구조 분해 할당의 기본값 지정, null 은 사용 불가!\ndescription: '구조 분해 할당의 기본값 설정은 Nullish(undefined 와 null) 가 아닌, 오직 undefined 일 때만 적용됩니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'javascript',\n]\n\ncreatedAt: '2023-12-21 20:20:00'\nmodifiedHistories: []\n---\n\n# 구조 분해 할당의 기본값 지정, Null 은 사용 불가!\n\nplain object 를 사용하여, 데이터를 의미단위로 묶어서 사용합니다.\n\n의미를 가지는 key 와 쌍을 이루는 value 로 구성되며, Javascript built-in object 에도 많은 기능을 제공합니다.\n\n이번 포스팅에서는 이러한 plain object 의 기능들 중, **구조 분해 할당의 기본값 설정** 에 대해 정리합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 구조 분해 할당의 기본값\n\n구조 분해 할당은 plain object 의 하위 프로퍼티에 좀 더 효율적으로 참조하는 기능입니다.\n\n```javascript title=\"구조 분해 할당 예시\" showLineNumbers {8-14}\nconst obj = {\n    keyA: 'value a',\n    keyB: 'value b',\n    keyC: undefined,\n    keyD: null,\n};\n\n// 구조 분해 할당\nconst {\n    keyA,\n    keyB,\n    keyC,\n    keyD,\n} = obj;\n```\n\n\u003cbr /\u003e\n\n위 예시처럼 value 가 `undefined` 인 경우도 있고, `null` 인 경우가 있었습니다.\n\n이러한 경우 **기본값을 지정하여 유효한 value 를 보장** 하도록 의도하였습니다.\n\n```javascript title=\"구조 분해 할당의 기본값 예시\" showLineNumbers {8-14}\nconst obj = {\n    keyA: 'value a',\n    keyB: 'value b',\n    keyC: undefined,\n    keyD: null,\n};\n\n// 구조 분해 할당 기본값 지정\nconst {\n    keyA,\n    keyB,\n    keyC =. '빈 값',\n    keyD = '빈 값',\n};\n```\n\n\u003cbr /\u003e\n\n여기서 제가 실수한 부분이 있습니다.\n\n~~`value` 가 `Nullish (undefined 또는 null)` 일 경우, 기본값을 설정할 수 있다고 생각했습니다.~~\n\n하지만 `null` 에는 기본값 설정이 불가능 하고, **`value` 가 `undefined` 일 경우에만 기본값을 설정** 할 수 있었습니다.\n\n* [MDN - 구조 분해 할당](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%EA%B8%B0%EB%B3%B8%EA%B0%92)\n\n\u003cbr /\u003e\n\n제가 실수한 부분이 일으킨 이슈는 아래의 코드와 같습니다.\n\n```javascript title=\"구조 분해 할당의 기본값 이슈\" showLineNumbers {11-12, 15-17}\nconst obj = {\n    keyA: 'value a',\n    keyB: 'value b',\n    keyC: undefined,\n    keyD: null,\n};\n\nconst {\n    keyA,\n    keyB,\n    keyC = '값 없음',\n    keyD = '값 없음',\n} = obj;\n\n// 에러 발생\n// Error: Cannot read properties of null (reading 'toUpperCase')\nconsole.log('keyD.toUpperCase(): ', keyD.toUpperCase());\n```\n\n\u003cbr /\u003e\n\n`keyD` 에 기본값을 `string` 으로 지정하였지만, `null` 이므로 기본값 지정이 적용되지 않습니다.\n\n그러므로 `keyD.toUpperCase()` 를 호출할 경우, `null` 에 대한 메소드 호출이 되며 에러가 발생하게 됩니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## null 은 명시적으로 표현한 값이 없음!\n\n값이 없을을 나타내는 `undefined` 와 `null` 은 타입도 다르지만, 더 **중요한 것은 의미** 인 것 같습니다.\n\n변수나 프로퍼티에 할당한 값이 없는 경우 `undefined` 를 가지고, `null` 은 개발자가 의도를 가지고 값을 비운다는 의미입니다.\n\n즉, 의도를 가지고 비워둔 값에는 구조 분해 할당의 기본값이 적용되지 않는 것 입니다.\n\n\u003cbr /\u003e\n\n만약 `Nullish` 에 대한 기본값을 지정하고 싶을 경우는 **Nullish 병합 연산자** 를 사용합니다.\n\n```javascript title=\"Nullish 병합 연산자\" showLineNumbers {11-12, 15-16}\nconst obj = {\n    keyA: 'value a',\n    keyB: 'value b',\n    keyC: undefined,\n    keyD: null\n};\n\nconst {\n    keyA,\n    keyB,\n    keyC: _keyC,\n    keyD: _keyD,\n};\n\nconst keyC = _keyC ?? '값 없음';\nconst keyD = _keyD ?? '값 없음';\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 유감스러운 구조 분해 할당의 기본값\n\n`undefined` 뿐만 아니라, `Nullish` 에 대한 기본값을 설정하고 싶다면, 위 예시코드와 같이 코드 1줄씩 추가로 작성하게 됩니다.\n\n이 기능의 의미는 이해하지만, 작성할 코드가 늘어난다는 점에서는 아쉽습니다.\n\n\u003cbr /\u003e\n\n다른분들은 저와 같은 실수가 없기를 바라며, 이번 포스팅을 마무리 합니다.\n"])</script><script>self.__next_f.push([1,"12:T1174,"])</script><script>self.__next_f.push([1,"---\nid: 2\ntitle: AWS S3 를 사용한 PDF 뷰어 구현시, Metadata 설정\ndescription: 'AWS S3 에 업로드한 PDF 파일이 렌더링되지 않고 다운로드 되는 이슈에 대한 정리 입니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'javascript',\n    'PDF',\n    'PDF Metadata',\n    'AWS',\n    'S3',\n]\n\ncreatedAt: '2023-12-30 16:00:00'\nmodifiedHistories: []\n---\n\n# 웹에서 PDF 뷰어를 제공하는 방법\n\nPDF 파일은 범용적으로 사용되는 문서 파일 입니다.\n\nPDF 뷰어를 제공하는 방법에는 여러가지가 있습니다.\n\n* `\u003ciframe /\u003e`, `\u003cobject /\u003e`, `\u003cembed /\u003e` 태그\n* PDF 뷰어 관련 라이드러리들\n\n\n\n\u003cbr /\u003e\n\n\n\n## `\u003cobject /\u003e` 를 사용한 PDF 뷰어 구현하기\n\nPDF 파일은 브라우저 내장 뷰어에서 다양한 기능을 제공합니다.\n\n구현 초기에는 `\u003ciframe /\u003e` 이나 `\u003cobject /\u003e` 의 보안문제를 피하기 위해, PDF 라이브러리를 사용하고자 하였습니다.\n\n하지만 브라우저의 내장 PDF 뷰어의 강력한 기능들을 포기하거나 직접 구현해야 하는 문제가 있습니다.\n\n\u003cbr /\u003e\n\n이러한 이유로 `\u003cobject /\u003e` 태그를 사용하여 PDF 뷰어를 사용하기로 하였습니다.\n\n또한 `\u003ciframe /\u003e` 보다는 `\u003cobject /\u003e` 태그가 PDF 에는 적합하다는 MDN 공식문서에 따르게 되었습니다.\n\n* 참고: [MDN 공식 문서](https://developer.mozilla.org/ko/docs/Learn/HTML/Multimedia_and_embedding/Other_embedding_technologies#embed_%EC%99%80_object_%EC%9A%94%EC%86%8C)\n\n\n\n\u003cbr /\u003e\n\n\n\n## `\u003cobject /\u003e` 를 사용하여 간단한 PDF 뷰어 만들기\n\n아래와 같이 `\u003cobject /\u003e` 태그를 사용하여 간단하게 PDF 뷰어 기능을 사용할 수 있습니다.\n\n```tsx title=\"PDF 뷰어 예시 코드\" showLineNumbers\ntype TMyPdfViewerProps = {\n    url: string;\n}\n\nfunction MyPdfViewer(props: TMyPdfViewerProps) {\n    const {\n        url,\n    } = props;\n\n    const data = `${url}#view=FitH`;\n\n    return (\u003c\u003e\n        \u003cobject \n            data={data}\n            type='application/pdf' \n            width='100%' \n            height='100%' /\u003e\n    \u003c/\u003e);\n}\n\nexport default MyPdfViewer;\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## AWS S3 에 업로드한 PDF 파일이 다운로드되는 이슈\n\nAWS S3 는 널리 사용되는 클라우드 스토리지 입니다.\n\nPDF 파일을 S3 에 업로드한 후, `\u003cMyPdfViewer /\u003e` 컴포넌트로 보여주고자 합니다.\n\n만약 단순히 S3 에 PDF 파일을 업로드 했다면, `\u003cobject /\u003e` 에 연동한 **PDF 파일이 렌더링 되지 않고 다운로드되는 현상**을 마주하게 됩니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## PDF 파일이 다운로드만 되는 이유\n\nAWS S3 에 파일을 업로드할 경우, 별도의 설정을 하지 않는다면 아래와 같은 **Metadata** 기본값으로 설정됩니다.\n\n* `Content-Type: binary/octet-stream`\n* `Content-Disposition: attachment`\n\n\u003cbr /\u003e\n\n위와 같은 파일을 브라우저에서 요청할 경우, 해당 파일은 첨부파일로 인식하고 다운로드하는 동작을 하게 됩니다.\n\nAWS S3 에 업로드한 파일이 **단순 첨부파일 응답 으로 처리되기 때문에** `\u003cobject /\u003e` 태그에 렌더링되는 것이 아닌 다운로드가 됩니다.\n\n\u003cbr /\u003e\n\n이를 PDF 뷰어로 동작하도록 하려면, **AWS S3 에 업로드한 PDF 파일의 Metadata 를 아래와 같이 수정** 해서 해결할 수 있습니다.\n\n* `Content-Type: application/pdf`\n* `Content-Disposition: inline`\n\n\u003cbr /\u003e\n\n위와 같이 Metadata 를 변경했다면, `\u003cobject /\u003e` 태그에서 요청한 PDF 파일은 다운로드되지 않고 브라우저 내장 PDF 뷰어로 렌더링됩니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\n이번 이슈를 해결하기 위해, 최초 시도했던 방법은 AWS S3 에 PDF 파일을 별도로 요청한 후, 응답 결과인 PDF 파일 데이터를 `Blob` 으로 wrapping 하는 방식을 구현했습니다.\n\n하지만 이렇게 wrapping 한 Blob 은 파일내용에 따라 렌더링이 되지 않는 이슈가 발생하였습니다.\n\nBlob 으로 변환한 PDF 파일을 다운로드하여 확인하면 정상적으로 열리지만 `\u003cobject /\u003e` 태그에 렌더링되지 않는 경우가 있다보니, AWS S3 에 업로드한 파일의 Metadata 를 수정하는 방법을 사용하게 되었습니다.\n\n이번 이슈를 통해, 파일을 다루는 경우에는 Metadata 에 대한 확인 및 설정이 필요하다는 것을 배우게 되었습니다.\n"])</script><script>self.__next_f.push([1,"13:T1598,"])</script><script>self.__next_f.push([1,"---\nid: 4\ntitle: 'Nextjs 의 useRouter mock 정의하기'\ndescription: 'Nextjs 의 useRouter 를 사용하는 컴포넌트를 테스트하기 위한 방법을 정리합니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'jest',\n    '@testing-library',\n    'useRouter',\n    'next-router-mock',\n    '유닛 테스트',\n]\n\ncreatedAt: '2024-01-06 17:30:00'\nmodifiedHistories: []\n---\n\n# Nextjs 의 useRouter mock 정의하기\n\n페이지 이동을 위한 컴포넌트는 웹페이지에서 빠질 수 없는 컴포넌트 입니다.\n\nNextjs 프로젝트에서 페이지 이동은 Nextjs 의 `useRouter` hook 을 사용하여 구현합니다.\n\n이러한 컴포넌트는 내부에서 `useRouter` 를 사용하고 있기 때문에, Jest 의 `render()` 를 사용한 렌더링 시, 에러가 발생하게 됩니다.\n\n이번 포스팅에서는 `useRouter` 를 mocking 하여 테스트 하는 방법에 대해 정리하고자 합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 컴포넌트 렌더링 실패\n\n`useRouter` 를 사용하는 컴포넌트를 아무런 설정없이 Jest 의 `render()` 를 실행시키면, 렌더링 에러가 발생합니다.\n\n이는 테스트 환경에서 `useRouter()` 가 렌더링 되지 않으면서 발생하게 됩니다.\n\n이를 해결하기 위해, `next-router-mock` 라이브러리를 활용할 수 있습니다.\n\n```bash\nyarn add -D next-router-mock\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## `useRouter` 를 사용하는 테스트용 컴포넌트\n\n이번 포스트에서 테스트할 컴포넌트는 아래와 같습니다.\n\n`onClick()` 내부에서 `router.push()` 를 사용하여 페이지를 이동 시키는 동작을 합니다.\n\n```tsx title=\"MyAnchor.tsx\" showLineNumbers\nimport {\n    useCallback,\n    PropsWithChildren,\n} from 'react';\nimport {\n    useRouter,\n} from 'next/navigation';\n\ntype TMyAnchorProps = PropsWithChildren\u003c{\n    className?: string;\n    href: string;\n}\u003e;\n\nfunction MyAnchor(props: TMyAnchorProps) {\n    const {\n        className,\n        href,\n        children,\n    } = props;\n\n    const router = useRouter();\n\n    const onClick = useCallback(() =\u003e {\n        router.push(href);\n    }, [href]);\n\n    return (\n        \u003ca \n            className={className}\n            href={href}\u003e\n            {children}\n        \u003c/a\u003e\n    );\n}\n\nexport default MyAnchor;\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## `jest.mock()` 을 사용하여 `useRouter()` mocking 하기\n\n`jest.mock()` 을 사용하면, 특정 모듈을 mocking 할 수 있습니다.\n\n이를 활용하여, `next/navigation` 모듈을 mocking 하여 `useRouter` 가 테스트 환경에서 렌더링될 수 있도록 합니다.\n\n```ts title=\"jest.mock() 으로 useRouter mocking 하기\"\njest.mock('next/navigation', () =\u003e jest.requireActual('next-router-mock'));\n```\n\n* `jest.mock()`: 특정 모듈을 mocking 합니다.\n    * 첫번째 인자: mocking 할 모듈명\n    * 두번째 인자: mocking 반환 함수\n* `jest.requireActual()`: 실제 모듈을 가져옵니다. (`import`, `require`)\n\n\u003cbr /\u003e\n\n위 코드를 사용하여 `useRouter` 를 mocking 하게 되면, 정상적으로 렌더링됨을 확인할 수 있습니다.\n\n아래는 테스트 예시 코드 입니다.\n\n```tsx title=\"MyAnchor 테스트\" showLineNumbers {7, 9, 12-15, 48-50}\nimport MyAnchor from './MyAnchor';\nimport {\n    render,\n    screen,\n} from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport mockRouter from 'next-router-mock';\n\njest.mock('next/navigation', () =\u003e jest.requireActual('next-router-mock'));\n\ndescribe('\u003cMyAnchor /\u003e 테스트', () =\u003e {\n    beforeEach(() =\u003e {\n        // mockRouter 의 pathname 을 '/' 으로 초기화 합니다.\n        mockRouter.push('/');\n    });\n\n    it('DOM 에 렌더링 된다.', () =\u003e {\n        render(\n            \u003cdiv data-testid=\"test-MyAnchor\"\u003e\n                \u003cMyAnchor href=\"/test-url\"\u003e\n                    Test Page\n                \u003c/MyAnchor\u003e\n            \u003c/div\u003e\n        );\n\n        const $anchor = screen.getByTestId('test-MyAnchor');\n\n        expect($anchor).toBeInTheDocument();\n    });\n\n    it('click 시, href 경로로 페이지 이동한다.', async () =\u003e {\n        render(\n            \u003cdiv data-testid=\"test-MyAnchor\"\u003e\n                \u003cMyAnchor \n                    className=\"test-className\"\n                    href=\"test-url\"\u003e\n                    Test Page\n                \u003c/MyAnchor\u003e\n            \u003c/div\u003e\n        );\n\n        const $anchor = screen\n            .getByTestId('test-MyAnchor')\n            .querySelector('.test-className');\n\n        await userEvent.click($anchor);\n\n        expect(mockRouter).toMatchObject({\n            pathname: '/test-url',\n        });\n    });\n});\n```\n\n\u003cbr /\u003e\n\n그리고 `router` 가 클릭된 후, 페이지 이동이 되었는지 테스트하기 위해, `mockRouter` 를 활용할 수 있습니다.\n\n`mockRouter` 의 `pathname` 에 이동할 페이지의 url 이 반영되었다면, 실제로는 페이지 이동이 된 것으로 볼 수 있습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\n프레임워크는 개발에 필요한 다양한 기능을 제공합니다.\n\n이를 테스트하기 위해서는 프레임워크와 동일한 환경을 만들어주어야 함을 알게 되었습니다.\n\n단순 컴포넌트나 함수를 테스트할 때는 신경쓰지 않았던 **모듈 mocking** 이 필요하고, `jest.mock()` 을 사용하여 mocking 할 수 있었습니다.\n\n`next-router-mock` 라이브러리 처럼 오픈 소스 문화가 있기에 저도 웹 개발을 할 수 있음을 새삼 느끼게 됩니다. 🫠\n"])</script><script>self.__next_f.push([1,"14:T14bb,"])</script><script>self.__next_f.push([1,"---\nid: 3\ntitle: '\"styled-components\" 로 구현한 컴포넌트 테스트하기'\ndescription: '\"styled-components\" 를 사용한 컴포넌트를 테스트하기 위한 환경설정에 대해 알아봅니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'jest',\n    'styled-components',\n    '@testing-library',\n    '유닛 테스트',\n]\n\ncreatedAt: '2023-12-26 23:50:00'\nmodifiedHistories: []\n---\n\n# styled-components 로 구현한 컴포넌트 테스트하기\n\n컴포넌트의 style 작성에는 여러가지 선택지가 있습니다.\n\n그 중 저는 **styled-components** 를 가장 선호합니다.\n\n이번 포스팅에서는 **styled-components** 를 사용한 컴포넌트를 테스트하기 위한 jest 환경을 설정해보겠습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 설정없이 jest 를 실행하면? throw Error!\n\n**styled-components** 는 `\u003cThemeProvider /\u003e` 하위에서 사용할 수 있습니다.\n\n만약 추가 설정없이 jest 를 실행하게 되면, `render()` 호출에서 에러가 발생합니다.\n\n```tsx title=\"에러 발생 예시\" showLineNumbers {10-12}\nimport MyComponent from './MyComponent';\nimport {\n    render,\n} from '@testing-library/react';\n\ndescribe('MyComponent 테스트', () =\u003e {\n    it('DOM 에 렌더링 된다.', () =\u003e {\n        // render() 호출 시, Error 발생\n        render(\n            \u003cdiv data-testid=\"my-component\"\u003e\n                \u003cMyComponent /\u003e\n            \u003c/div\u003e\n        );\n\n        const $myComponent = screen.getByTestId('my-component');\n\n        expect($myComponent).toBeInTheDocument();\n    });\n});\n```\n\n```bash title=\"에러 메시지\"\nTypeError: Cannot read properties of undefined (reading 'MarkdownAnchor')\n```\n\n\u003cbr /\u003e\n\n아래와 같이 `render()` 호출부에 `\u003cThemeProvider /\u003e` 를 함께 넘겨주면 테스트가 정상적으로 실행되는 것을 확인할 수 있습니다.\n\n```tsx title=\"테스트 정상 동작\" showLineNumbers {11, 13}\nimport MyComponent from './MyComponent';\nimport {\n    render,\n} from '@testing-library/react';\n\ndescribe('MyComponent 테스트', () =\u003e {\n    it('DOM 에 렌더링 된다.', () =\u003e {\n        // render() 성공\n        render(\n            \u003cdiv data-testid=\"my-component\"\u003e\n                \u003cThemeProvier theme={theme}\u003e\n                    \u003cMyComponent /\u003e\n                \u003c/ThemeProvier\u003e\n            \u003c/div\u003e\n        );\n\n        const $myComponent = screen.getByTestId('my-component');\n\n        // 테스트 통과\n        expect($myComponent).toBeInTheDocument();\n    });\n});\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## util 또는 hook 으로 `\u003cThemeProvider /\u003e` 제공하기\n\n테스트 코드를 작성할 때, 각 테스트 케이스별로 중복되는 코드들이 생기게 됩니다.\n\n이러한 부분들을 공통 함수로 묶어내거나 추상화하지 않는 이유는, 테스트 코드를 읽어나가는 것으로 어떤 테스트를 수행하는지 파악할 수 있는 것이 더 테스트 코드의 가치를 높이기 때문입니다.\n\n\u003cbr /\u003e\n\n하지만 `\u003cThemeProvider /\u003e` 를 감싸는 코드는 **styled-components** 설정을 테스트하는 것이 아닌 이상, 특정 컴포넌트를 테스트하는데 의미를 두기 어렵습니다.\n\n그러므로 이 부분은 별도의 **util 함수** 또는 **custom hook** 으로 분리하여 사용해도 무방해 보입니다.\n\n\u003cbr /\u003e\n\n저는 **@testing-library** 에서 제공하는 `render()` 함수 처럼 `util 함수` 로 만드는 것이 좀 더 일관되는 패턴으로 생각하여 아래와 같이 작성해 보았습니다.\n\n```tsx title=\"@/utils/testing-library/renderTestComponent.tsx\" showLineNumbers\n// react\nimport { \n    ReactElement,\n} from 'react';\n// jest\nimport { \n    render,\n} from '@testing-library/react';\n// styled-components\nimport { \n    ThemeProvider,\n} from 'styled-components';\nimport theme from '@/styles/theme';\n\nconst renderTestComponent = (element: ReactElement) =\u003e {\n    const { rerender } = render(\n        \u003cThemeProvider theme={theme('light')}\u003e\n            {element}\n        \u003c/ThemeProvider\u003e\n    );\n\n    return {\n        rerender,\n    };\n};\n\nexport default renderTestComponent;\n```\n\n\u003cbr /\u003e\n\n이를 테스트 코드에 적용하면 다음과 같습니다.\n\n```tsx title=\"util 함수를 적용한 테스트 코드\" showLineNumbers {5, 10}\nimport MyComponent from './MyComponent';\n// import {\n//     render,\n// } from '@testing-library/react';\nimport renderTestComponent from '@/utils/testing-library/renderTestComponent';\n\ndescribe('MyComponent 테스트', () =\u003e {\n    it('DOM 에 렌더링 된다.', () =\u003e {\n        // render() 성공\n        renderTestComponent(\n            \u003cdiv data-testid=\"my-component\"\u003e\n                \u003cMyComponent /\u003e\n            \u003c/div\u003e\n        );\n\n        const $myComponent = screen.getByTestId('my-component');\n\n        // 테스트 통과\n        expect($myComponent).toBeInTheDocument();\n    });\n});\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\n유닛 테스트를 하나씩 추가하며, coverage 가 높아져 가는 것이 하나의 재미요소가 되었습니다.\n\n`renderTestComponent()` 처럼 테스트 환경을 위한 기능을 만드는 과정은 성취감과 연결되었습니다.\n\n이 블로그 프로젝트는 개발 초기 시점인 만큼, 모든 컴포넌트를 테스트할 수 있도록 목표를 잡아야겠습니다!\n"])</script><script>self.__next_f.push([1,"15:T15fe,"])</script><script>self.__next_f.push([1,"---\nid: 2\ntitle: '\"jest.fn()\" 으로 함수 테스트하기'\ndescription: '컴포넌트 props 로 넘겨주는 함수를 테스트하는 방법으로 \"jest.fn()\" 사용방법에 대한 정리 입니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'jest.fn',\n    'jest',\n    '@testing-library',\n    '유닛 테스트',\n]\n\ncreatedAt: '2023-12-23 14:45:00'\nmodifiedHistories: []\n---\n\n# \"jest.fn()\" 으로 함수 테스트하기\n\n컴포넌트에는 props 를 사용하여 데이터와 함수를 넘겨주도록 만들 수 있습니다.\n\n이번 포스팅에서는 `jest.fn()` 을 사용하여 컴포넌트에 넘겨준 함수가 정상동작하는지 테스트하는 방법에 대해 정리합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 컴포넌트 props 에 넘겨주는 함수\n\n컴포넌트 props 에는 함수를 넘겨줄 수 있습니다.\n\n사용자 인터렉션을 처리하기 위한 함수가 될 수도 있고, 특정 동작에 대한 callback 으로 활용되도록 구현할 수 있습니다.\n\n이렇게 넘겨준 함수가 의도한 시점, 상황에 호출이 되는지 테스트하고자 합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 테스트 예시 컴포넌트\n\n이번 포스팅에서 테스트에 사용할 input 컴포넌트를 만들어보겠습니다.\n\n```typescript title=\"./ChocobeInput.tsx\" showLineNumbers\nimport {\n    useCallback,\n    memo,\n    ChangeEvent,\n} from 'react';\n\ntype TChocobeButtonProps = {\n    value: string;\n    onChange: (value: string) =\u003e void;\n};\n\nfunction ChocobeInput(props: TChocobeInputProps) {\n    const {\n        value,\n        onChange,\n    } = props;\n\n    //\n    // callback\n    //\n    const onChangeInput = useCallback((e: ChangeEvent\u003cHTMLInputElement\u003e) =\u003e {\n        const value = e.target.value;\n        onChange(value);\n    }, [onChange]);\n\n    return (\n        \u003cinput\n            value={value}\n            onChange={onChangeInput} /\u003e\n    );\n}\n\nexport default memo(ChocobeInput);\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## `jest.fn()` 으로 onChange mockup function 만들기\n\n* 참고: [[Jest 공식 문서] Using a mock function](https://jestjs.io/docs/mock-functions#using-a-mock-function)\n\n`Jest` 는 `fn()` 이라는 **함수 mockup 메소드** 를 제공하고 있습니다.\n\n위 예시 컴포넌트를 테스트한다면, `props.onChange()` 를 테스트하기 위해 `jest.fn()` 을 사용하게 됩니다.\n\n```typescript title=\"jest.fn() 으로 mockup function 생성하기\" showLineNumbers {11, 16}\n// UI Components\nimport ChocobeInput from './ChocobeInput';\n// jest\nimport {\n    render,\n    screen,\n} from '@testing-library/react';\n\ndescribe('ChocobeInput 컴포넌트 테스트', () =\u003e {\n    it('ChocobeInput 에 값을 입력하면 onChange() 가 호출된다.', async () =\u003e {\n        const fn_onChange = jest.fn();\n\n        render(\n            \u003cChocobeInput\n                value=\"\"\n                onChange={fn_onChange} /\u003e\n        );\n    });\n});\n```\n\n\n\n\u003cbr /\u003e\n\n## input 요소에 KeyboardEvent 발생시키기\n\n`fn_onChange()` 함수는 `\u003cChocobeInput /\u003e` 컴포넌트에 `KeyboardEvent` 가 발생하면 호출되는 구조 입니다.\n\n`userEvent` 를 사용하여 `KeyboardEvent` 나 `click` 이벤트 등을 발생시킬 수 있으며, `\u003cChocobeInput /\u003e` 컴포넌트의 경우에는 `KeyboardEvent` 가 발생하면 `onChange()` 가 호출됩니다.\n\n컴포넌트에 `KeyboardEvent` 를 발생시키려면 `userEvent.type()` 메소드를 활용하게 됩니다.\n\n```typescript title=\"userEvent.type() 으로 KeyboardEvent 발생시키기\" showLineNumbers {24}\n// UI Components\nimport ChocobeInput from './ChocobeInput';\n// jest\nimport {\n    render,\n    screen,\n} from '@testing-library/react';\nimport {\n    userEvent,\n} from '@testing-library/user-event';\n\ndescribe('ChocobeInput 컴포넌트 테스트', () =\u003e {\n    it('ChocobeInput 에 값을 입력하면 onChange() 가 호출된다.', async () =\u003e {\n        const fn_onChange = jest.fn();\n\n        render(\n            \u003cChocobeInput\n                value=\"\"\n                onChange={fn_onChange} /\u003e\n        );\n\n        const $chocobeInput = screen.getByRole('textbox');\n\n        await userEvent.type($chocobeInput, 'Hello');\n    });\n});\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## KeyboardEvent 에 의해 fn_onClick() 호출 여부 테스트하기\n\n위 예시 코드를 통해 `\u003cChocobeInput /\u003e` 컴포넌트에 `KeyboardEvent` 가 발생한 상태 입니다.\n\n`userEvent.type(요소, 입력값)` 으로 넘겨준 `입력값` 은 문자 1개당 1번의 KeyboardEvent 가 발생하게 되므로, 총 5번의 KeyboardEvent 가 발생한 상태 입니다.\n\n이를 테스트하면 다음과 같습니다.\n\n```typescript title=\"발생한 이벤트 테스트\" showLineNumbers\n// UI Components\nimport ChocobeInput from './ChocobeInput';\n// jest\nimport {\n    render,\n    screen,\n} from '@testing-library/react';\nimport {\n    userEvent,\n} from '@testing-library/user-event';\n\ndescribe('ChocobeInput 컴포넌트 테스트', () =\u003e {\n    it('ChocobeInput 에 값을 입력하면 onChange() 가 호출된다.', async () =\u003e {\n        const fn_onChange = jest.fn();\n\n        render(\n            \u003cChocobeInput\n                value=\"\"\n                onChange={fn_onChange} /\u003e\n        );\n\n        const $chocobeInput = screen.getByRole('textbox');\n\n        await userEvent.type($chocobeInput, 'Hello');\n\n        expect(fn_onChange).toHaveBeenCalledTimes(5);\n    });\n});\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\n함수 테스트는 `jest.fn()` 뿐만 아니라 `jest.spyOn()` 으로도 가능합니다.\n\n다음 포스팅에서는 `jest.spyOn()` 으로 테스트하는 방법과 `jest.fn()` 과 차이점에 대해 정리하겠습니다.\n"])</script><script>self.__next_f.push([1,"16:T1e27,"])</script><script>self.__next_f.push([1,"---\nid: 1\ntitle: LLMOps 와 친해지기 1 - 용어 정리\ndescription: 'AI 학습 모델인 Large Language Model 에 대한 정리입니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: []\n\ncreatedAt: '2023-12-16 15:00:00'\nmodifiedHistories: []\n---\n\n# LLMOps 와 친해지기 1 - 용어 정리\n\n**LLMOps** 란, Large Language Model 의 약자이며 대규모 언어 모델 입니다.\n\n사내 신규 프로젝트로 **LLMOps** 를 사용하기 위한 UI 툴 서비스를 개발하게 되었습니다.\n\n개발할 서비스에 대한 도메인 지식이 필요함을 느끼게 되었기에, 관련 용어와 개념을 정리하고자 합니다.\n\n일반인의 시야에서 조사한 내용을 정리하는 목적을 가지고 LLM 에 초점을 가지므로, 좀 더 정확한 내용은 첨부한 **참고 링크** 를 확인해주세요.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 용어 정리\n\n### 머신러닝\n\n\u003e 참고: [Machine learning (ML) –  머신러닝 이란?](https://www.ibm.com/kr-ko/topics/machine-learning)\n\n\u003cbr /\u003e\n\n기계학습 방법을 말합니다.\n\n**딥러닝** 이 아닌 **머신러닝** 은 정형화된 데이터를 학습하며 사람의 개입이 많이 필요합니다.\n\n정형화된 데이터란 데이터 각각에 대하여 **labeling** 이나 **tagging** 작업을 한 학습 데이터를 말합니다.\n\n데이터가 많을수록 좋은 결과를 기대할 수 있기 때문에, 정형화된 데이터를 만드는 과정부터 많은 시간과 노력이 필요하게 됩니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n### 딥러닝\n\n\u003e 참고: [Machine learning (ML) –  머신러닝 이란?](https://www.ibm.com/kr-ko/topics/machine-learning)\n\n\u003cbr /\u003e\n\n머신러닝의 하위 분야이며, 머신러닝 처럼 정형화된 데이터로 학습할 수 있으며, 추가로 비정형 데이터를 학습할 수도 있습니다.\n\n비정형 데이터 학습을 위해 사용되는 개념으로 **신경망** 이 있습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n### 신경망\n\n\u003e 참고: [AWS - 신경망이란 무엇인가요?](https://aws.amazon.com/ko/what-is/neural-network/)\n\u003e\n\u003e 참고: [Machine learning (ML) –  머신러닝 이란?](https://www.ibm.com/kr-ko/topics/machine-learning)\n\n\u003cbr /\u003e\n\n신경망은 머신러닝의 하위 분야이며 딥러닝의 기계 학습 알고리즘 중 하나입니다.\n\n신경망은 구조화 되지 않은 데이터와 명시적이지 않은 훈련 방식을 사용하며, 이렇게 학습한 데이터를 **일반화** 하고 **추론** 할 수 있습니다.\n\n예를 들면 다음과 같습니다.\n\n```bash\n질문1: \"결제 방법을 알려줘\"\n\n질문2: \"비용 송금 방법을 알려줘\"\n```\n\n위 질문은 문장은 다르지만, 컴퓨터는 신경망을 통해 \"결제 방법 안내\" 라는 동일한 문맥임을 이해합니다.\n\n\u003cbr /\u003e\n\n신경망은 **노드** 로 구성되며, 노드에는 **입력 노드**, **출력 노드** 등, 무수히 많은 노드로 구성됩니다.\n\n각 노드는 **관련성에 대한 임계치** 가 있으며, 임계치에 다다르면 활성화 되는데, 이러한 방식으로 관련된 노드들의 활성화를 통해 **일반화** 와 **추론** 을 할 수 있게 됩니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n### MLOps\n\n\u003e 참고: [MLOps란?](https://www.ibm.com/kr-ko/topics/machine-learning)\n\n\u003cbr /\u003e\n\n**MLOps** 는 **Machine Learning** 과 **Operations** 의 합성어로, 효율적인 머신러닝 **모델 개발**, **배포**, **운용** 을 위한 개발 방법론이며, **새로운 모델 개발이 목적** 입니다.\n\n**MLOps** 를 구성하는 요소는 다음과 같습니다.\n\n* 지속적 통합 (**CI**: Continuous Integration)\n* 지속적 배포 (**CD**: Continuous Deployment)\n* 지속적 학습 (**CT**: Continuous Training)\n\n\n\n\u003cbr /\u003e\n\n\n\n### FMOps\n\n\u003e 참고: [카카오엔터프라이즈 기술블로그 Tech\u0026(테크앤):티스토리](https://tech.kakaoenterprise.com/196)\n\n**FM(Foundation Model)** 을 한국어로 **기반 모델** 이라고 합니다.\n\n**FMOps(Foundation Model Operations)** 는 **기반 모델 개발**, **배포**, **운용** 을 위한 개발 방법론 입니다.\n\n**FMOps(Foundation Model Operations)** 에는 자연어 뿐만 아니라, 이미지나 음성을 기반으로 하는 모델(예시: **DALL-E**) 을 모두 포함합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n### LLMOps\n\n\u003e 참고: [카카오엔터프라이즈 기술블로그 Tech\u0026(테크앤):티스토리](https://tech.kakaoenterprise.com/196)\n\n\u003cbr /\u003e\n\n**FMOps** 에 포함되는 개념이며, **자연어 처리** 를 위한 개념으로 **LLM(Large Language Model)** 이 있습니다.\n\n**LLMOps(Large Langague Model Operations)** 는 **LLM 개발**, **배포**, **운용** 을 위한 개발 방법론입니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n### MLOps 와 FMOps 비교\n\n\u003e 참고: [카카오엔터프라이즈 기술블로그 Tech\u0026(테크앤):티스토리](https://tech.kakaoenterprise.com/196)\n\n\u003cbr /\u003e\n\n* 목적\n    * MLOps: **새로운 모델을 개발** 합니다.\n    * FMOps: 이미 학습이 완료된 모델과 자신의 데이터를 사용하여, **자신만의 AI 앱을 개발** 합니다.\n* 다루는 모델 유형\n    * MLOps: 기업이 직접 모델과 파이프라인 모두 개발하게 됩니다.\n    * FMOps: **API 를 통해서 원하는 모델을 사용** 합니다.\n* 산출물\n    * MLOps: **Model** 과 이를 사용할 수 있는 **API** 를 만들게 됩니다.\n    * FMOps: LLM 과 사용자의 커스텀 데이터를 사용한 **AI 어플리케이션** 을 만들게 됩니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n### 프롬프트\n\n\u003e [프롬프트 (Prompt) 란 무엇인가? - 정의, 원리, fine tuning](https://www.thedatahunt.com/trend-insight/what-is-prompt)\n\n\u003cbr /\u003e\n\n개발 환경에서는 다양한 설정과 실행방법이 있습니다.\n\n이를 UI 로 모두 제공하는 것은 어렵기도 하고, 사용성도 복잡해집니다.\n\n그래서 CLI 를 사용하는 경우가 많습니다.\n\n프롬프트란, 컴퓨터에게 실행할 태스크를 전달하는 메시지, **명령어** 라는 의미를 가집니다.\n\nAI 가 발전함에 따라 현재는 명령어뿐만 아니라, 자연어까지 컴퓨터가 이해할 수 있게 되어서, 프롬프트의 의미는 **컴퓨터에게 어떤 태스크를 수행할지 전달하는 자연어 메시지** 라는 의미로 확장되었습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n### 프롬프트 체이닝\n\n\u003e 참고: [카카오엔터프라이즈 기술블로그 Tech\u0026(테크앤):티스토리](https://tech.kakaoenterprise.com/196)\n\n\u003cbr /\u003e\n\n프롬프트를 잘 작성할수록 AI 는 더 정확한 응답을 할 수 있습니다.\n\nLLM 에 하나의 프롬프트를 연결하여 AI 앱을 만들수도 있지만, 더 정확한 기능을 구현하기 위해 LLM 에 외부의 프롬프트를 포함하여 복수의 프롬프트를 연결하여 개발하게 되는데, 이를 **프롬프트 체이닝(Prompt Chaing)** 이라고 합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n### LangChain\n\n\u003e 참고: [카카오엔터프라이즈 기술블로그 Tech\u0026(테크앤):티스토리](https://tech.kakaoenterprise.com/196)\n\n\u003cbr /\u003e\n\n**LangChain** 은 **프롬프트 체이닝** 을 지원하는 프레임워크 입니다.\n\nLLM 과 외부의 프롬프트들을 자유롭게 연결할 수 있는 기능을 제공합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n### LLM 앱 개발 플렛폼\n\nLLM 과 LangChain 을 사용하여 AI 앱을 만들 수 있는 플렛폼이 있습니다. (프롬프트 체이닝 서비스 플렛폼)\n\n대표적으로 **LangFlow** 와 **FlowiseAI** 가 있습니다.\n\n\u003cbr /\u003e\n\n* LangFlow:\n    * [LangFlow Github](https://github.com/logspace-ai/langflow)\n    * 서버: `Python`\n    * 프론트: `React(Typescript)`\n* FlowiseAI\n    * [FlowiseAI Github](https://github.com/FlowiseAI/Flowise)\n    * 서버: `Express(Typescript)`\n    * 프론트: `React(Javascript)`\n"])</script><script>self.__next_f.push([1,"17:T1d77,"])</script><script>self.__next_f.push([1,"---\nid: 1\ntitle: Nextjs 프로젝트의 유닛 테스트\ndescription: '유닛 테스트를 위해 Jest 와 @testing-library 설치 및 설정에 대한 정리 입니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'nextjs',\n    'jest',\n    '@testing-library',\n    'react',\n    '유닛 테스트',\n]\n\ncreatedAt: '2023-12-16 22:13:00'\nmodifiedHistories: []\n---\n\n# Nextjs 프로젝트의 유닛 테스트\n\n* 참고: [Next.js with React Testing Library, Jest, and TypeScript](https://medium.com/readytowork-org/next-js-with-react-testing-library-jest-and-typescript-a6aa11b85434)\n* 참고: [Nextjs 공식문서](https://nextjs.org/docs/pages/building-your-application/testing/jest)\n\n\n\n\u003cbr /\u003e\n\n\n\n\u003cdetails\u003e\n\u003csummary\u003e유닛 테스트를 멀리한 핑계와 결심\u003c/summary\u003e\n\n\u003cbr /\u003e\n\n스타트업에 재직하며 다양한 프로젝트를 개발하고 있습니다.\n\n진행했던 프로젝트를 되돌아보면, 한결같이 시간이 부족하였고, 이를 핑계삼아 유닛 테스트 없이 기능 구현만을 하였습니다.\n\n\u003cbr /\u003e\n\n### 🤪 유닛 테스트 없이도 개발 가능한데?\n\n테스트에 관한 블로그 글이나 **클린코드** 와 같은 책에서 언급한 **코드에 대한 신뢰도** 는 사실 체감을 하지 못하였습니다.\n\n오히려 유닛 테스트 작성 때문에 기능 구현할 시간을 뺏긴다는 느낌이 컸고, 유닛 테스트 없이도 기능 개발은 충분히 가능했습니다.\n\n\u003cbr /\u003e\n\n### 😰 `console.log` 와 수작업 테스트 노가다...\n\n기능 개발을 완료한 후, 기억이 흐릿해질 정도로 시간이 지나서 기능 추가/수정 작업이 생겼습니다.\n\n기억을 상기하기 위해 여기 저기에 `console.log()` 를 작성하였고, 기능 추가 후에는 남아있는 `console.log()` 를 제거하는 귀찮은 작업들이 남게 되었습니다.\n\n사실 함수명, 메소드명, 변수명 등이 모두 명확하고, 모든 코드가 서로 의존성 없이 독립적인 기능을 한다면 `console.log()` 로 확인하는 작업이 필요 없을 수 있습니다.\n\n하지만 기능이 언제나 단순 명료하게 구현될 수 없고, 더더욱 이 코드를 작성한 저의 코드 품질에 부족함이 많기 때문에 `console.log()` 노가다와 함께할 가능성이 보였습니다.\n\n**그리고 가장 큰 문제는, 변경된 기능이 다른 부분에 영향을 미치는지, 버그를 찾기위한 반복된 수작업 테스트를 하게 되었습니다.**\n\n기능을 추가하는 코드 베이스가 클 수록, 수작업 테스트는 상당한 시간을 소비하게 하였습니다.\n\n\u003cbr /\u003e\n\n### 🤓 유닛 테스트를 사용한 테스트 자동화가 필요해!\n\n만약 유닛 테스트를 작성해 두었다면, 아래와 같은 보상이 있었다고 생각됩니다.\n\n* 현재 코드가 테스트에 통과하고 있으므로, 적어도 작성된 **Test Case** 내에서는 신뢰할 수 있는 코드다.\n* 테스트 대상이 지원하는 모든 기능과 `porps` 에 대하여, 독립적인 **Use Case** 를 확인할 수 있다.\n* **수정한 코드가 의도한 부분에만 적용됨을 보장 받을 수 있다.**\n\n\u003cbr /\u003e\n\n위와 같은 기대값을 가지며, **유닛 테스트에 대한 결심** 을 하게 되었습니다.\n\n\u003c/details\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 유닛 테스트 라이브러리 설치\n\n유닛 테스트를 위해, `jest` 와 `@testing-library` 를 사용하고자 합니다.\n\n```bash title=\"jest 관련 패키지\"\nyarn add -D jest ts-jest ts-node jest-environment-jsdom @types/jest\n```\n\n```bash title=\"@testing-library 관련 패키지\"\nyarn add -D @testing-library/jest-dom @testing-library/react @testing-library/user-event\n```\n\n\n\u003cbr /\u003e\n\n\n\n## jest 실행을 위한 명령어 추가하기\n\n`package.json` 의 `scripts` 를 통해 프로젝트에 대한 명령어를 추가할 수 있습니다.\n\n단발성 테스트를 위한 명령어와 코드 변경마다 테스트를 실행하는 명령어를 추가합니다.\n\n```json title=\"package.json\" {5-7}\n{\n    // ...\n    \"scripts\": {\n        // ...\n        \"test\": \"jest\",\n        \"test:watch\": \"jest --watch\",\n        \"test:watchAll\": \"jest --watchAll\"\n    },\n    // ...\n}\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## jest 설정하기\n\n[Nextjs 공식 문서](https://nextjs.org/docs/pages/building-your-application/testing/jest#manual-setup) 에서도 **jest** 와 **@testing-library** 를 사용하는 방법에 대해 안내하고 있습니다.\n\n\u003cbr /\u003e\n\n**jest.config.ts** 파일을 사용하여 설정할 수 있습니다.\n\n직접 파일을 생성하지 않고, CLI 를 통해 설정 템플릿을 생성하여 수정하는 방향으로 설정하겠습니다.\n\n터미널에서 아래의 명령을 실행합니다.\n\n```bash title=\"npm 으로 jest.config.ts 생성하기\"\nnpm init jest@latest\n```\n\n```bash title=\"yarn 으로 jest.config.ts 생성하기\"\nyarn create jest@latest\n```\n\n\u003cbr /\u003e\n\n명령을 실행하면, 몇가지 질문(Y/N)으로 기본 설정값이 반영된 **jest.config.ts** 파일이 생성됩니다.\n\n생성된 **jest.config.ts** 를 아래와 같이 수정합니다.\n\n```typescript showLineNumbers\nimport {\n    Config,\n} from 'jest';\nimport nextJest from 'next/jest.js';\n\nconst createJestConfig = nextJest({\n    dir: './',\n});\n\n/**\n * For a detailed explanation regarding each configuration property, visit:\n * https://jestjs.io/docs/configuration\n */\n\nconst config: Config = {\n    // The directory where Jest should output its coverage files\n    coverageDirectory: \"coverage\",\n\n    // Indicates which provider should be used to instrument code for coverage\n    coverageProvider: \"babel\",\n\n    // A preset that is used as a base for Jest's configuration\n    preset: \"ts-jest\",\n\n    // A list of paths to modules that run some code to configure or set up the testing framework before each test\n    setupFilesAfterEnv: [\"\u003crootDir\u003e/jest.setup.ts\"],\n\n    // The test environment that will be used for testing\n    testEnvironment: \"jest-environment-jsdom\",\n};\n\nexport default createJestConfig(config);\n```\n\n\u003cbr /\u003e\n\n`jest.config.ts` 파일의 **26번줄** 에서 설정한 **jest.setup.ts** 파일을 생성하고 아래의 코드를 작성합니다.\n\n```typescript title=\"jest.setup.ts\"\nimport '@testing-library/jest-dom';\n```\n\n**jest.setup.ts** 에서 `import` 하는 모듈은 **@testing-library** 에서 제공하는 **확장 matcher** 를 사용할 수 있게 해줍니다.\n\n이로써 Nextjs 의 유닛 테스트 설정을 완료 하였습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 첫번째 컴포넌트 테스트 만들기\n\n먼저 테스트를 할 React 컴포넌트를 만들겠습니다.\n\n```tsx title=\"Hello.tsx\"\nfunction Hello() {\n    return (\n        \u003ch1\u003e\n            Hello World\n        \u003c/h1\u003e\n    );\n}\n\nexport default Hello;\n```\n\n\u003cbr /\u003e\n\n*Hello.tsx* 와 동일한 경로에 **Hello.spec.tsx** 파일을 생성하고, 유닛 테스트를 작성합니다.\n\n```typescript title=\"Hello.spec.tsx\"\nimport Hello from './Hello';\nimport {\n    render,\n    screen,\n} from '@testing-library/react';\n\ndescribe('\u003cHello /\u003e 컴포넌트 유닛 테스트', () =\u003e {\n    it('Dom 에 렌더링 됨', () =\u003e {\n        render(\u003cHello /\u003e);\n\n        const $hello = screen.getByRole('heading', {\n            level: 1,\n        });\n\n        expect($hello).toBeInTheDocument();\n    });\n});\n```\n\n\u003cbr /\u003e\n\n유닛 테스트를 작성한 후, 터미널에 아래의 명령어로 테스트를 실행할 수 있으며, 모든 테스트가 통과됨을 확인할 수 있습니다.\n\n```bash title=\"jest 실행하기\"\nyarn test\n```\n"])</script><script>self.__next_f.push([1,"18:T2361,"])</script><script>self.__next_f.push([1,"---\nid: 1\ntitle: Custom Hook 으로 분리하며 발생한 실수\ndescription: 'Custom Hook 으로 분리한 useEffect 가 여러번 호출 케이스 중 한가지를 정리합니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'react',\n    'custom hook',\n]\n\ncreatedAt: '2023-12-19 22:50:00'\nmodifiedHistories: []\n---\n\n# Custom Hook 으로 분리하며 발생한 실수\n\n## 실수가 발생한 상황\n\n페이지가 mount 되면 API 를 호출하는 흐름은 빈번히 사용됩니다.\n\n그리고 API 응답을 받으면, 후처리를 하는 `useEffect` 를 사용할 수 있습니다.\n\n\u003cbr /\u003e\n\n이번 이슈에서는 Custom Hook 으로 나누기 전까지는 의도한 대로 API 응답과 Effect 가 1:1 로 실행되었습니다.\n\n```tsx title=\"MyPage.tsx\" showLineNumbers {28-30, 32-34}\nimport {\n    useCallback,\n    useEffect,\n} from 'react';\nimport {\n    useAppSelector,\n} from '@/redux/hooks';\n\nfunction MyPage() {\n    const triggerState = useAppSelector(({ triggerState }) =\u003e triggerState);\n\n    const responseOfApi_1 = useAppSelector(({ api_1 }) =\u003e api_1);\n    const responseOfApi_2 = useAppSelector(({ api_2 }) =\u003e api_2);\n\n    const callApi_1 = useCallback(() =\u003e {\n        // API 호출 1\n    }, []);\n\n    const callApi_2 = useCallback(() =\u003e {\n        // API 호출 2\n    }, []);\n\n    useEffect(function handleTriggerState() {\n        callApi_1();\n        callApi_2();\n    }, [triggerState]);\n\n    useEffect(function onSuccessApi_1() {\n        // API 1 응답 후처리\n    }, [responseOfApi_1]);\n\n    useEffect(function onSuccessApi_2() {\n        // API 2 응답 후처리\n    }, [responseOfApi_2]);\n\n    return (\n        // ...\n    );\n}\n\nexport default MyPage;\n```\n\n\u003cbr /\u003e\n\n이런 방식으로 **호출하는 API 가 늘어나자, 컴포넌트가 점점 복잡해졌습니다.**\n\n**또한 사용자 인터렉션에 의해 다시 호출해야 하는 API 도 있어서** Custom Hook 으로 분리하여 재사용하는 방향으로 생각하게 되었습니다.\n\n\u003cbr /\u003e\n\n리펙토링 결과, API 후처리를 담당하는 `useEffect` 가 번복 실행되는 현상이 나타났습니다.\n\n```tsx title=\"./hooks/useApi_1.ts\" showLineNumbers {16-18}\nimport {\n    useCallback,\n    useEffect,\n} from 'react';\nimport {\n    useAppSelector\n} from '@/redux/hooks';\n\nconst useApi_1 = () =\u003e {\n    const responseOfApi_1 = useAppSelector(({ api_1 }) =\u003e api_1);\n\n    const callApi_1 = useCallback(() =\u003e {\n        // API 호출 1\n    }, []);\n\n    useEffect(function onSuccessApi_1() {\n        // (번복 실행됨) API 1 응답 후처리\n    }, [responseOfApi_1]);\n\n    return {\n        callApi_1,\n    };\n};\n\nexport default useApi_1;\n```\n\n```tsx title=\"./hooks/useApi_2.ts\" showLineNumbers {16-18}\nimport {\n    useCallback,\n    useEffect,\n} from 'react';\nimport {\n    useAppSelector\n} from '@/redux/hooks';\n\nconst useApi_2 = () =\u003e {\n    const responseOfApi_2 = useAppSelector(({ api_2 }) =\u003e api_2);\n\n    const callApi_2 = useCallback(() =\u003e {\n        // API 호출 2\n    }, []);\n\n    useEffect(function onSuccessApi_2() {\n        // (번복 실행됨) API 2 응답 후처리\n    }, [responseOfApi_2]);\n\n    return {\n        callApi_2,\n    };\n};\n\nexport default useApi_2;\n```\n\n```tsx title=\"MyPage.tsx\" showLineNumbers {10-11, 13-16}\nimport {\n    useEffect,\n} from 'react';\nimport useApi_1 from './hooks/useApi_1';\nimport useApi_2 from './hooks/useApi_2';\n\nfunction MyPage() {\n    const triggerState = useAppSelector(({ triggerState }) =\u003e triggerState);\n\n    const { callApi_1 } = useApi_1();\n    const { callApi_2 } = useApi_2();\n\n    useEffect(function onSuccessApi_2() {\n        callApi_1();\n        callApi_2();\n    }, [triggerState]);\n\n    return (\n        // ...\n    );\n};\n\nexport default MyPage;\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## useEffect 의 dependencies 는 무죄\n\n`useEffect` 의 `dependencies` 는 redux 에서 가져온 state 였습니다.\n\n(위의 예시 코드에서는 `triggerState` 로 표현하였습니다.)\n\n**`triggerState` 에 의도치 않은 mutate 가 발생하는 것인가** 라고 생각했지만, 이는 아니였습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## Custom Hook 을 재사용한 만큼 번복되는 useEffect\n\nCustom Hook 으로 분리하는 단위를 **특정 API 호출 함수** 와 **해당 API 응답 후처리 Effect** 로 묶어서 구성하였습니다.\n\n그리고 필요한 곳에서 재사용을 하였습니다.\n\n\u003cbr /\u003e\n\n결과적으로 재사용한 횟수만큼 `useEffect` 가 번복 실행된 것입니다.\n\nCustom Hook 은 사용하는 곳에 scope 를 만드는 것이므로, 당연한 결과임에도 알아차리지 못하였습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## API 호출함수와 Effect 를 분리한 Custom Hook 으로 이슈 해결\n\n원인을 찾은 후, API 의 후처리를 담당하는 `useEffect` 를 Custom Hook 에서 빼고, 기존의 `MyPage` 에 위치시켰습니다.\n\n그러자 번복되는 `useEffect` 이슈는 해결 되었습니다.\n\n\n```tsx title=\"./hooks/useApi_1.ts\" showLineNumbers {15-17}\nimport {\n    useCallback,\n} from 'react';\nimport {\n    useAppSelector\n} from '@/redux/hooks';\n\nconst useApi_1 = () =\u003e {\n    const responseOfApi_1 = useAppSelector(({ api_1 }) =\u003e api_1);\n\n    const callApi_1 = useCallback(() =\u003e {\n        // API 호출 1\n    }, []);\n\n    // useEffect(function onSuccessApi_1() {\n    //     // API 1 응답 후처리\n    // }, [responseOfApi_1]);\n\n    return {\n        callApi_1,\n    };\n};\n\nexport default useApi_1;\n```\n\n```tsx title=\"./hooks/useApi_2.ts\" showLineNumbers {15-17}\nimport {\n    useCallback,\n} from 'react';\nimport {\n    useAppSelector\n} from '@/redux/hooks';\n\nconst useApi_2 = () =\u003e {\n    const responseOfApi_2 = useAppSelector(({ api_2 }) =\u003e api_2);\n\n    const callApi_2 = useCallback(() =\u003e {\n        // API 호출 2\n    }, []);\n\n    // useEffect(function onSuccessApi_2() {\n    //     // API 2 응답 후처리\n    // }, [responseOfApi_2]);\n\n    return {\n        callApi_2,\n    };\n};\n\nexport default useApi_2;\n```\n\n```tsx title=\"MyPage.tsx\" showLineNumbers {20-22, 24-26}\nimport {\n    useEffect,\n} from 'react';\nimport useApi_1 from './hooks/useApi_1';\nimport useApi_2 from './hooks/useApi_2';\n\nfunction MyPage() {\n    const triggerState = useAppSelector(({ triggerState }) =\u003e triggerState);\n\n    const { callApi_1 } = useApi_1();\n    const { callApi_2 } = useApi_2();\n\n    useEffect(function onSuccessApi_2() {\n        callApi_1();\n        callApi_2();\n\n        // eslint-disable-next-line\n    }, [triggerState]);\n\n    useEffect(function onSuccessApi_1() {\n        // API 1 응답 후처리\n    }, [responseOfApi_1]);\n\n    useEffect(function onSuccessApi_2() {\n        // API 2 응답 후처리\n    }, [responseOfApi_2]);\n\n    return (\n        // ...\n    );\n};\n\nexport default MyPage;\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## MyPage 에서 API 후처리를 담당하는 useEffect 분리\n\n위 코드처럼 리펙토링한 이후, 의도한 동작은 되었습니다.\n\n하지만, **MyPage.tsx 파일을 열어보기 전까지는 API 후처리를 어디서 하는지 파악하기가 어렵다고 느껴졌습니다.**\n\n\u003cbr /\u003e\n\n그래서 MyPage.tsx 의 **API 후처리 Effect 들을 Custom Hook 으로** 나눠보기로 하였습니다.\n\n```ts title=\"./hooks/useMyPageApiEffects.ts\" showLineNumbers {9-11, 13-15}\nimport {\n    useEffect,\n} from 'react';\n\nconst useMyPageApiEffects = () =\u003e {\n    const responseOfApi_1 = useAppSelector(({ api_1 }) =\u003e api_1);\n    const responseOfApi_2 = useAppSelector(({ api_2 }) =\u003e api_2);\n\n    useEffect(function onSuccessApi_1() {\n        // API 1 응답 후처리\n    }, [responseOfApi_1]);\n\n    useEffect(function onSuccessApi_2() {\n        // API 2 응답 후처리\n    }, [responseOfApi_2]);\n}\n\nexport default useMyPageApiEffects;\n```\n\n```tsx title=\"MyPage.tsx\" showLineNumbers {13}\nimport {\n    useEffect,\n} from 'react';\nimport useApi_1 from './hooks/useApi_1';\nimport useApi_2 from './hooks/useApi_2';\nimport useMyPageApiEffects from './hooks/useMyPageApiEffects';\n\nfunction MyPage() {\n    const triggerState = useAppSelector(({ triggerState }) =\u003e triggerState);\n\n    const { callApi_1 } = useApi_1();\n    const { callApi_2 } = useApi_2();\n    useMyPagteApiEffects();\n\n    useEffect(function onSuccessApi_2() {\n        callApi_1();\n        callApi_2();\n    }, [triggerState]);\n\n    return (\n        // ...\n    );\n};\n\nexport default MyPage;\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\n여기까지 수정한 결과, MyPage.tsx 에서 API 에 대한 후처리 Effect 가 있다는 것을 파일 목록을 통해서도 파악할 수 있게 되었습니다.\n\n개인적으로는 위와 같은 구조의 Custom Hook 이 마음에 들었습니다.\n\n이렇게 분리한 Custom Hook 은 아래와 같은 파일 구조가 되었습니다.\n\n```bash\n└── MyPage\n    ├── MyPage.tsx\n    └── hooks\n        ├── useApi_1.ts\n        ├── useApi_2.ts\n        └── useMyPageApiEffects.ts\n``` \n\n\u003cbr /\u003e\n\n사소한 실수에 의한 이슈라서 자책 포인트가 되었지만, Custom Hook 으로 분리하는 구조를 생각할 수 있는 계기가 되어서 성취감이 느껴졌습니다.\n"])</script><script>self.__next_f.push([1,"19:T2862,"])</script><script>self.__next_f.push([1,"---\nid: 5\ntitle: 그림자 표현하기\ndescription: '그림자 설정방법과 특징에 대해 정리합니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    'javascript',\n    '3d',\n    'shadow',\n]\n\ncreatedAt: '2024-01-07 23:50:00'\nmodifiedHistories: []\n---\n\n# 그림자 표현하기\n\n그림자를 표현하기 위해서는 물체와 조명의 각도, 그림자의 크기, 형태 등의 상호작용 연산이 필요합니다.\n\n그래서 Three.js 의 그림자 설정의 기본값은 모두 미사용으로 설정되어 있습니다.\n\n이 덕분에 개발자가 원하는 조명과 원하는 물체의 그림자를 직접 지정하여 표현할 수 있습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 예시 코드\n\n이전 포스팅에서 바닥(땅) 을 만들었던 코드에 그림자 설정을 추가해 보겠습니다.\n\n```js title=\"예시 코드\" showLineNumbers\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n\n    Mesh,\n    MeshStandardMaterial,\n    SphereGeometry,\n    PlaneGeometry,\n\n    Color,\n    HemisphereLight,\n    HemisphereLightHelper,\n    DirectionalLight,\n    DirectionalLightHelper,\n} from 'three';\nimport {\n    OrbitControls,\n} from 'three/examples/jsm/controls/OrbitControls';\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { OrbitControls } */\nlet controls;\n\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n    $canvas.width = window.innerWidth;\n    $canvas.height = window.innerHeight;\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\nfunction initScene() {\n    scene = new Scene();\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n    camera.fov = 35;\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.position.set(0, 0, 12);\n\n    camera.updateProjectionMatrix();\n}\n\nfunction initControls($canvas) {\n    controls = new OrbitControls(camera, $canvas);\n    controls.enableDamping = true;\n}\n\nfunction initHemisphereLight() {\n    const skyColor = new Color('#fff');\n    const groundColor = new Color('#000');\n    const light = new HemisphereLight(\n        skyColor,\n        groundColor,\n        0.75\n    );\n\n    const helper = new HemisphereLightHelper(light);\n\n    scene.add(light);\n    scene.add(helper);\n}\n\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n    const light = new DirectionalLight(color);\n    light.position.set(2, 2, 2);\n\n    const helper = new DirectionalLightHelper(light);\n\n    scene.add(light);\n    scene.add(helper);\n}\n\nfunction initSphereMesh() {\n    const geometry = new SphereGeometry();\n    const material = new MeshStandardMaterial();\n    const sphere = new Mesh(geometry, material);\n\n    scene.add(sphere);\n}\n\nfunction initPlaneMesh() {\n    const geometry = new PlaneGeometry(10, 10);\n    const material = new MeshStandardMaterial();\n    const plane = new Mesh(geometry, material);\n    plane.position.set(0, -1, 0);\n    plane.rotation.set(\n        Math.PI * -0.5,\n        0,\n        0\n    );\n\n    scene.add(plane);\n}\n\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n}\n\nfunction render() {\n    window.requestAnimationFrame(render);\n\n    renderer.render(scene, camera);\n    controls.update();\n}\n\n(function init() {\n    const $canvas = initCanvas();\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n    initControls($canvas);\n\n    initHemisphereLight();\n    initDirectionalLight();\n\n    initSphereMesh();\n    initPlaneMesh();\n\n    render();\n}());\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 그림자 종류\n\nThree.js 에서 제공하는 그림자는 크게 2가지로 볼 수 있습니다.\n\n* Hard Shadow: 선명하며 거친 그림자를 표현합니다.\n* Soft Shadow: 부드러운 그림자를 표현합니다.\n\n\u003cbr /\u003e\n\nSoft Shadow 는 그림자에 Blur 를 적용하여 부드럽게 표현합니다.\n\n주의할 점은 Blur 값을 크게 설정할수록 부드럽게 표현하지만, 사용자 PC 의 연산량이 커진다는 것 입니다.\n\n\u003cbr /\u003e\n\nThree.js 의 그림자 설정은 다음과 같은 과정으로 만들 수 있습니다.\n\n1. Hard Shadow 설정하기\n2. Soft Shadow 설정 추가하기\n\n\n\n\u003cbr /\u003e\n\n\n\n## 그림자 설정이 필요한 인스턴스들\n\n그림자를 표현하려면 몇가지 설정을 함께 해주어야 합니다.\n\n아래는 그림자 설정이 필요한 인스턴스들 입니다.\n\n* WebGLRenderer 인스턴스\n* Light 인스턴스\n* Mesh 인스턴스\n\n\n\n\u003cbr /\u003e\n\n\n\n## WebGLRenderer 에 shadow 설정하기\n\nWebGLRenderer 는 **ShadowMap** 이라는 메커니즘을 제공합니다.\n\n지금은 컴퓨터 그래픽스에서 그림자를 표현하는 여러 알고리즘 중 한가지 라는 것 정도로 정리하고자 합니다.\n\n* WebGLRenderer shadowMap 은 그림자를 이미지로 생성한 후, 그림자를 씌우는 방식으로 동작합니다.\n\n\u003cbr /\u003e\n\n아래 코드는 WebGLRenderer 가 그림자를 표현하도록 설정합니다.\n\n```js title=\"WebGLRenderer 그림자 사용 설정\" showLineNumbers{111} {7}\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.shadowMap.enabled = true;\n}\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## Light 와 Mesh 의 그림자 설정 (Hard Shadow)\n\nLight 와 Mesh 의 그림자 설정 속성은 동일한 인터페이스를 가집니다.\n\n그림자 설정 속성은 크게 두가지가 있습니다.\n\n* 그림자를 만들어내는 설정: `castShadow`\n* 다른 Mesh 의 그림자를 받는 설정: `receiveShadow`\n\n\u003cbr /\u003e\n\nLight 가 비추는 빛은 다른 Mesh 에 의해 그림자를 생성하게 됩니다.\n\n그러므로 Light 의 **castShadow** 를 `true` 로 설정해줍니다.\n\n```js title=\"DirectionalLight shadow 설정\" showLineNumbers{78} {5}\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n    const light = new DirectionalLight(color);\n    light.position.set(2, 2, 2);\n    light.castShadow = true;\n\n    const helper = new DirectionalLightHelper(light);\n\n    scene.add(light);\n    scene.add(helper);\n}\n```\n\n\u003cbr /\u003e\n\n빛에 의해 그림자를 만들어내는 Mesh 역시 그림자를 생성하므로, **caseShadow** 를 `true` 로 설정해줍니다.\n\n```js title=\"Sphere Mesh shadow 설정\" showLineNumbers{90} {5}\nfunction initSphereMesh() {\n    const geometry = new SphereGeometry();\n    const material = new MeshStandardMaterial();\n    const sphere = new Mesh(geometry, material);\n    sphere.castShadow = true;\n\n    scene.add(sphere);\n}\n```\n\n\u003cbr /\u003e\n\n바닥(땅) 을 표현한 Plane Mesh 는 다른 Mesh 의 그림자를 받게 되므로, **receiveShadow** 를 `true` 로 설정해줍니다.\n\n```js title=\"Plane Mesh shadow 설정\" showLineNumbers{99} {12}\nfunction initPlaneMesh() {\n    const geometry = new PlaneGeometry(10, 10);\n    const material = new MeshStandardMaterial();\n    const plane = new Mesh(geometry, material);\n    plane.position.set(0, -1, 0);\n    plane.rotation.set(\n        Math.PI * -0.5,\n        0,\n        0\n    );\n\n    plane.receiveShadow = true;\n\n    scene.add(plane);\n}\n```\n\n\u003cbr /\u003e\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-07-02/2024-01-07-02-01.png\" alt=\"Hard Shadow\" /\u003e\n\n\u003cbr /\u003e\n\n지금까지 설정하여 만들어낸 그림자는 **Hard Shadow** 입니다.\n\nBlur 처리를 하지 않기 때문에 선명한 그림자가 그려지고, 곡선에서 픽셀이 보이는 특징이 있습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## Soft Shadow 설정 추가하기\n\nHard Shadow 설정을 한 후, WebGLRenderer 의 `shadowMap.type` 을 `VSMShadowMap` 으로 설정하므로써 Soft Shadow 로 표현됩니다.\n\n```js title=\"VSMShadowMap import 하기\" showLineNumbers {16}\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n\n    Mesh,\n    MeshStandardMaterial,\n    SphereGeometry,\n    PlaneGeometry,\n\n    Color,\n    HemisphereLight,\n    HemisphereLightHelper,\n    DirectionalLight,\n    DirectionalLightHelper,\n    VSMShadowMap,\n} from 'three';\n```\n\n```js title=\"Soft Shadow\" showLineNumbers{116} {8}\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.shadowMap.enabled = true;\n    renderer.shadowMap.type = VSMShadowMap;\n}\n```\n\n\u003cbr /\u003e\n\n위 코드에서 사용한 `VSMShadowMap` 이외에도 다른 종류의 shadowMap 을 사용할 수도 있습니다. (이번 포스팅에서는 `VSMShadowMap` 을 사용합니다.)\n\n[Three.js 공식 문서 - WebGLRenderer.shadowMap](https://threejs.org/docs/index.html?q=webglRenderer#api/en/renderers/WebGLRenderer.shadowMap)\n\n* BasicShadowMap\n* PCFShadowMap (default)\n* PCFSoftShadowMap\n* VSMShadowMap\n\n\u003cbr /\u003e\n\n위 설정을 추가한 후, 결과를 확인하면 Hard Shadow 와 다른점이 없어 보입니다.\n\n이는 그림자를 생성하는 Light 의 **Blur 정도** 와 **번지는 영역의 Radius** 를 변경하면서 부드러움이 달라지는 것을 확인할 수 있습니다.\n\n```js title=\"DirectionalLight 의 Blur 와 Radius 설정\" showLineNumbers{79} {6-7}\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n    const light = new DirectionalLight(color);\n    light.position.set(2, 2, 2);\n    light.castShadow = true;\n    light.shadow.blurSamples = 30;\n    light.shadow.radius = 12;\n\n    const helper = new DirectionalLightHelper(light);\n\n    scene.add(light);\n    scene.add(helper);\n}\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-07-02/2024-01-07-02-02.png\" alt=\"Soft Shadow\" /\u003e\n\n\u003cbr /\u003e\n\nLight 의 shadow 설정 시, 주의할 사항은 다음과 같습니다.\n\n* `shadow.blurSamples`: 값이 커질수록 부드러운 그림자를 표현하지만, 필요 성능이 높아집니다.\n* `shadow.radius`: 값이 너무 작으면 화면이 깨지는 현상이 있으므로, **10 이상** 설정을 권장합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\n그림자는 조명과 물제의 상호연산을 사용하기 때문에 연산량이 많이 필요하다고 합니다.\n\n그래서 그림자를 최소한으로 사용할 수 있도록 여러가지 설정을 분리시켜놓은 느낌이 들었습니다.\n\nThree.js 를 활용할 때, 그림자 설정이 성능 최적화 대상이라는 것을 알게 되었습니다.\n"])</script><script>self.__next_f.push([1,"1a:T1a79,"])</script><script>self.__next_f.push([1,"---\nid: 4\ntitle: 평평한 바닥(땅) 만들기 (Plane Mesh)\ndescription: '바닥을 표현하기 위해 Plane Mesh 를 생성합니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    'javascript',\n    '3d',\n    'plane',\n]\n\ncreatedAt: '2024-01-07 23:20:00'\nmodifiedHistories: []\n---\n\n# 평평한 바닥(땅) 만들기 (Plane Mesh)\n\n이번 포스팅에서는 바닥(땅) 을 만들어 보겠습니다.\n\nThree.js 에서는 바닥(땅) 을 **Plane Mesh** 로 만들 수 있습니다.\n\n다음 포스팅에서 다룰 그림자를 표현하려면, 바닥(땅) 이 있어야 하므로 별도의 포스팅으로 분리하게 되었습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 예시 코드\n\n이번 포스팅에서 사용할 예시 코드는 다음과 같습니다.\n\n```js title=\"예시 코드\" showLineNumbers {96}\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n\n    Mesh,\n    MeshStandardMaterial,\n    SphereGeometry,\n\n    Color,\n    HemisphereLight,\n    HemisphereLightHelper,\n    DirectionalLight,\n    DirectionalLightHelper,\n} from 'three';\nimport {\n    OrbitControls,\n} from 'three/examples/jsm/controls/OrbitControls';\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { OrbitControls } */\nlet controls;\n\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n    $canvas.width = window.innerWidth;\n    $canvas.height = window.innerHeight;\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\nfunction initScene() {\n    scene = new Scene();\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n    camera.fov = 35;\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.position.set(0, 0, 12);\n\n    camera.updateProjectionMatrix();\n}\n\nfunction initControls($canvas) {\n    controls = new OrbitControls(camera, $canvas);\n    controls.enableDamping = true;\n}\n\nfunction initHemisphereLight() {\n    const skyColor = new Color('#fff');\n    const groundColor = new Color('#000');\n    const light = new HemisphereLight(\n        skyColor,\n        groundColor,\n        0.75\n    );\n\n    const helper = new HemisphereLightHelper(light);\n\n    scene.add(light);\n    scene.add(helper);\n}\n\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n    const light = new DirectionalLight(color);\n    light.position.set(2, 2, 2);\n\n    const helper = new DirectionalLightHelper(light);\n\n    scene.add(light);\n    scene.add(helper);\n}\n\nfunction initSphereMesh() {\n    const geometry = new SphereGeometry();\n    const material = new MeshStandardMaterial();\n    const sphere = new Mesh(geometry, material);\n\n    scene.add(sphere);\n}\n\n// 여기에 Plane Mesh(바닥) 을 생성하는 함수를 구현할 예정입니다.\n\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n}\n\nfunction render() {\n    window.requestAnimationFrame(render);\n\n    renderer.render(scene, camera);\n    controls.update();\n}\n\n(function init() {\n    const $canvas = initCanvas();\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n    initControls($canvas);\n\n    initHemisphereLight();\n    initDirectionalLight();\n\n    initSphereMesh();\n\n    render();\n}());\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## Plane Mesh 생성 함수 만들기\n\nPlane Mesh 는 **PlaneGeometry** class 를 사용하여 생성할 수 있습니다.\n\n```js title=\"PlaneGeometry class import 하기\" showLineNumbers {9}\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n\n    Mesh,\n    MeshStandardMaterial,\n    SphereGeometry,\n    PlaneGeometry,\n\n    Color,\n    HemisphereLight,\n    HemisphereLightHelper,\n    DirectionalLight,\n    DirectionalLightHelper,\n} from 'three';\n```\n\n```js title=\"initPlaneMesh() 함수 구현하기\" showLineNumbers{97}\nfunction initPlaneMesh() {\n    const geometry = new PlaneGeometry();\n    const material = new MeshStandardMaterial();\n    const plane = new Mesh(geometry, material);\n    plane.position.set(0, -1, 0);\n\n    scene.add(plane);\n}\n```\n\n```js title=\"initPlaneMesh 함수 호출하기\" showLineNumbers{120} {12}\n(function init() {\n    const $canvas = initCanvas();\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n    initControls($canvas);\n\n    initHemisphereLight();\n    initDirectionalLight();\n\n    initSphereMesh();\n    initPlaneMesh();\n\n    render();\n}());\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-07-01/2024-01-07-01-01.png\" alt=\"PlaneMesh\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## Plane Mesh 회전 및 크기 변경하기\n\n위 코드를 실행하면, Sphere 하부에 사각형 물체가 렌더링됩니다.\n\n**width**, **height**, **rotation** 을 변경하여 바닥(땅) 처럼 보이도록 설정해 보겠습니다.\n\n```js title=\"initPlaneMesh() 함수 구현하기\" showLineNumbers{97} {2, 6-10}\nfunction initPlaneMesh() {\n    const geometry = new PlaneGeometry(5, 5);\n    const material = new MeshStandardMaterial();\n    const plane = new Mesh(geometry, material);\n    plane.position.set(0, -1, 0);\n    plane.rotation.set(\n        Math.PI * -0.5, \n        0, \n        0\n    );\n\n    scene.add(plane);\n}\n```\n\n\u003cbr /\u003e\n\nPlaneGeometry class 는 생성자에 **width** 와 **height** 를 넘겨주어 크기를 설정할 수 있습니다.\n\n```js title=\"width, height 설정\" showLineNumbers{98}\nconst geometry = new PlaneGeometry(5, 5);\n```\n\n\u003cbr /\u003e\n\n그리고 Plane Mesh 인스턴스의 `rotation.set()` 메소드를 사용하여 회전시킬 수 있습니다.\n\n회전시킬 값은 **Radian** 으로 넘겨주어야 하므로, **Math.PI** 를 사용합니다.\n\n```js title=\"회전 시키기\" showLineNumbers{102} {2}\nplane.rotation.set(\n    Math.PI * -0.5, \n    0, \n    0\n);\n```\n\n위 코드에서 X축 회전으로 `Math.PI * -0.5` 를 주었는데, 이는 아래와 같은 Plane Mesh 의 특성으로 고려한 것입니다.\n\n* Plane Mesh 는 한쪽면만 렌더링되는 단면 물체 입니다.\n* 렌더링되지 않는 반대쪽 면에는 그림자가 드리우지 않습니다.\n\n\u003cbr /\u003e\n\n이렇게 실행한 결과는 다음과 같습니다.\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-07-01/2024-01-07-01-02.png\" alt=\"PlaneMesh 설정\" /\u003e\n\n\u003cbr /\u003e\n\n카메라를 회전시켜서 Plane Mesh 의 반대쪽 면을 보면, 렌더링되지 않은 결과를 볼 수 있습니다.\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-07-01/2024-01-07-01-03.png\" alt=\"PlaneMesh 반대면\" /\u003e\n\n\n\n## 마치며\n\nPlane Mesh 를 생성하여 바닥(땅) 을 만들 수 있게 되었습니다.\n\n다음 포스팅에서는 바닥(땅) 에 그림자를 표현하여, 조명과 물체의 자연스러운 연출 방법을 정리해 보겠습니다.\n"])</script><script>self.__next_f.push([1,"1b:T2eef,"])</script><script>self.__next_f.push([1,"---\nid: 3\ntitle: 조명 종류와 설정\ndescription: '조명 종류와 설정 방법에 대해 정리합니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    'javascript',\n    '3d',\n    'light',\n]\n\ncreatedAt: '2024-01-06 23:00:00'\nmodifiedHistories: []\n---\n\n# 조명 종류와 설정\n\nThree.js 는 조명이 없으면 검은 화면만 보이게 됩니다.\n\n이번 포스팅에서는 조명의 종류와 특징, 설정 방법에 대해 정리하고자 합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 조명 종류\n\n조명의 종류는 다음과 같습니다.\n\n* DirectionalLight\n* PointLight\n* AmbientLight\n* HemisphereLight\n\n그리고 개발환경에서 조명의 광원 위치를 파악하기 쉽게 도와주는 **Helper class** 가 있습니다.\n\n자세한 사항은 각 조명과 함께 정리하겠습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 예시 코드\n\n이번 포스팅에서 사용할 예시 코드는 다음과 같습니다.\n\n```js title=\"예시 코드\" showLineNumbers {94}\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n\n    SphereGeometry,\n    MeshStandardMaterial,\n    Mesh,\n\n    Color,\n\n    DirectionalLight,\n    DirectionalLightHelper,\n} from 'three';\nimport './style.css';\nimport {\n    OrbitControls,\n} from 'three/examples/jsm/controls/OrbitControls';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { OrbitControls } */\nlet controls;\n\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n    $canvas.width = window.innerWidth;\n    $canvas.height = window.innerHeight;\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n}\n\nfunction initScene() {\n    scene = new Scene();\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n    camera.fov = 35;\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.position.set(0, 0, 10);\n\n    camera.updateProjectionMatrix();\n}\n\nfunction initControls($canvas) {\n    controls = new OrbitControls(camera, $canvas);\n    controls.enableDamping = true;\n}\n\nfunction createSphere() {\n    const geometry = new SphereGeometry();\n    const material = new MeshStandardMaterial();\n    const sphere = new Mesh(geometry, material);\n\n    return sphere;\n}\n\nfunction render() {\n    requestAnimationFrame(render);\n\n    renderer.render(scene, camera);\n    controls.update();\n}\n\nfunction init() {\n    const $canvas = initCanvas();\n\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n    initControls($canvas);\n\n    const sphere = createSphere();\n    scene.add(sphere);\n\n    // 여기에서 `조명 설정` 함수를 호출하며 실습할 예정입니다.\n\n    render();\n}\n\ninit();\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## DirectionalLight\n\nDirectionalLight 는 **광원** 에서 **특정 지점(lookAt(좌표))** 로 비추는 **단방향 조명** 입니다.\n\n물체에 비추는 빛의 양은 광원과의 거리와 무관한 빛의 세기(intensity) 설정값이 적용됩니다.\n\n\u003cbr /\u003e\n\n```js title=\"DirectionalLight import 하기\" showLineNumbers\nimport {\n    DirectionalLight,\n} from 'three';\n```\n\n```js title=\"DirectionalLight\" showLineNumbers{83} {9, 14-18}\nfunction init() {\n    initRenderer(initCanvas());\n    initCamera();\n    initScene();\n\n    const sphere = createSphere();\n    scene.add(sphere);\n\n    initDirectionalLight();\n\n    render();\n}\n\nfunction initDirectionalLight() {\n    const light = new DirectionalLight();\n    light.position.set(1, 1, 1);\n    scene.add(light);\n}\n\ninit();\n```\n\n\u003cbr /\u003e\n\nDirectionalLight 생성자에 인자로 **Color 객체** 를 넘겨주어 빛의 색상을 변경할 수 있습니다.\n\n**Color** 는 Three.js 에서 제공하는 class 이며, Three.js 의 색상관련 설정은 **Color 인스턴스** 를 받습니다.\n\n```js title=\"Color import 하기\" showLineNumbers\nimport {\n    Color,\n} from 'three';\n```\n\n```js title=\"DirectionalLight 색상 설정하기\" showLineNumbers{83} {15}\nfunction init() {\n    initRenderer(initCanvas());\n    initCamera();\n    initScene();\n\n    const sphere = createSphere();\n    scene.add(sphere);\n\n    initDirectionalLight();\n\n    render();\n}\n\nfunction initDirectionalLight() {\n    const color = new Color('#f0f400');\n    const light = new DirectionalLight(color);\n    light.position.set(1, 1, 1);\n\n    scene.add(light);\n}\n\ninit();\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-06-01/2024-01-06-01-01.png\" alt=\"DirectionalLight\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n### DirectionalLightHelper\n\nDirectionalLight 의 광원을 표기해주는 기능을 사용해 보겠습니다.\n\nDirectionalLightHelper 인스턴스를 생성한 후, `scene.add()` 를 사용하여 등록해 줍니다.\n\n```js title=\"DirectionalLightHelper import 하기\" showLineNumbers {3}\nimport {\n    DirectionalLight,\n    DirectionalLightHelper,\n} from 'three';\n```\n\n```js title=\"DirectionalLight 색상 설정하기\" showLineNumbers{83} {20-21}\nfunction init() {\n    initRenderer(initCanvas());\n    initCamera();\n    initScene();\n\n    const sphere = createSphere();\n    scene.add(sphere);\n\n    initDirectionalLight();\n\n    render();\n}\n\nfunction initDirectionalLight() {\n    const color = new Color('#f0f400');\n    const light = new DirectionalLight(color);\n    light.position.set(1, 1, 1);\n    scene.add(light);\n\n    const helper = new DirectionalLightHelper(light);\n    scene.add(helper);\n}\n\ninit();\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-06-01/2024-01-06-01-02.png\" alt=\"DirectionalLightHelper\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 빛의 세기(intensity) 설정하기\n\n조명은 빛의 세기(intensity) 가 있습니다.\n\nThree.js 의 모든 조명에도 빛의 세기(intensity) 를 설정할 수 있습니다.\n\n빛의 세기 값은 **0 ~ 1** 값으로 설정합니다.\n\n아래 코드는 DirectionalLight 에 빛의 세기(intensity) 를 0.75 로 설정하고 있습니다.\n\n```js title=\"DirectionalLight 색상 설정하기\" showLineNumbers{83} {18}\nfunction init() {\n    initRenderer(initCanvas());\n    initCamera();\n    initScene();\n\n    const sphere = createSphere();\n    scene.add(sphere);\n\n    initDirectionalLight();\n\n    render();\n}\n\nfunction initDirectionalLight() {\n    const color = new Color('#f0f400');\n    const light = new DirectionalLight(\n        color, \n        0.75\n    );\n    light.position.set(1, 1, 1);\n    scene.add(light);\n\n    const helper = new DirectionalLightHelper(light);\n    scene.add(helper);\n}\n\ninit();\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## PointLight\n\n전등처럼 한 점에서 빛을 방사하는 조명 입니다.\n\n사용방법은 다음과 같습니다.\n\n```js title=\"PointLight import 하기\" showLineNumbers\nimport {\n    PointLight,\n    PointLightHelper,\n} from 'three';\n```\n\n```js title=\"PointLight 색상 설정하기\" showLineNumbers{83} {9, 14-25}\nfunction init() {\n    initRenderer(initCanvas());\n    initCamera();\n    initScene();\n\n    const sphere = createSphere();\n    scene.add(sphere);\n\n    initPointLight();\n\n    render();\n}\n\nfunction initPointLight() {\n    const color = new Color('#f0f400');\n    const light = new PointLight(\n        color,\n        0.75 // 빛의 세기(intensity)\n    );\n    light.position.set(1, 1, 1);\n    scene.add(light);\n\n    const helper = new PointLightHelper(light);\n    scene.add(helper);\n}\n\ninit();\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-06-01/2024-01-06-01-03.png\" alt=\"PointLight\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## AmbientLight\n\nAmbient 는 `주변` 이라는 뜻을 가지고 있습니다.\n\nAmbientLight 는 특정한 광원이 없고, 모든 영역에 동일하게 비추는 조명입니다.\n\n즉 `(x, y, z)` 에 관계없이 동일한 빛을 비춥니다.\n\n\u003cbr /\u003e\n\nAmbientLight 가 적용된 결과를 확인하기 위해, PointLight 와 함께 사용해 보겠습니다.\n\n```js title=\"PointLight import 하기\" showLineNumbers {5}\nimport {\n    PointLight,\n    PointLightHelper,\n\n    AmbientLight,\n} from 'three';\n```\n\n```js title=\"PointLight 색상 설정하기\" showLineNumbers{83} {10, 28-35}\nfunction init() {\n    initRenderer(initCanvas());\n    initCamera();\n    initScene();\n\n    const sphere = createSphere();\n    scene.add(sphere);\n\n    initPointLight();\n    initAmbientLight();\n\n    render();\n}\n\nfunction initPointLight() {\n    const color = new Color('#f0f400');\n    const light = new PointLight(\n        color,\n        0.75 // 빛의 세기(intensity)\n    );\n    light.position.set(1, 1, 1);\n    scene.add(light);\n\n    const helper = new PointLightHelper(light);\n    scene.add(helper);\n}\n\nfunction initAmbientLight() {\n    const color = new Color('#fff');\n    const light = new AmbientLight(\n        color,\n        0.25, // 빛의 세기(intensity)\n    );\n    scene.add(light);\n}\n\ninit();\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-06-01/2024-01-06-01-04.png\" alt=\"AmbientLight\" /\u003e\n\n\u003cbr /\u003e\n\n그리고 AmbientLight 는 모든 영역에 비추는 조명이므로, **Helper class 가 없다는 특징** 이 있습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## HemisphereLight\n\nHemisphereLight 는 위쪽(skyColor) 와 아래쪽(groundColor) 를 인자로 받고, 그라데이션으로 비추는 조명입니다.\n\n일반적으로 기본 조명으로 사용하는데, 이는 Three.js 특성 때문입니다.\n\n* 조명이 없으면, 물체(Mesh) 는 보이지 않는 검은 화면만 렌더링 됩니다.\n* 다른 조명에 의해 생기는 그림자를 좀 더 자연스럽고 부드럽게 만들어줍니다.\n\n\u003cbr /\u003e\n\n아래 코드는 HemisphereLight 와 DirectionalLight 를 조합한 예시 입니다.\n\n```js title=\"PointLight import 하기\" showLineNumbers {5-6}\nimport {\n    DirectionalLight,\n    DirectionalLightHelper,\n\n    HemisphereLight,\n    HemisphereLightHelper,\n} from 'three';\n```\n\n```js title=\"PointLight 색상 설정하기\" showLineNumbers{83} {10, 28-40}\nfunction init() {\n    initRenderer(initCanvas());\n    initCamera();\n    initScene();\n\n    const sphere = createSphere();\n    scene.add(sphere);\n\n    initDirectionalLight();\n    initHemisphereLight();\n\n    render();\n}\n\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n    const light = new DirectionalLight(\n        color,\n        0.75 // 빛의 세기(intensity)\n    );\n    light.position.set(1, 1, 1);\n    scene.add(light);\n\n    const helper = new PointLightHelper(light);\n    scene.add(helper);\n}\n\nfunction initHemisphereLight() {\n    const skyColor = new Color('#fff');\n    const groundColor = new Color('#000');\n    const light = new HemisphereLight(\n        skyColor,\n        groundColor,\n        0.25, // 빛의 세기(intensity)\n    );\n    scene.add(light);\n\n    const helper = new HemisphereLightHelper(light);\n    scene.add(helper);\n}\n\ninit();\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-06-01/2024-01-06-01-05.png\" alt=\"Hemisphere\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\n일반적으로 DirectionalLight 와 HemisphereLight 를 조합하여 기본 조명을 구성합니다.\n\n각 설정은 다음과 같습니다.\n\n```js title=\"일반적인 조명 설정\" showLineNumbers\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n    const light = new DirectionalLight(\n        color,\n        0.75 // HemispherLight 보다 0.5 강하게 설정합니다.\n    );\n    scene.add(light);\n}\n\nfunction initHemisphereLight() {\n    const skyColor = new Color('#fff');\n    const groundColor = new Color('#000');\n    const light = new HemisphereLight(\n        skyColor,\n        groundColor,\n        0.25 // DirectionalLight 보다 0.5 약하게 설정합니다.\n    );\n    scene.add(light);\n}\n```\n\n\u003cbr /\u003e\n\nHemisphereLight 를 사용하므로써 그림자 부분이 검은색으로 보이지 않도록 해주며, 좀 더 자연스러운 조명을 연출할 수 있습니다.\n\n그리고 PointLight 는 특정 물체를 강조하거나 효과를 주기위해 주로 사용합니다.\n\n\u003cbr /\u003e\n\nThree.js 는 개발 능력뿐만 아니라 사물을 표현하는 예술 능력도 필요하겠다는 느낌이 듭니다. 😱\n"])</script><script>self.__next_f.push([1,"1c:T3ac1,"])</script><script>self.__next_f.push([1,"---\nid: 2\ntitle: 카메라 설정 (PerspectiveCamera)\ndescription: 'Three.js 의 카메라인 PerspectiveCamera 설정에 대한 포스팅입니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    'javascript',\n    '3d',\n    'camera',\n]\n\ncreatedAt: '2024-01-01 23:50:00'\nmodifiedHistories: []\n---\n\n# 카메라 설정 (PerspectiveCamera)\n\nThree.js 가 `\u003ccanvas /\u003e` 에 실제로 렌더링하는 부분은 `카메라 (PerspectiveCamera)` 가 비추는 영역입니다.\n\n이번 포스팅에서는 카메라 설정과 효과, 사용자 인터렉션 적용 방법에 대해 정리해 보겠습니다.\n\n이번 포스팅에서는 아래의 코드를 시작점으로 사용하겠습니다.\n\n```js title=\"샘플 코드\" showLineNumbers\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    Scene,\n    DirectionalLight,\n\n    BoxGeometry,\n    MeshPhongMaterial,\n    Mesh,\n} from 'three';\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { Scene } */\nlet scene;\n\n(function init() {\n    const $canvas = initCanvas();\n\n    initRenderer($canvas);\n\n    const light = createLight();\n    const boxMesh = createBoxMesh();\n\n    initCamera();\n    initScene(light, boxMesh);\n\n    render();\n\n    console.log('시작');\n}());\n\nfunction render() {\n    renderer.render(scene, camera);\n\n    window.requestAnimationFrame(render);\n}\n\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\n/**\n * @param { HTMLCanvasElement } $canvas \n */\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.setSize(\n        window.innerWidth,\n        window.innerHeight\n    );\n}\n\nfunction createLight() {\n    const light = new DirectionalLight();\n    light.position.set(1, 2, 3);\n\n    return light;\n}\n\nfunction createBoxMesh() {\n    const boxGeometry = new BoxGeometry();\n    const boxMaterial = new MeshPhongMaterial();\n\n    return new Mesh(boxGeometry, boxMaterial);\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera(\n        45,\n        window.innerWidth / window.innerHeight\n    );\n\n    camera.position.set(0, 0, 5);\n}\n\nfunction initScene(...items) {\n    scene = new Scene();\n\n    items.forEach(item =\u003e {\n        scene.add(item);\n    });\n}\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## PerspectiveCamera 생성자 params\n\n카메라 생성자 params 를 사용하여 초기 설정을 할 수 있습니다.\n\n```ts title=\"PerspectiveCamera 생성자 함수\" showLineNumbers\nclass PerspectiveCamera {\n    constructor(\n        fov?: number,\n        aspect?: number,\n        near?: number,\n        far?: number\n    );\n}\n```\n\n* fov (Field of View): 시야각 (화각)\n    * fov 설정값이 클수록 먼 거리에서 보는 느낌이 납니다.\n    * fov 설정값이 커질수록 **투시에 따른 왜곡현상** 이 도드라지게 나타납니다.\n* aspect: 카메라 종횡비 (aspect radio)\n    * 카메라의 가로, 세로 비율값 입니다.\n* near: (Near clipping)\n    * 카메라를 기준으로 가까운 물체(Mesh) 에 대한 렌더링 잘라내기 설정값 입니다.\n* far: (Far clipping)\n    * 카메라를 기준으로 먼 물체(Mesh) 에 대한 렌더링 잘라내기 설정값 입니다.\n\n\u003cbr /\u003e\n\n위 설정들은 PerspectiveCamera 생성자를 통해서도 설정할 수 있고, 객체를 생성한 후 설정을 변경할 수도 있습니다.\n\n만약 객체를 생성한 후 설정을 변경한다면, 카메라 메소드인 **updateProjectionMatrix()** 함수를 호출하여야 실제 렌더링에 반영됩니다.\n\n아래 코드는 PerspectiveCamera 객체를 생성한 후, 카메라 설정을 변경하고 있습니다.\n\n```js title=\"카메라 객체 설정값 변경하기\" showLineNumbers {88, 89, 92}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    Scene,\n    DirectionalLight,\n\n    BoxGeometry,\n    MeshPhongMaterial,\n    Mesh,\n} from 'three';\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { Scene } */\nlet scene;\n\n(function init() {\n    const $canvas = initCanvas();\n\n    initRenderer($canvas);\n\n    const light = createLight();\n    const boxMesh = createBoxMesh();\n\n    initCamera();\n    initScene(light, boxMesh);\n\n    render();\n\n    console.log('시작');\n}());\n\nfunction render() {\n    renderer.render(scene, camera);\n\n    window.requestAnimationFrame(render);\n}\n\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\n/**\n * @param { HTMLCanvasElement } $canvas \n */\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.setSize(\n        window.innerWidth,\n        window.innerHeight\n    );\n}\n\nfunction createLight() {\n    const light = new DirectionalLight();\n    light.position.set(1, 2, 3);\n\n    return light;\n}\n\nfunction createBoxMesh() {\n    const boxGeometry = new BoxGeometry();\n    const boxMaterial = new MeshPhongMaterial();\n\n    return new Mesh(boxGeometry, boxMaterial);\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera(\n        // 45,\n        // window.innerWidth / window.innerHeight\n    );\n\n    camera.fov = 45;\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.position.set(0, 0, 3);\n\n    camera.updateProjectionMatrix();\n}\n\nfunction initScene(...items) {\n    scene = new Scene();\n\n    items.forEach(item =\u003e {\n        scene.add(item);\n    });\n}\n```\n\n\u003cbr /\u003e\n\n위 코드의 실행 결과로 BoxMesh 의 단면을 볼 수 있습니다.\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-01-01/2024-01-01-01-01.png\" alt=\"실행 결과\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 카메라의 주시 좌표값 변경하기\n\n현재는 BoxMesh 의 단면만을 비추고 있어서 마치 2D 인것 처럼 보입니다.\n\n카메라의 위치와 카메라의 주시 좌표값을 변경하면, 물체를 다각도에서 다양한 구도로 렌더링할 수 있습니다.\n\n\u003cbr /\u003e\n\n먼저 카메라의 위치를 (1, 1, 2) 로 변경해 보겠습니다.\n\n```js title=\"카메라 position 변경\" showLineNumbers{82} {6}\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n\n    camera.fov = 45;\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.position.set(1, 1, 2);\n\n    camera.updateProjectionMatrix();\n}\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-01-01/2024-01-01-01-02.png\" alt=\"실행 결과\" /\u003e\n\n\u003cbr /\u003e\n\n카메라의 position 만을 변경한 결과, BoxMesh 의 일부분만 렌더링되고 있습니다.\n\n이는 카메라의 주시 좌표값을 설정하지 않아서 카메라 위치에서 정면을 주시하고 있기 때문입니다.\n\n카메라 객체의 `lookAt()` 메소드를 사용하면, 카메라의 위치인 position 에서 특정 좌표를 주시하게 됩니다.\n\nBoxMesh 가 카메라의 중앙에 오도록 하기위해, BoxMesh 의 position 위치값인 (0, 0, 0) 으로 카메라 주시 좌표를 설정해 보겠습니다.\n\n```js title=\"카메라 position 변경\" showLineNumbers{82} {8}\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n\n    camera.fov = 45;\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.position.set(1, 1, 2);\n\n    camera.lookAt(0, 0, 0);\n\n    camera.updateProjectionMatrix();\n}\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-01-01/2024-01-01-01-03.png\" alt=\"실행 결과\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 카메라 fov 와 position 설정에 따른 왜곡 현상\n\nfov(Field of View) 값이 커질수록 멀리서 보는 느낌으로 렌더링됩니다.\n\n이는 물체가 더 작게 보이는 결과를 볼 수 있습니다.\n\n\u003cbr /\u003e\n\n만약 fov 를 큰 값으로 설정하여 물체가 작게 보이도록 한 후, 카메라의 위치를 물체와 가깝게 설정하면 어떻게 될까요?\n\n이는 카메라의 **왜곡 현상** 에 의해 좀 더 렌즈의 굴곡이 커지게 됩니다.\n\nfov 와 position 의 관계를 표현해 보면 다음과 같습니다.\n\n* fov 작게 설정, position 멀리 설정\n    * 왜곡 현상이 적어집니다.\n* fov 크게 설정, position 가깝게 설정\n    * 왜곡 현상이 커집니다.\n\n\u003cbr /\u003e\n\n실제 왜곡 현상의 차이를 확인하기 위해 두가지 설정을 비교해 보겠습니다.\n\n* 첫번째 설정: **fov 작게, position 멀리** 설정\n* 두번째 설정: **fov 크게, position 가깝게** 설정\n\n```js title=\"fov 작게, position 멀리 설정\" showLineNumbers{82} {5-6}\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.fov = 45;\n    camera.position.set(2, 2, 2);\n\n    camera.lookAt(0, 0, 0);\n\n    camera.updateProjectionMatrix();\n}\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-01-01/2024-01-01-01-04.png\" alt=\"실행 결과\" /\u003e\n\n\u003cbr /\u003e\u003cbr /\u003e\n\n```js title=\"fov 크게, position 가깝게 설정\" showLineNumbers{82} {5-6}\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.fov = 90;\n    camera.position.set(1, 1, 1);\n\n    camera.lookAt(0, 0, 0);\n\n    camera.updateProjectionMatrix();\n}\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-01-01/2024-01-01-01-05.png\" alt=\"실행 결과\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 추가: 마우스를 사용하여 카메라 제어하기\n\nThree.js 는 여러가지 Addons 를 제공합니다.\n\n이 중 **OrbitControls** 객체를 사용하면, 마우스를 사용하여 카메라를 제어하는 기능을 제공할 수 있습니다.\n\n\u003cbr /\u003e\n\nOrbitControls 는 **PerspectiveCamera 의 Addon** 개념으로 사용하게 되며, 카메라의 제어를 담당하게 됩니다.\n\n주의할 점은 PerspectiveCamera 의 `lookAt()` 메소드를 함께 사용하게 되면, 카메라 제어에 충돌이 발생하는 현상입니다.\n\n그러므로 OrbitControls 를 사용하려면, `lookAt()` 메소드는 꼭 제거해 주는 것이 좋습니다.\n\n\u003cbr /\u003e\n\n먼저 OrbitControls 의 생성자를 살펴보면 다음과 같습니다.\n\n```ts\nclass OrbitControls {\n    constructor(\n        object: Camera, \n        domElement?: HTMLElement\n    );\n}\n```\n\n* object: 제어할 카메라 객체\n* domElement: 마우스 이벤트를 발생시킬 HTMLElement\n\n\u003cbr /\u003e\n\nPerspectiveCamera 에 OrbitControls 를 적용하는 `initControls()` 함수를 추가해 보겠습니다.\n\n```js title=\"OrbitControls 로 카메라 제어하기\" showLineNumbers {11-13, 25-26, 37, 45, 103-108}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    Scene,\n    DirectionalLight,\n\n    BoxGeometry,\n    MeshPhongMaterial,\n    Mesh,\n} from 'three';\nimport {\n    OrbitControls,\n} from 'three/examples/jsm/controls/OrbitControls'\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { OrbitControls } */\nlet controls;\n\n(function init() {\n    const $canvas = initCanvas();\n\n    initRenderer($canvas);\n\n    const light = createLight();\n    const boxMesh = createBoxMesh();\n\n    initCamera();\n    initControls($canvas);\n    initScene(light, boxMesh);\n\n    render();\n}());\n\nfunction render() {\n    renderer.render(scene, camera);\n    controls.update();\n\n    window.requestAnimationFrame(render);\n}\n\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\n/**\n * @param { HTMLCanvasElement } $canvas \n */\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.setSize(\n        window.innerWidth,\n        window.innerHeight\n    );\n}\n\nfunction createLight() {\n    const light = new DirectionalLight();\n    light.position.set(1, 2, 3);\n\n    return light;\n}\n\nfunction createBoxMesh() {\n    const boxGeometry = new BoxGeometry();\n    const boxMaterial = new MeshPhongMaterial();\n\n    return new Mesh(boxGeometry, boxMaterial);\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.fov = 45;\n    camera.position.set(2, 2, 2);\n\n    camera.fov = 90;\n    camera.position.set(1, 1, 1);\n\n    camera.lookAt(0, 0, 0);\n\n    camera.updateProjectionMatrix();\n}\n\n/**\n * @param { HTMLElement } $targetElement \n */\nfunction initControls($targetElement) {\n    controls = new OrbitControls(camera, $targetElement);\n}\n\nfunction initScene(...items) {\n    scene = new Scene();\n\n    items.forEach(item =\u003e {\n        scene.add(item);\n    });\n}\n```\n\n\u003cbr /\u003e\n\nOrbitControls 를 카메라에 설치하게 되면 아래와 같은 마우스 인터렉션을 사용할 수 있습니다.\n\n* 마우스 좌클릭 - 드래그\n    * 카메라 주시 좌표를 회전 중심점으로 하여, **드래그 반대 방향으로 카메라를 회전** 시킵니다.\n    * 결과적으로 카메라가 고정된 상태에서 **바라보는 물체가 회전** 하게 됩니다.\n* 마우스 휠\n    * 확대, 축소 동작을 합니다.\n* 마우스 우클릭 - 드래그\n    * **드래그 반대 방향으로 카메라의 위치를 이동** 시킵니다.\n    * 결과적으로 카메라가 고정된 상태에서 **바라보는 물체가 이동** 하게 됩니다.\n\n\u003cbr /\u003e\n\nOrbitControls 객체의 설정을 사용하여, 특정 마우스 인터렉션의 사용 여부를 설정할 수 있습니다.\n\n이 설정 프로퍼티들은 `enable` 을 접두사로 사용하고 있습니다.\n\n* `enableRotate`: `false` 값을 대입하면, 회전기능을 막습니다.\n* `enableZoom`: `false` 값을 대입하면 확대, 축소 기능을 막습니다.\n* `enablePan`: `false` 값을 대입하면 이동 기능을 막습니다.\n\n\u003cbr /\u003e\n\n추가로 `enableDamping` 에 `true` 값을 대입하게 되면, 카메라의 모든 인터렉션에 감속도가 적용되어 **카메라의 부드러운 움직임이 연출** 됩니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\n일전에 HTML Canvas API 를 스터디하면서, 도형에 대한 인터렉션이나 애니메이션을 구현해본 적이 있습니다.\n\n물체의 튕김이나 가속도, 감속도를 구현해 보려는 시도를 했었지만, 제가 구현한 결과물은 너무나 어색했습니다.\n\nThree.js 의 인터렉션은 OrbitControls 하나를 접했을 뿐인데, 부드러운 3D 엔진에 그저 놀라울 뿐입니다.\n\n\u003cbr /\u003e\n\n하지만 실제 구현할 기획에 따라 엔진의 물리 효과를 커스터마이징을 할 수 있어야 자연스러운 결과물이 나올 것 같습니다.\n\nOrbitControls 가 제공하는 효과는 마치 물속의 부력이 작용하는 것처럼 느껴졌습니다.\n\nThree.js 의 기본 사용법과 원리를 이해한 후, 물리 엔진 커스터마이징에 대해서도 도전해 보고 싶어졌습니다.\n"])</script><script>self.__next_f.push([1,"d:[\"$\",\"$Le\",null,{\"featuredMarkdownFileDataList\":[{\"category\":\"jest\",\"slug\":\"2023-12-17-01\",\"href\":\"/blog/jest/2023-12-17-01\",\"frontmatter\":{\"id\":1,\"title\":\"\\\"node:fs\\\" 테스트 하기\",\"description\":\"node 모듈중 File System 기능, \\\"fs\\\" 를 테스트하는 방법에 대해 정리합니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":true,\"tags\":[\"mock-fs\",\"fs\",\"node:fs\",\"jest\",\"@testing-library\",\"유닛 테스트\"],\"createdAt\":\"$D2023-12-17T15:33:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$f\"},{\"category\":\"threejs\",\"slug\":\"2023-12-31-01\",\"href\":\"/blog/threejs/2023-12-31-01\",\"frontmatter\":{\"id\":1,\"title\":\"Three.js 설치 및 실행\",\"description\":\"Three.js 를 사용하기 위한 설치와 첫번째 화면을 그려봅니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":true,\"tags\":[\"threejs\",\"javascript\",\"3d\"],\"createdAt\":\"$D2023-12-31T22:47:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$10\"}],\"commonMarkdownFileDataList\":[{\"category\":\"javascript\",\"slug\":\"2023-12-21-01\",\"href\":\"/blog/javascript/2023-12-21-01\",\"frontmatter\":{\"id\":1,\"title\":\"구조 분해 할당의 기본값 지정, null 은 사용 불가!\",\"description\":\"구조 분해 할당의 기본값 설정은 Nullish(undefined 와 null) 가 아닌, 오직 undefined 일 때만 적용됩니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"javascript\"],\"createdAt\":\"$D2023-12-21T20:20:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$11\"},{\"category\":\"javascript\",\"slug\":\"2023-12-30-01\",\"href\":\"/blog/javascript/2023-12-30-01\",\"frontmatter\":{\"id\":2,\"title\":\"AWS S3 를 사용한 PDF 뷰어 구현시, Metadata 설정\",\"description\":\"AWS S3 에 업로드한 PDF 파일이 렌더링되지 않고 다운로드 되는 이슈에 대한 정리 입니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"javascript\",\"PDF\",\"PDF Metadata\",\"AWS\",\"S3\"],\"createdAt\":\"$D2023-12-30T16:00:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$12\"},{\"category\":\"jest\",\"slug\":\"2024-01-06-01\",\"href\":\"/blog/jest/2024-01-06-01\",\"frontmatter\":{\"id\":4,\"title\":\"Nextjs 의 useRouter mock 정의하기\",\"description\":\"Nextjs 의 useRouter 를 사용하는 컴포넌트를 테스트하기 위한 방법을 정리합니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"jest\",\"@testing-library\",\"useRouter\",\"next-router-mock\",\"유닛 테스트\"],\"createdAt\":\"$D2024-01-06T17:30:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$13\"},{\"category\":\"jest\",\"slug\":\"2023-12-26-01\",\"href\":\"/blog/jest/2023-12-26-01\",\"frontmatter\":{\"id\":3,\"title\":\"\\\"styled-components\\\" 로 구현한 컴포넌트 테스트하기\",\"description\":\"\\\"styled-components\\\" 를 사용한 컴포넌트를 테스트하기 위한 환경설정에 대해 알아봅니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"jest\",\"styled-components\",\"@testing-library\",\"유닛 테스트\"],\"createdAt\":\"$D2023-12-26T23:50:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$14\"},{\"category\":\"jest\",\"slug\":\"2023-12-23-01\",\"href\":\"/blog/jest/2023-12-23-01\",\"frontmatter\":{\"id\":2,\"title\":\"\\\"jest.fn()\\\" 으로 함수 테스트하기\",\"description\":\"컴포넌트 props 로 넘겨주는 함수를 테스트하는 방법으로 \\\"jest.fn()\\\" 사용방법에 대한 정리 입니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"jest.fn\",\"jest\",\"@testing-library\",\"유닛 테스트\"],\"createdAt\":\"$D2023-12-23T14:45:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$15\"},{\"category\":\"llmops\",\"slug\":\"2023-12-16-01\",\"href\":\"/blog/llmops/2023-12-16-01\",\"frontmatter\":{\"id\":1,\"title\":\"LLMOps 와 친해지기 1 - 용어 정리\",\"description\":\"AI 학습 모델인 Large Language Model 에 대한 정리입니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[],\"createdAt\":\"$D2023-12-16T15:00:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$16\"},{\"category\":\"nextjs\",\"slug\":\"2024-01-01-01\",\"href\":\"/blog/nextjs/2024-01-01-01\",\"frontmatter\":{\"id\":2,\"title\":\".DS_Store not found 에러\",\"description\":\"Nextjs 빌드 시, .DS_Store 파일을 찾을 수 없다는 에러를 마주하게 되었습니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"nextjs\",\".DS_Store\"],\"createdAt\":\"$D2024-01-01T15:20:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"---\\nid: 2\\ntitle: .DS_Store not found 에러\\ndescription: 'Nextjs 빌드 시, .DS_Store 파일을 찾을 수 없다는 에러를 마주하게 되었습니다.'\\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\\n\\nfeatured: false\\ntags: [\\n    'nextjs',\\n    '.DS_Store',\\n]\\n\\ncreatedAt: '2024-01-01 15:20:00'\\nmodifiedHistories: []\\n---\\n\\n# .DS_Store not found 에러\\n\\nNextjs 프로젝트에 이미지 파일을 추가하고 삭제한 후, 빌드 에러가 발생하였습니다.\\n\\n\u003e Error: ENOENT: no such file or directory, open '/.../.DS_Store\\n\\n\\n\\n\u003cbr /\u003e\\n\\n\\n\\n## 에러 원인 파악\\n\\n.DS_Store 는 맥북의 폴더 관련 메타데이터 파일이며, Finder 로 폴더에 접근하게 되면 자동으로 생성됩니다.\\n\\n문제는 Nextjs 프로젝트를 개발 환경으로 실행하거나 빌드할 때, .DS_Store 파일이 추가되면, 빌드 에러가 발생합니다.\\n\\n\\n\\n\\n\u003cbr /\u003e\\n\\n\\n\\n## 해결 방법\\n\\n* 참고: [Stack Overflow](https://github.com/vercel/next.js/discussions/15573#discussioncomment-2415012)\\n\\n\u003cbr /\u003e\\n\\nNextjs 프로젝트 하위에 존재하는 .DS_Store 파일을 모두 삭제하는 것으로 해결할 수 있었습니다.\\n\\n모든 폴더를 직접 열어보면서 지우는 방법도 있겠지만, 터미널을 사용하여 삭제 명령으로 처리할 수 있습니다.\\n\\n```bash title=\\\"프로젝트 내의 모든 .DS_Store 파일 삭제\\\"\\nrm **/.DS_Store\\n```\\n\\n\u003cbr /\u003e\\n\\n삭제 명령이 실행 완료되면, Nextjs 프로젝트가 정상적으로 빌드되는 것을 확인할 수 있습니다.\\n\"},{\"category\":\"nextjs\",\"slug\":\"2023-12-16-01\",\"href\":\"/blog/nextjs/2023-12-16-01\",\"frontmatter\":{\"id\":1,\"title\":\"Nextjs 프로젝트의 유닛 테스트\",\"description\":\"유닛 테스트를 위해 Jest 와 @testing-library 설치 및 설정에 대한 정리 입니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"nextjs\",\"jest\",\"@testing-library\",\"react\",\"유닛 테스트\"],\"createdAt\":\"$D2023-12-16T22:13:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$17\"},{\"category\":\"react\",\"slug\":\"2023-12-19-01\",\"href\":\"/blog/react/2023-12-19-01\",\"frontmatter\":{\"id\":1,\"title\":\"Custom Hook 으로 분리하며 발생한 실수\",\"description\":\"Custom Hook 으로 분리한 useEffect 가 여러번 호출 케이스 중 한가지를 정리합니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"react\",\"custom hook\"],\"createdAt\":\"$D2023-12-19T22:50:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$18\"},{\"category\":\"threejs\",\"slug\":\"2024-01-07-02\",\"href\":\"/blog/threejs/2024-01-07-02\",\"frontmatter\":{\"id\":5,\"title\":\"그림자 표현하기\",\"description\":\"그림자 설정방법과 특징에 대해 정리합니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"javascript\",\"3d\",\"shadow\"],\"createdAt\":\"$D2024-01-07T23:50:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$19\"},{\"category\":\"threejs\",\"slug\":\"2024-01-07-01\",\"href\":\"/blog/threejs/2024-01-07-01\",\"frontmatter\":{\"id\":4,\"title\":\"평평한 바닥(땅) 만들기 (Plane Mesh)\",\"description\":\"바닥을 표현하기 위해 Plane Mesh 를 생성합니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"javascript\",\"3d\",\"plane\"],\"createdAt\":\"$D2024-01-07T23:20:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$1a\"},{\"category\":\"threejs\",\"slug\":\"2024-01-06-01\",\"href\":\"/blog/threejs/2024-01-06-01\",\"frontmatter\":{\"id\":3,\"title\":\"조명 종류와 설정\",\"description\":\"조명 종류와 설정 방법에 대해 정리합니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"javascript\",\"3d\",\"light\"],\"createdAt\":\"$D2024-01-06T23:00:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$1b\"},{\"category\":\"threejs\",\"slug\":\"2024-01-01-01\",\"href\":\"/blog/threejs/2024-01-01-01\",\"frontmatter\":{\"id\":2,\"title\":\"카메라 설정 (PerspectiveCamera)\",\"description\":\"Three.js 의 카메라인 PerspectiveCamera 설정에 대한 포스팅입니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"javascript\",\"3d\",\"camera\"],\"createdAt\":\"$D2024-01-01T23:50:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$1c\"}]}]\n"])</script><script>self.__next_f.push([1,""])</script></body></html><style data-styled="" data-styled-version="6.1.0"></style>