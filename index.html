<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/0c7e3e2387401c47-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" as="image" href="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg" fetchPriority="high"/><link rel="stylesheet" href="/_next/static/css/6566b64e7f0e478f.css" crossorigin="" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-14bcfdf71a1473f7.js" crossorigin=""/><script src="/_next/static/chunks/fd9d1056-9fe3c6d0c60c86d8.js" async="" crossorigin=""></script><script src="/_next/static/chunks/472-cf3134408a61a609.js" async="" crossorigin=""></script><script src="/_next/static/chunks/main-app-b1972c4cdd2be6d3.js" async="" crossorigin=""></script><script src="/_next/static/chunks/576-dc377cf448834f03.js" async=""></script><script src="/_next/static/chunks/251-ef7560cc4f7a9f6d.js" async=""></script><script src="/_next/static/chunks/app/layout-5bdea2f994faa404.js" async=""></script><script src="/_next/static/chunks/08ffe114-a8e3ed06beefbf38.js" async=""></script><script src="/_next/static/chunks/48507feb-6de01ca04009bb96.js" async=""></script><script src="/_next/static/chunks/39209d7c-a33d4549f726b4ab.js" async=""></script><script src="/_next/static/chunks/128-a9a4b8134fdbdc1d.js" async=""></script><script src="/_next/static/chunks/app/page-2a9b84f80b166504.js" async=""></script><title>Chocobe Blog v2</title><meta name="description" content="Frontend 기술 블로그 입니다."/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><meta name="next-size-adjust"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" crossorigin="" noModule=""></script><style data-styled="" data-styled-version="6.1.0">*{margin:0;padding:0;box-sizing:border-box;font-family:"Pretendard Variable",sans-serif;}/*!sc*/
body{width:100vw;height:100vh;overflow:hidden;}/*!sc*/
data-styled.g1[id="sc-global-eqoFij1"]{content:"sc-global-eqoFij1,"}/*!sc*/
.bogipj{display:flex;flex-wrap:wrap;gap:20px;}/*!sc*/
.bogipj >.navItem{padding:0 8px;color:#222;font-size:16px;line-height:24px;font-weight:500;}/*!sc*/
data-styled.g2[id="sc-4612defa-0"]{content:"bogipj,"}/*!sc*/
.fiXfoi{position:sticky;top:0;z-index:1;background-color:#E8F3F3;}/*!sc*/
.fiXfoi >.innerWrapper{margin:0 auto;padding:24px 20px 20px;width:100%;max-width:1200px;display:grid;grid-template-columns:repeat(3, 1fr);}/*!sc*/
.fiXfoi >.innerWrapper >.logoLink{display:flex;justify-content:center;align-items:flex-end;gap:4px;}/*!sc*/
.fiXfoi >.innerWrapper >.logoLink >.chocobe{padding:8px 4px 0;color:#fff;font-size:28px;line-height:20px;font-weight:600;background-color:#00AAA1;}/*!sc*/
.fiXfoi >.innerWrapper >.logoLink >.fe-blog{position:relative;color:#222;font-size:16px;line-height:16px;font-weight:600;}/*!sc*/
.fiXfoi >.innerWrapper >.logoLink >.fe-blog::before{content:'';width:4px;height:4px;display:block;position:absolute;bottom:2px;right:-6px;border-radius:50%;background-color:#00AAA1;}/*!sc*/
.fiXfoi >.innerWrapper >.headerActionsWrapper{display:flex;justify-content:flex-end;}/*!sc*/
data-styled.g3[id="sc-2b4c7cfd-0"]{content:"fiXfoi,"}/*!sc*/
.gWzijn{height:0;min-height:100%;}/*!sc*/
data-styled.g4[id="sc-6cb25f84-0"]{content:"gWzijn,"}/*!sc*/
.hoTFrx{width:100%;position:relative;border:1px solid #D9D9D9;overflow:hidden;}/*!sc*/
.hoTFrx >.decoratorYellow{width:45%;height:35%;position:absolute;top:0;right:0;transform:translate(100%, -100%);transition:all 0.18s ease-in-out;transition-delay:0.09s;background-color:#fff;}/*!sc*/
.hoTFrx >.decoratorGreen{width:100%;height:100%;position:absolute;top:0;left:0;transform:translate(-100%, 100%);transition:all 0.18s ease-in-out;background-color:#fff;}/*!sc*/
.hoTFrx >.content{padding:16px;width:100%;height:100%;position:sticky;top:0;left:0;}/*!sc*/
.hoTFrx >.content >.iconWrapper{padding:12px;width:fit-content;height:fit-content;color:#232536;border-radius:8px;background-color:#FBF6EA;transition:all 0.18s ease-in-out;}/*!sc*/
.hoTFrx >.content >.category{margin-top:16px;color:#232536;font-size:24px;line-height:36px;font-weight:700;transition:all 0.18s ease-in-out;}/*!sc*/
.hoTFrx >.content >.description{margin-top:8px;color:#6D6E76;font-size:16px;line-height:24px;font-weight:400;}/*!sc*/
.hoTFrx:hover{border-color:transparent;}/*!sc*/
.hoTFrx:hover >.decoratorYellow{background-color:#FFD050;transform:translate(0, 0);}/*!sc*/
.hoTFrx:hover >.decoratorGreen{background-color:#009189;transform:translate(-8px, 8px);}/*!sc*/
.hoTFrx:hover >.content >.iconWrapper{color:#009189;background-color:#FBF6EA;}/*!sc*/
.hoTFrx:hover >.content >.category{color:#fff;}/*!sc*/
.hoTFrx:hover >.content >.description{color:#eee;}/*!sc*/
data-styled.g5[id="sc-59513bf2-0"]{content:"hoTFrx,"}/*!sc*/
.kRxxxQ{display:flex;flex-wrap:wrap;gap:20px;}/*!sc*/
.kRxxxQ >.categoryItem{flex:1;min-width:300px;display:inline-block;}/*!sc*/
data-styled.g6[id="sc-1b3db0c2-0"]{content:"kRxxxQ,"}/*!sc*/
.gwGyTj{display:flex;border-radius:8px;box-shadow:1px 3px 6px 0 rgba(0, 0, 0, 0.2);overflow:hidden;transition:all 0.18s ease;}/*!sc*/
.gwGyTj >.thumbnailWrapper{flex-shrink:0;width:40%;height:auto;position:relative;}/*!sc*/
.gwGyTj >.thumbnailWrapper >.thumbnail{object-fit:cover;object-position:center;}/*!sc*/
.gwGyTj >.cardBody{flex:1;padding:20px 16px;width:100%;position:relative;color:#fff;}/*!sc*/
.gwGyTj >.cardBody >.hoverDecorator{width:50%;height:32px;position:absolute;top:0;right:0;transform:translate(100%, -100%);transition:all 0.18s ease-in-out;background-color:#fdd835;pointer-events:none;}/*!sc*/
.gwGyTj >.cardBody >.hoverDecorator::after{content:'';width:50%;height:50px;display:block;position:absolute;top:8px;right:8px;transform:translate(100%, 100%);transition:all 0.18s ease-in-out;transition-delay:0.09s;background-color:#009189;}/*!sc*/
.gwGyTj >.cardBody >.category{color:#592EA9;font-size:16px;line-height:24px;font-weight:600;}/*!sc*/
.gwGyTj >.cardBody >.title{margin-top:20px;color:#232536;font-size:24px;line-height:30px;font-weight:700;}/*!sc*/
.gwGyTj >.cardBody >.date{margin-top:16px;color:#4C4C4C;font-size:14px;line-height:22px;font-weight:500;}/*!sc*/
.gwGyTj >.cardBody >.description{margin-top:16px;color:#6D6E76;font-size:16px;line-height:24px;font-weight:400;white-space:pre-line;display:-webkit-box;overflow:hidden;-webkit-box-orient:vertical;-webkit-line-clamp:2;}/*!sc*/
.gwGyTj >.cardBody >.readMoreLink{margin-top:32px;padding:16px 48px;display:none;color:#fff;font-size:18px;line-height:28px;font-weight:700;background-color:#009189;}/*!sc*/
.gwGyTj:not([data-variant=featured]):hover{box-shadow:3px 6px 12px 0 rgba(0, 0, 0, 0.5);cursor:pointer;}/*!sc*/
.gwGyTj:not([data-variant=featured]):hover >.cardBody >.hoverDecorator{transform:translate(0, 0);}/*!sc*/
.gwGyTj:not([data-variant=featured]):hover >.cardBody >.hoverDecorator::after{transform:translate(0, 0);}/*!sc*/
.gwGyTj[data-variant=featured]{flex-flow:row-reverse;border-radius:0;box-shadow:none;}/*!sc*/
.gwGyTj[data-variant=featured] >.thumbnailWrapper{border-radius:8px;overflow:hidden;}/*!sc*/
.gwGyTj[data-variant=featured] >.cardBody >.hoverDecorator{display:none;}/*!sc*/
.gwGyTj[data-variant=featured] >.cardBody >.title{font-size:36px;line-height:40px;}/*!sc*/
.gwGyTj[data-variant=featured] >.cardBody >.description{display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:2;overflow:hidden;white-space:pre-line;}/*!sc*/
.gwGyTj[data-variant=featured] >.cardBody >.readMoreLink{display:inline-block;}/*!sc*/
.gwGyTj[data-variant=featured]:hover{box-shadow:none;}/*!sc*/
data-styled.g7[id="sc-ae8c9e8b-0"]{content:"gwGyTj,"}/*!sc*/
.kzwff{padding-bottom:20px;display:flex;flex-direction:column;gap:40px;}/*!sc*/
.kzwff >.featuredSection{padding:40px 0;background-color:#F2F8F7;}/*!sc*/
.kzwff >.featuredSection >.sectionContent{margin-left:auto;margin-right:auto;max-width:980px;}/*!sc*/
.kzwff >.commonSection{margin-left:auto;margin-right:auto;padding:0 40px;width:100%;max-width:calc(980px + (40px * 2));}/*!sc*/
.kzwff >.commonSection >.sectionHeader{display:flex;align-items:flex-start;gap:4px;border-bottom:4px solid #D9D9D9;}/*!sc*/
.kzwff >.commonSection >.sectionHeader >.sectionTitle{color:#232536;font-size:18px;line-height:24px;font-weight:700;}/*!sc*/
.kzwff >.commonSection >.sectionContent{margin-top:8px;}/*!sc*/
data-styled.g8[id="sc-3e8c62b1-0"]{content:"kzwff,"}/*!sc*/
</style></head><body class="__className_7bb6ba"><div class="w-full
            h-full
            overflow-y-scroll
            overflow-x-auto"><header class="sc-2b4c7cfd-0 fiXfoi"><div class="innerWrapper"><nav class="sc-4612defa-0 bogipj"><a class="navItem" href="/profile">Profile</a></nav><a class="logoLink" href="/"><span class="chocobe">Chocobe</span><span class="fe-blog">FE Blog</span></a></div></header><div style="min-height:calc(100% - 72px)" class="sc-6cb25f84-0 gWzijn"><div class="sc-3e8c62b1-0 kzwff"><section class="featuredSection"><div class="sc-ae8c9e8b-0 gwGyTj sectionContent" data-variant="featured"><figure class="thumbnailWrapper"><img alt="&quot;node:fs&quot; 테스트 하기" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">jest</div><div class="title">&quot;node:fs&quot; 테스트 하기</div><div class="date">작성일: </div><div class="description">node 모듈중 File System 기능, "fs" 를 테스트하는 방법에 대해 정리합니다.</div><a class="readMoreLink" href="/blog/jest/2023-12-17-01">Read More</a></div></div></section><section class="commonSection"><div class="sectionHeader"><svg stroke="currentColor" fill="none" stroke-width="2px" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="sectionIcon" height="20px" width="20px" xmlns="http://www.w3.org/2000/svg"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M9 6l11 0"></path><path d="M9 12l11 0"></path><path d="M9 18l11 0"></path><path d="M5 6l0 .01"></path><path d="M5 12l0 .01"></path><path d="M5 18l0 .01"></path></svg><div class="sectionTitle">All Categories</div></div><div class="sc-1b3db0c2-0 kRxxxQ sectionContent"><div role="listitem" class="sc-59513bf2-0 hoTFrx categoryItem"><div class="decoratorYellow"></div><div class="decoratorGreen"></div><div class="content"><div class="iconWrapper"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="20px" width="20px" xmlns="http://www.w3.org/2000/svg"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M20 4l-2 14.5l-6 2l-6 -2l-2 -14.5z"></path><path d="M7.5 8h3v8l-2 -1"></path><path d="M16.5 8h-2.5a.5 .5 0 0 0 -.5 .5v3a.5 .5 0 0 0 .5 .5h1.423a.5 .5 0 0 1 .495 .57l-.418 2.93l-2 .5"></path></svg></div><div class="category">Javascript</div><div class="description">Javascript 에 대한 보강할 부분들을 정리합니다.</div></div></div><div role="listitem" class="sc-59513bf2-0 hoTFrx categoryItem"><div class="decoratorYellow"></div><div class="decoratorGreen"></div><div class="content"><div class="iconWrapper"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="20px" width="20px" xmlns="http://www.w3.org/2000/svg"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M6.306 8.711c-2.602 .723 -4.306 1.926 -4.306 3.289c0 2.21 4.477 4 10 4c.773 0 1.526 -.035 2.248 -.102"></path><path d="M17.692 15.289c2.603 -.722 4.308 -1.926 4.308 -3.289c0 -2.21 -4.477 -4 -10 -4c-.773 0 -1.526 .035 -2.25 .102"></path><path d="M6.305 15.287c-.676 2.615 -.485 4.693 .695 5.373c1.913 1.105 5.703 -1.877 8.464 -6.66c.387 -.67 .733 -1.339 1.036 -2"></path><path d="M17.694 8.716c.677 -2.616 .487 -4.696 -.694 -5.376c-1.913 -1.105 -5.703 1.877 -8.464 6.66c-.387 .67 -.733 1.34 -1.037 2"></path><path d="M12 5.424c-1.925 -1.892 -3.82 -2.766 -5 -2.084c-1.913 1.104 -1.226 5.877 1.536 10.66c.386 .67 .793 1.304 1.212 1.896"></path><path d="M12 18.574c1.926 1.893 3.821 2.768 5 2.086c1.913 -1.104 1.226 -5.877 -1.536 -10.66c-.375 -.65 -.78 -1.283 -1.212 -1.897"></path><path d="M11.5 12.866a1 1 0 1 0 1 -1.732a1 1 0 0 0 -1 1.732z"></path></svg></div><div class="category">React</div><div class="description">React 를 사용하며 마주친 이슈나 생각을 정리하고자 합니다.</div></div></div><div role="listitem" class="sc-59513bf2-0 hoTFrx categoryItem"><div class="decoratorYellow"></div><div class="decoratorGreen"></div><div class="content"><div class="iconWrapper"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="20px" width="20px" xmlns="http://www.w3.org/2000/svg"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M9 15v-6l7.745 10.65a9 9 0 1 1 2.255 -1.993"></path><path d="M15 12v-3"></path></svg></div><div class="category">Nextjs</div><div class="description">SSR 과 CSR 을 자유롭게 사용할 수 있는 Nextjs 에 대한 정리입니다.</div></div></div><div role="listitem" class="sc-59513bf2-0 hoTFrx categoryItem"><div class="decoratorYellow"></div><div class="decoratorGreen"></div><div class="content"><div class="iconWrapper"><svg stroke="currentColor" fill="currentColor" stroke-width="0" role="img" viewBox="0 0 24 24" height="20px" width="20px" xmlns="http://www.w3.org/2000/svg"><title></title><path d="M22.251 11.82a3.117 3.117 0 0 0-2.328-3.01L22.911 0H8.104L11.1 8.838a3.116 3.116 0 0 0-2.244 2.988c0 1.043.52 1.967 1.313 2.536a8.279 8.279 0 0 1-1.084 1.244 8.14 8.14 0 0 1-2.55 1.647c-.834-.563-1.195-1.556-.869-2.446a3.11 3.11 0 0 0-.91-6.08 3.117 3.117 0 0 0-3.113 3.113c0 .848.347 1.626.903 2.182-.048.097-.097.195-.146.299-.465.959-.993 2.043-1.195 3.259-.403 2.432.257 4.384 1.849 5.489A5.093 5.093 0 0 0 5.999 24c1.827 0 3.682-.917 5.475-1.807 1.279-.632 2.599-1.292 3.898-1.612.48-.118.98-.187 1.508-.264 1.07-.153 2.175-.312 3.168-.89a4.482 4.482 0 0 0 2.182-3.091c.174-.994 0-1.994-.444-2.87.298-.48.465-1.042.465-1.647zm-1.355 0c0 .965-.785 1.75-1.75 1.75a1.753 1.753 0 0 1-1.085-3.126l.007-.007c.056-.042.118-.084.18-.125 0 0 .008 0 .008-.007.028-.014.055-.035.083-.05.007 0 .014-.006.021-.006.028-.014.063-.028.097-.042.035-.014.07-.027.098-.041.007 0 .013-.007.02-.007.028-.007.056-.021.084-.028.007 0 .02-.007.028-.007.034-.007.062-.014.097-.02h.007l.104-.022c.007 0 .02 0 .028-.007.028 0 .055-.007.083-.007h.035c.035 0 .07-.007.111-.007h.09c.028 0 .05 0 .077.007h.014c.055.007.111.014.167.028a1.766 1.766 0 0 1 1.396 1.723zM10.043 1.39h10.93l-2.509 7.4c-.104.02-.208.055-.312.09l-2.64-5.385-2.648 5.35c-.104-.034-.216-.055-.327-.076l-2.494-7.38zm4.968 9.825a3.083 3.083 0 0 0-.938-1.668l1.438-2.904 1.452 2.967c-.43.43-.743.98-.868 1.605H15.01zm-3.481-1.098c.034-.007.062-.014.097-.02h.02c.029-.008.056-.008.084-.015h.028c.028 0 .049-.007.076-.007h.271c.028 0 .049.007.07.007.014 0 .02 0 .035.007.027.007.048.007.076.014.007 0 .014 0 .028.007l.097.02h.007c.028.008.056.015.083.029.007 0 .014.007.028.007.021.007.049.014.07.027.007 0 .014.007.02.007.028.014.056.021.084.035h.007a.374.374 0 0 1 .09.049h.007c.028.014.056.034.084.048.007 0 .007.007.013.007.028.014.05.035.077.049l.007.007c.083.062.16.132.236.201l.007.007a1.747 1.747 0 0 1 .48 1.209 1.752 1.752 0 0 1-3.502 0 1.742 1.742 0 0 1 1.32-1.695zm-6.838-.049c.966 0 1.751.786 1.751 1.751s-.785 1.751-1.75 1.751-1.752-.785-1.752-1.75.786-1.752 1.751-1.752zm16.163 6.025a3.07 3.07 0 0 1-1.508 2.133c-.758.438-1.689.577-2.669.716a17.29 17.29 0 0 0-1.64.291c-1.445.355-2.834 1.05-4.182 1.717-1.724.854-3.35 1.66-4.857 1.66a3.645 3.645 0 0 1-2.154-.688c-1.529-1.056-1.453-3.036-1.272-4.12.167-1.015.632-1.966 1.077-2.877.028-.055.049-.104.077-.16.152.056.312.098.479.126-.264 1.473.486 2.994 1.946 3.745l.264.139.284-.104c1.216-.431 2.342-1.133 3.336-2.071a9.334 9.334 0 0 0 1.445-1.716c.16.027.32.034.48.034a3.117 3.117 0 0 0 3.008-2.327h1.167a3.109 3.109 0 0 0 3.01 2.327c.576 0 1.11-.16 1.57-.43.18.52.236 1.063.139 1.605z"></path></svg></div><div class="category">Jest</div><div class="description">Jest 를 사용한 유닛 테스트 관련 정리입니다.</div></div></div><div role="listitem" class="sc-59513bf2-0 hoTFrx categoryItem"><div class="decoratorYellow"></div><div class="decoratorGreen"></div><div class="content"><div class="iconWrapper"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" height="20px" width="20px" xmlns="http://www.w3.org/2000/svg"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 22l-5 -19l19 5.5z"></path><path d="M12.573 17.58l-6.152 -1.576l8.796 -9.466l1.914 6.64"></path><path d="M12.573 17.58l-1.573 -6.58l6.13 2.179"></path><path d="M9.527 4.893l1.473 6.107l-6.31 -1.564z"></path></svg></div><div class="category">Three.js</div><div class="description">3D 웹페이지 개발을 위한 Three.js 스터디 포스팅 입니다.</div></div></div><div role="listitem" class="sc-59513bf2-0 hoTFrx categoryItem"><div class="decoratorYellow"></div><div class="decoratorGreen"></div><div class="content"><div class="iconWrapper"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 640 512" height="20px" width="20px" xmlns="http://www.w3.org/2000/svg"><path d="M320 32c-8.1 0-16.1 1.4-23.7 4.1L15.8 137.4C6.3 140.9 0 149.9 0 160s6.3 19.1 15.8 22.6l57.9 20.9C57.3 229.3 48 259.8 48 291.9v28.1c0 28.4-10.8 57.7-22.3 80.8c-6.5 13-13.9 25.8-22.5 37.6C0 442.7-.9 448.3 .9 453.4s6 8.9 11.2 10.2l64 16c4.2 1.1 8.7 .3 12.4-2s6.3-6.1 7.1-10.4c8.6-42.8 4.3-81.2-2.1-108.7C90.3 344.3 86 329.8 80 316.5V291.9c0-30.2 10.2-58.7 27.9-81.5c12.9-15.5 29.6-28 49.2-35.7l157-61.7c8.2-3.2 17.5 .8 20.7 9s-.8 17.5-9 20.7l-157 61.7c-12.4 4.9-23.3 12.4-32.2 21.6l159.6 57.6c7.6 2.7 15.6 4.1 23.7 4.1s16.1-1.4 23.7-4.1L624.2 182.6c9.5-3.4 15.8-12.5 15.8-22.6s-6.3-19.1-15.8-22.6L343.7 36.1C336.1 33.4 328.1 32 320 32zM128 408c0 35.3 86 72 192 72s192-36.7 192-72L496.7 262.6 354.5 314c-11.1 4-22.8 6-34.5 6s-23.5-2-34.5-6L143.3 262.6 128 408z"></path></svg></div><div class="category">LLMOps</div><div class="description">LLMOps 를 통해 AI 와 가까워지기 위한 정리입니다.</div></div></div></div></section><section class="commonSection"><div class="sectionHeader"><svg stroke="currentColor" fill="none" stroke-width="2px" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="sectionIcon" height="20px" width="20px" xmlns="http://www.w3.org/2000/svg"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M9 6l11 0"></path><path d="M9 12l11 0"></path><path d="M9 18l11 0"></path><path d="M5 6l0 .01"></path><path d="M5 12l0 .01"></path><path d="M5 18l0 .01"></path></svg><div class="sectionTitle">All Blog Posts</div></div><div class="sectionContent flex flex-col gap-[20px]"><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="구조 분해 할당의 기본값 지정, null 은 사용 불가!" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">javascript</div><div class="title">구조 분해 할당의 기본값 지정, null 은 사용 불가!</div><div class="date">작성일: </div><div class="description">구조 분해 할당의 기본값 설정은 Nullish(undefined 와 null) 가 아닌, 오직 undefined 일 때만 적용됩니다.</div><a class="readMoreLink" href="/blog/javascript/2023-12-21-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="AWS S3 를 사용한 PDF 뷰어 구현시, Metadata 설정" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">javascript</div><div class="title">AWS S3 를 사용한 PDF 뷰어 구현시, Metadata 설정</div><div class="date">작성일: </div><div class="description">AWS S3 에 업로드한 PDF 파일이 렌더링되지 않고 다운로드 되는 이슈에 대한 정리 입니다.</div><a class="readMoreLink" href="/blog/javascript/2023-12-30-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="Nextjs 의 useRouter mock 정의하기" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">jest</div><div class="title">Nextjs 의 useRouter mock 정의하기</div><div class="date">작성일: </div><div class="description">Nextjs 의 useRouter 를 사용하는 컴포넌트를 테스트하기 위한 방법을 정리합니다.</div><a class="readMoreLink" href="/blog/jest/2024-01-06-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="&quot;styled-components&quot; 로 구현한 컴포넌트 테스트하기" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">jest</div><div class="title">&quot;styled-components&quot; 로 구현한 컴포넌트 테스트하기</div><div class="date">작성일: </div><div class="description">"styled-components" 를 사용한 컴포넌트를 테스트하기 위한 환경설정에 대해 알아봅니다.</div><a class="readMoreLink" href="/blog/jest/2023-12-26-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="&quot;jest.fn()&quot; 으로 함수 테스트하기" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">jest</div><div class="title">&quot;jest.fn()&quot; 으로 함수 테스트하기</div><div class="date">작성일: </div><div class="description">컴포넌트 props 로 넘겨주는 함수를 테스트하는 방법으로 "jest.fn()" 사용방법에 대한 정리 입니다.</div><a class="readMoreLink" href="/blog/jest/2023-12-23-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="LLMOps 와 친해지기 1 - 용어 정리" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">llmops</div><div class="title">LLMOps 와 친해지기 1 - 용어 정리</div><div class="date">작성일: </div><div class="description">AI 학습 모델인 Large Language Model 에 대한 정리입니다.</div><a class="readMoreLink" href="/blog/llmops/2023-12-16-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt=".DS_Store not found 에러" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">nextjs</div><div class="title">.DS_Store not found 에러</div><div class="date">작성일: </div><div class="description">Nextjs 빌드 시, .DS_Store 파일을 찾을 수 없다는 에러를 마주하게 되었습니다.</div><a class="readMoreLink" href="/blog/nextjs/2024-01-01-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="Nextjs 프로젝트의 유닛 테스트" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">nextjs</div><div class="title">Nextjs 프로젝트의 유닛 테스트</div><div class="date">작성일: </div><div class="description">유닛 테스트를 위해 Jest 와 @testing-library 설치 및 설정에 대한 정리 입니다.</div><a class="readMoreLink" href="/blog/nextjs/2023-12-16-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="Custom Hook 으로 분리하며 발생한 실수" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">react</div><div class="title">Custom Hook 으로 분리하며 발생한 실수</div><div class="date">작성일: </div><div class="description">Custom Hook 으로 분리한 useEffect 가 여러번 호출 케이스 중 한가지를 정리합니다.</div><a class="readMoreLink" href="/blog/react/2023-12-19-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="Particle 로 반딧불이 표현하기" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">Particle 로 반딧불이 표현하기</div><div class="date">작성일: </div><div class="description">3D 환경에서 반딧불이나 별을 표현할 때 Particle 을 활용합니다. 매우 많은 입자들로 표현하는 Particle 을 어떻게 구현하는지 정리하고자 합니다.</div><a class="readMoreLink" href="/blog/threejs/2024-02-29-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="Material 의 map, bumpMap, normalMap" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">Material 의 map, bumpMap, normalMap</div><div class="date">작성일: </div><div class="description">Material 의 표현 방식과 울퉁불퉁한 재질을 처리하는 방식을 정리합니다.</div><a class="readMoreLink" href="/blog/threejs/2024-02-12-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="click 이벤트에 animation 연동하기" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">click 이벤트에 animation 연동하기</div><div class="date">작성일: </div><div class="description">특정 버튼을 click 했을 때 animation 을 실행하는 방법을 정리합니다.</div><a class="readMoreLink" href="/blog/threejs/2024-02-06-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="Model 에 Click Event 적용하기 (추가: ToneMapping, light.shadow.camera)" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">Model 에 Click Event 적용하기 (추가: ToneMapping, light.shadow.camera)</div><div class="date">작성일: </div><div class="description">Canvas 에 렌더링된 Model 에 Click 인터렉션을 적용 해봅니다.</div><a class="readMoreLink" href="/blog/threejs/2024-02-03-02">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="(Issue) 조명이 어둡게 보이는 현상" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">(Issue) 조명이 어둡게 보이는 현상</div><div class="date">작성일: </div><div class="description">강좌의 결과물에 비해 실습 결과물의 밝기가 어둡게 렌더링되는 현상이 발생하였습니다. 현상 원인과 해결 방법에 대해 정리하고자 합니다.</div><a class="readMoreLink" href="/blog/threejs/2024-02-03-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="키보드를 사용하여 카메라 이동 인터렉션 만들기" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">키보드를 사용하여 카메라 이동 인터렉션 만들기</div><div class="date">작성일: </div><div class="description">키보드 입력에 대한 event listener 를 사용하여 카메라를 이동할 수 있는 인터렉션을 구현해 봅니다.</div><a class="readMoreLink" href="/blog/threejs/2024-01-30-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="canvas 크기 설정 및 material 렌더링 side 설정" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">canvas 크기 설정 및 material 렌더링 side 설정</div><div class="date">작성일: </div><div class="description">사용자 모니터 대응을 위한 WebGLRenderer 설정과 material 의 렌더링 side 설정에 대해 정리합니다.</div><a class="readMoreLink" href="/blog/threejs/2024-01-28-02">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="Model 에 Animation 효과 적용하기" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">Model 에 Animation 효과 적용하기</div><div class="date">작성일: </div><div class="description">Model 파일인 .gltf, .glb 에 Animation 을 적용하는 방법에 대해 정리합니다.</div><a class="readMoreLink" href="/blog/threejs/2024-01-26-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="Model (.gltf, .glb) 객체 구조파악 및 그림자 적용" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">Model (.gltf, .glb) 객체 구조파악 및 그림자 적용</div><div class="date">작성일: </div><div class="description">Three.js 환경에 불러온 Model 객체의 주요 구성요소를 파악하고, 속성값을 변경하여 그림자를 만들어 봅니다.</div><a class="readMoreLink" href="/blog/threejs/2024-01-21-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="모델 파일을 Three.js 에 렌더링하기" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">모델 파일을 Three.js 에 렌더링하기</div><div class="date">작성일: </div><div class="description">.gltf 또는 .glb 확장자인 모델 파일을 Three.js 에 불러오고 렌더링하는 방법을 정리합니다.</div><a class="readMoreLink" href="/blog/threejs/2024-01-10-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="배경화면 및 환경조명 설정하기" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">배경화면 및 환경조명 설정하기</div><div class="date">작성일: </div><div class="description">360도 이미지 확장자인 .hdr 파일을 사용하여 배경화면을 설정하고, 배경화면에 의한 환경조명 설정에 대한 정리입니다.</div><a class="readMoreLink" href="/blog/threejs/2024-01-08-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="그림자 표현하기" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">그림자 표현하기</div><div class="date">작성일: </div><div class="description">그림자 설정방법과 특징에 대해 정리합니다.</div><a class="readMoreLink" href="/blog/threejs/2024-01-07-02">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="평평한 바닥(땅) 만들기 (Plane Mesh)" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">평평한 바닥(땅) 만들기 (Plane Mesh)</div><div class="date">작성일: </div><div class="description">바닥을 표현하기 위해 Plane Mesh 를 생성합니다.</div><a class="readMoreLink" href="/blog/threejs/2024-01-07-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="조명 종류와 설정" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">조명 종류와 설정</div><div class="date">작성일: </div><div class="description">조명 종류와 설정 방법에 대해 정리합니다.</div><a class="readMoreLink" href="/blog/threejs/2024-01-06-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="카메라 설정 (PerspectiveCamera)" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">카메라 설정 (PerspectiveCamera)</div><div class="date">작성일: </div><div class="description">Three.js 의 카메라인 PerspectiveCamera 설정에 대한 포스팅입니다.</div><a class="readMoreLink" href="/blog/threejs/2024-01-01-01">Read More</a></div></div><div data-variant="normal" class="sc-ae8c9e8b-0 gwGyTj"><figure class="thumbnailWrapper"><img alt="Three.js 설치 및 실행" fetchPriority="high" decoding="async" data-nimg="fill" class="thumbnail" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg"/></figure><div class="cardBody"><div class="hoverDecorator"></div><div class="category">threejs</div><div class="title">Three.js 설치 및 실행</div><div class="date">작성일: </div><div class="description">Three.js 를 사용하기 위한 설치와 첫번째 화면을 그려봅니다.</div><a class="readMoreLink" href="/blog/threejs/2023-12-31-01">Read More</a></div></div></div></section></div></div></div><script src="/_next/static/chunks/webpack-14bcfdf71a1473f7.js" crossorigin="" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/0c7e3e2387401c47-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/6566b64e7f0e478f.css\",\"style\",{\"crossOrigin\":\"\"}]\n0:\"$L3\"\n"])</script><script>self.__next_f.push([1,"4:I[3728,[],\"\"]\n6:I[9928,[],\"\"]\n7:I[9248,[\"576\",\"static/chunks/576-dc377cf448834f03.js\",\"251\",\"static/chunks/251-ef7560cc4f7a9f6d.js\",\"185\",\"static/chunks/app/layout-5bdea2f994faa404.js\"],\"\"]\n8:I[179,[\"576\",\"static/chunks/576-dc377cf448834f03.js\",\"251\",\"static/chunks/251-ef7560cc4f7a9f6d.js\",\"185\",\"static/chunks/app/layout-5bdea2f994faa404.js\"],\"\"]\n9:I[6962,[\"576\",\"static/chunks/576-dc377cf448834f03.js\",\"251\",\"static/chunks/251-ef7560cc4f7a9f6d.js\",\"185\",\"static/chunks/app/layout-5bdea2f994faa404.js\"],\"\"]\na"])</script><script>self.__next_f.push([1,":I[6954,[],\"\"]\nb:I[7264,[],\"\"]\n"])</script><script>self.__next_f.push([1,"3:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/6566b64e7f0e478f.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]],[\"$\",\"$L4\",null,{\"buildId\":\"bTo6wyWnTWU_hu8lDfUVl\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/\",\"initialTree\":[\"\",{\"children\":[\"__PAGE__\",{}]},\"$undefined\",\"$undefined\",true],\"initialHead\":[false,\"$L5\"],\"globalErrorComponent\":\"$6\",\"children\":[null,[\"$\",\"html\",null,{\"lang\":\"ko\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_7bb6ba\",\"children\":[\"$\",\"div\",null,{\"className\":\"w-full\\n            h-full\\n            overflow-y-scroll\\n            overflow-x-auto\",\"children\":[\"$\",\"$L7\",null,{\"children\":[[\"$\",\"$L8\",null,{}],[\"$\",\"$L9\",null,{\"style\":{\"minHeight\":\"calc(100% - 72px)\"},\"children\":[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lb\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"childProp\":{\"current\":[\"$Lc\",\"$Ld\",null],\"segment\":\"__PAGE__\"},\"styles\":null}]}]]}]}]}]}],null]}]]\n"])</script><script>self.__next_f.push([1,"5:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Chocobe Blog v2\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"Frontend 기술 블로그 입니다.\"}],[\"$\",\"link\",\"4\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"meta\",\"5\",{\"name\":\"next-size-adjust\"}]]\nc:null\n"])</script><script>self.__next_f.push([1,"e:I[463,[\"281\",\"static/chunks/08ffe114-a8e3ed06beefbf38.js\",\"465\",\"static/chunks/48507feb-6de01ca04009bb96.js\",\"306\",\"static/chunks/39209d7c-a33d4549f726b4ab.js\",\"576\",\"static/chunks/576-dc377cf448834f03.js\",\"251\",\"static/chunks/251-ef7560cc4f7a9f6d.js\",\"128\",\"static/chunks/128-a9a4b8134fdbdc1d.js\",\"931\",\"static/chunks/app/page-2a9b84f80b166504.js\"],\"\"]\nf:T162a,"])</script><script>self.__next_f.push([1,"---\nid: 1\ntitle: '\"node:fs\" 테스트 하기'\ndescription: 'node 모듈중 File System 기능, \"fs\" 를 테스트하는 방법에 대해 정리합니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: true\ntags: [\n    'mock-fs',\n    'fs',\n    'node:fs',\n    'jest',\n    '@testing-library',\n    '유닛 테스트',\n]\n\ncreatedAt: '2023-12-17 15:33:00'\nmodifiedHistories: []\n---\n\n\n# \"node:fs\" 테스트 하기\n\nNextjs 를 사용하게 되면서 SSG(static site generators) 와 SSR(server side rendering) 을 사용하게 되었습니다.\n\n덕분에 CSR(client side rendering) 의 단점인 SEO 를 해소할 수 있게 되었습니다.\n\nSSG(static site generators) 와 SSR(server side rendering) 을 사용하게 되면, **node** 모듈들을 사용할 수 있습니다.\n\n이번 포스팅은 **node:fs** 를 사용하는 코드의 유닛 테스트 방법에 대해 정리합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## Jest 에서 안내하는 built-in modules 테스트\n\n* 참고: [[Jest 공식문서] Mocking Node modules](https://jestjs.io/docs/manual-mocks#mocking-node-modules)\n\n\u003cbr /\u003e\n\nJest 공식문서에 의하면, built-in modules 를 테스트하기 위해 몇가지 사전준비가 필요합니다.\n\n1. **node_modules** 와 인접한 경로에 **__mocks__** 폴더 만들기\n2. 테스트할 built-in module 과 동일한 이름의 파일(**fs.js**) 을 **__mocks__** 하위에 만들기\n3. **fs.js** 파일 구현하기\n    1. `jest.createMockFromModule('fs')` 를 호출하여 mock 적용하기\n    2. `fs` 의 메시드 중, 테스트 대상이 사용하는 모든 메서드에 mock 구현\n4. 유닛 테스트 파일에서 `jest.mock('fs')` 로 mock 적용하기\n\n\u003cbr /\u003e\n\n위 과정을 모두 구현할 수도 있지만, 좀 더 편리한 방법을 찾아본 결과 **mock-fs** 라는 라이브러리를 찾게 되었습니다.\n\n**mock-fs** 는 Jest 에서 안내하는 \"node:fs\" 테스트 준비 과정을 제공합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## **mock-fs** 설치하기\n\n만약 **Typescript** 를 사용한다면, **@types/mock-fs** 모듈도 함께 설치합니다.\n\n```bash title=\"Javascript 사용 시\" \nyarn add -D mock-fs\n```\n\n```bash title=\"Typescript 사용 시\"\nyarn add -D mock-fs @types/mock-fs\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## **node:fs** 테스크 코드 작성하기\n\n* 참고: [mock-fs 공식 문서](https://github.com/tschaub/mock-fs?tab=readme-ov-file#mock-fs)\n* 참고: [[지나가던 개발자]jest와 mock-fs로 fs 유닛 테스트하기](https://znagadeon.dev/post/test-fs/index.html)\n\n\u003cbr /\u003e\n\n**mock-fs** 를 사용하게 되면 아래의 2가지 작업이 필요합니다.\n\n* `jest.beforeEach()`: **mock-fs** 를 사용한 file system mockup\n* `jest.afterEach()`: **mock-fs** 해제\n\n\u003cbr /\u003e\n\n먼저 테스트 준비를 위한 mockup 을 구현하면 다음과 같습니다.\n\n```typescript showLineNumbers\nimport mock from 'mock-fs';\n\ndescribe('mock-fs 를 사용한 \"node:fs\" 테스트', () =\u003e {\n    beforeEach(() =\u003e {\n        mock({\n            '경로1': {\n                '하위_경로1': {\n                    '파일_1.mdx': '파일 내용 mockup',\n                    '파일_2.mdx': '파일 내용 mockup',\n                },\n            },\n            '경로2/경로3': {\n                '하위_경로2': {\n                    // 빈 폴더\n                },\n            },\n        });\n    });\n});\n```\n\n\u003cbr /\u003e\n\n이제 **node:fs** 는 mockup 에서 정의한 mock file system 을 사용하게 됩니다.\n\n```typescript {22} showLineNumbers\nimport fs from 'node:fs/promises';\nimport mock from 'mock-fs';\n\ndescribe('mock-fs 를 사용한 \"node:fs\" 테스트', () =\u003e {\n    beforeEach(() =\u003e {\n        mock({\n            '경로1': {\n                '하위_경로1': {\n                    '파일_1.mdx': '파일 내용 mockup',\n                    '파일_2.mdx': '파일 내용 mockup',\n                },\n            },\n            '경로2/경로3': {\n                '하위_경로2': {\n                    // 빈 폴더\n                },\n            },\n        });\n    });\n\n    it('\"node:fs\" 를 사용하여 파일을 가져올 수 있다.', async () =\u003e {\n        const fileNameList = await fs.readdir('경로1/하위_경로1');\n\n        expect(fileNameList).toEqual([\n            '파일_1.mdx',\n            '파일_2.mdx',\n        ]);\n    });\n});\n```\n\n\u003cbr /\u003e\n\n마지막으로 **mock-fs** 를 해제할 수 있도록 `jest.afterEach()` 를 작성하면 \"node:fs\" 유닛 테스트는 작성완료 됩니다.\n\n```typescript {21} showLineNumbers\nimport fs from 'node:fs/promises';\nimport mock from 'mock-fs';\n\ndescribe('mock-fs 를 사용한 \"node:fs\" 테스트', () =\u003e {\n    beforeEach(() =\u003e {\n        mock({\n            '경로1': {\n                '하위_경로1': {\n                    '파일_1.mdx': '파일 내용 mockup',\n                    '파일_2.mdx': '파일 내용 mockup',\n                },\n            },\n            '경로2/경로3': {\n                '하위_경로2': {\n                    // 빈 폴더\n                },\n            },\n        });\n    });\n\n    afterEach(mock.restore);\n\n    it('\"node:fs\" 를 사용하여 파일을 가져올 수 있다.', async () =\u003e {\n        const fileNameList = await fs.readdir('경로1/하위_경로1');\n\n        expect(fileNameList).toEqual([\n            '파일_1.mdx',\n            '파일_2.mdx',\n        ]);\n    });\n});\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\n이번 포스팅에서는 built-in modules 중 \"fs\" 를 테스트하는 방법에 대해 정리해 보았습니다.\n\n\"fs\" 가 아닌 다른 module 에 대한 테스트를 한다면, 결국은 Jest 공식문서에서 안내하는 mockup 방법도 사용해 보아야 할 것 같습니다.\n"])</script><script>self.__next_f.push([1,"10:Te10,"])</script><script>self.__next_f.push([1,"---\nid: 10\ntitle: 'Gamma, GammFactor, sRGB 정리'\ndescription: '디지털 환경에서 색상을 표현하는데 사용되는 일부 개념들을 정리합니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: true\ntags: [\n    'threejs',\n    'gamma',\n    'gamma factor',\n    'sRGB',\n]\n\ncreatedAt: '2024-01-28 18:00:00'\nmodifiedHistories: []\n---\n\n# Gamma, GammFactor, sRGB 정리\n\nThree.js 를 스터디하며 아래와 같은 용어를 접하게 되었습니다.\n\n* Gamma\n* GammaFactor`\n* sRGB\n\n\u003cbr /\u003e\n\n이번 포스팅에서는 위 용어에 대한 개념을 정리하고 Three.js 에서는 어떻게 설정할 수 있는지 살펴 보겠습니다.\n\n\u003e 참고: [What is Gamma? - Benq](https://www.benq.com/en-us/knowledge-center/knowledge/gamma-monitor.html)\n\u003e\n\u003e 참고: [Deprecated Gamma Correction Alternative - discourse.threejs](https://discourse.threejs.org/t/deprecated-gamma-correction-alternative/57170)\n\u003e\n\u003e 참고: [sRGB - 위키피디아](https://en.wikipedia.org/wiki/SRGB)\n\n\n\n\u003cbr /\u003e\n\n\n\n## Gamma 란?\n\nGamma 는 이미지나 색상을 처리하는 기술 중 하나입니다.\n\n**색상간의 밝기와 대비를 보정** 하거나, 사용자 **모니터의 특성을 보상** 하기 위해 사용되는 기술입니다.\n\n\u003cbr /\u003e\n\n좀 더 구체적으로 정의한다면 다음과 같습니다.\n\n* **디지털 환경에서 Black 과 White 사이를 얼마나 부드럽게 전환(표현)할 것인지에 대한 수치** 입니다.\n\n\u003cbr /\u003e\n\nGamma 는 **sRGB (Standard RGB)** 환경에서 사용되는 개념이며, 아래에서 정리하겠습니다.\n\n\u003cbr /\u003e\n\nGamma 는 일반적으로 **2.2** 값을 사용합니다.\n\n이 값은 **Gamma Curve** 를 그리는 연산식의 도출값인데, 값에 따른 차이를 비교하면 아래와 같습니다.\n\n\u003e 이미지 출처: [Deprecated Gamma Correction Alternative - discourse.threejs](https://discourse.threejs.org/t/deprecated-gamma-correction-alternative/57170)\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-28-01/2024-01-28-01-01.png\" alt=\"Gamma\" /\u003e\n\n\u003cbr /\u003e\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-28-01/2024-01-28-01-02.png\" alt=\"Gamma\" /\u003e\n\n\u003cbr /\u003e\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-28-01/2024-01-28-01-03.png\" alt=\"Gamma\" /\u003e\n\n\n\n## GammaFactor\n\nGammaFactor 는 Three.js 에서 Gamma 를 지칭하는 property 입니다.\n\nThree.js 구버전에서는 `WebGLRenderer` 인스턴스의 property 로 `gammaFactor` 를 설정할 수 있었습니다.\n\n`gammaFactor` 는 Three.js 에서 **Deprecated** 되었고, 포스팅을 작성하는 시점의 Three.js 최신 버전인 `0.160.1` 에서는 사라진 설정입니다.\n\n\u003cbr /\u003e\n\n만약 구버전 Three.js 코드에서 `gammaFactor` 설정을 보게 된다면, 최신 버전에서는 **Light** 인스턴스의 **intensity (빛의 강함 설정)** 을 사용해 봅시다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## sRGB\n\nsRGB 는 **Standard RGB Color Space** 의 약자 입니다.\n\n모니터, 프린터, 웹 과 같은 디지털 환경에서 색상을 표현하귀 위한 **표준 색상 공간(환경)** 입니다.\n\n앞서 살펴보았던 **Gamma 의 기본값이 2.2 인 것은 sRGB 의 값을 2.2 로 사용** 한다는 의미로 보여집니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\nThree.js 스터디를 하는 중, gammaFactor 설정이 궁금하여 이번 포스팅을 작성하게 되었습니다.\n\n의미와 용도 정도만 파악하려는 목적이었지만, gamma 와 sRGB 는 상당히 깊고 어려운 내용이었습니다.\n\n지금은 간단한 의미 정도만 파악한 후, 차후 필요성이 생겼을 때 좀 더 깊게 알아볼 예정입니다.\n"])</script><script>self.__next_f.push([1,"11:T1171,"])</script><script>self.__next_f.push([1,"---\nid: 1\ntitle: 구조 분해 할당의 기본값 지정, null 은 사용 불가!\ndescription: '구조 분해 할당의 기본값 설정은 Nullish(undefined 와 null) 가 아닌, 오직 undefined 일 때만 적용됩니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'javascript',\n]\n\ncreatedAt: '2023-12-21 20:20:00'\nmodifiedHistories: []\n---\n\n# 구조 분해 할당의 기본값 지정, Null 은 사용 불가!\n\nplain object 를 사용하여, 데이터를 의미단위로 묶어서 사용합니다.\n\n의미를 가지는 key 와 쌍을 이루는 value 로 구성되며, Javascript built-in object 에도 많은 기능을 제공합니다.\n\n이번 포스팅에서는 이러한 plain object 의 기능들 중, **구조 분해 할당의 기본값 설정** 에 대해 정리합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 구조 분해 할당의 기본값\n\n구조 분해 할당은 plain object 의 하위 프로퍼티에 좀 더 효율적으로 참조하는 기능입니다.\n\n```javascript title=\"구조 분해 할당 예시\" showLineNumbers {8-14}\nconst obj = {\n    keyA: 'value a',\n    keyB: 'value b',\n    keyC: undefined,\n    keyD: null,\n};\n\n// 구조 분해 할당\nconst {\n    keyA,\n    keyB,\n    keyC,\n    keyD,\n} = obj;\n```\n\n\u003cbr /\u003e\n\n위 예시처럼 value 가 `undefined` 인 경우도 있고, `null` 인 경우가 있었습니다.\n\n이러한 경우 **기본값을 지정하여 유효한 value 를 보장** 하도록 의도하였습니다.\n\n```javascript title=\"구조 분해 할당의 기본값 예시\" showLineNumbers {8-14}\nconst obj = {\n    keyA: 'value a',\n    keyB: 'value b',\n    keyC: undefined,\n    keyD: null,\n};\n\n// 구조 분해 할당 기본값 지정\nconst {\n    keyA,\n    keyB,\n    keyC =. '빈 값',\n    keyD = '빈 값',\n};\n```\n\n\u003cbr /\u003e\n\n여기서 제가 실수한 부분이 있습니다.\n\n~~`value` 가 `Nullish (undefined 또는 null)` 일 경우, 기본값을 설정할 수 있다고 생각했습니다.~~\n\n하지만 `null` 에는 기본값 설정이 불가능 하고, **`value` 가 `undefined` 일 경우에만 기본값을 설정** 할 수 있었습니다.\n\n* [MDN - 구조 분해 할당](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%EA%B8%B0%EB%B3%B8%EA%B0%92)\n\n\u003cbr /\u003e\n\n제가 실수한 부분이 일으킨 이슈는 아래의 코드와 같습니다.\n\n```javascript title=\"구조 분해 할당의 기본값 이슈\" showLineNumbers {11-12, 15-17}\nconst obj = {\n    keyA: 'value a',\n    keyB: 'value b',\n    keyC: undefined,\n    keyD: null,\n};\n\nconst {\n    keyA,\n    keyB,\n    keyC = '값 없음',\n    keyD = '값 없음',\n} = obj;\n\n// 에러 발생\n// Error: Cannot read properties of null (reading 'toUpperCase')\nconsole.log('keyD.toUpperCase(): ', keyD.toUpperCase());\n```\n\n\u003cbr /\u003e\n\n`keyD` 에 기본값을 `string` 으로 지정하였지만, `null` 이므로 기본값 지정이 적용되지 않습니다.\n\n그러므로 `keyD.toUpperCase()` 를 호출할 경우, `null` 에 대한 메소드 호출이 되며 에러가 발생하게 됩니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## null 은 명시적으로 표현한 값이 없음!\n\n값이 없을을 나타내는 `undefined` 와 `null` 은 타입도 다르지만, 더 **중요한 것은 의미** 인 것 같습니다.\n\n변수나 프로퍼티에 할당한 값이 없는 경우 `undefined` 를 가지고, `null` 은 개발자가 의도를 가지고 값을 비운다는 의미입니다.\n\n즉, 의도를 가지고 비워둔 값에는 구조 분해 할당의 기본값이 적용되지 않는 것 입니다.\n\n\u003cbr /\u003e\n\n만약 `Nullish` 에 대한 기본값을 지정하고 싶을 경우는 **Nullish 병합 연산자** 를 사용합니다.\n\n```javascript title=\"Nullish 병합 연산자\" showLineNumbers {11-12, 15-16}\nconst obj = {\n    keyA: 'value a',\n    keyB: 'value b',\n    keyC: undefined,\n    keyD: null\n};\n\nconst {\n    keyA,\n    keyB,\n    keyC: _keyC,\n    keyD: _keyD,\n};\n\nconst keyC = _keyC ?? '값 없음';\nconst keyD = _keyD ?? '값 없음';\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 유감스러운 구조 분해 할당의 기본값\n\n`undefined` 뿐만 아니라, `Nullish` 에 대한 기본값을 설정하고 싶다면, 위 예시코드와 같이 코드 1줄씩 추가로 작성하게 됩니다.\n\n이 기능의 의미는 이해하지만, 작성할 코드가 늘어난다는 점에서는 아쉽습니다.\n\n\u003cbr /\u003e\n\n다른분들은 저와 같은 실수가 없기를 바라며, 이번 포스팅을 마무리 합니다.\n"])</script><script>self.__next_f.push([1,"12:T1174,"])</script><script>self.__next_f.push([1,"---\nid: 2\ntitle: AWS S3 를 사용한 PDF 뷰어 구현시, Metadata 설정\ndescription: 'AWS S3 에 업로드한 PDF 파일이 렌더링되지 않고 다운로드 되는 이슈에 대한 정리 입니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'javascript',\n    'PDF',\n    'PDF Metadata',\n    'AWS',\n    'S3',\n]\n\ncreatedAt: '2023-12-30 16:00:00'\nmodifiedHistories: []\n---\n\n# 웹에서 PDF 뷰어를 제공하는 방법\n\nPDF 파일은 범용적으로 사용되는 문서 파일 입니다.\n\nPDF 뷰어를 제공하는 방법에는 여러가지가 있습니다.\n\n* `\u003ciframe /\u003e`, `\u003cobject /\u003e`, `\u003cembed /\u003e` 태그\n* PDF 뷰어 관련 라이드러리들\n\n\n\n\u003cbr /\u003e\n\n\n\n## `\u003cobject /\u003e` 를 사용한 PDF 뷰어 구현하기\n\nPDF 파일은 브라우저 내장 뷰어에서 다양한 기능을 제공합니다.\n\n구현 초기에는 `\u003ciframe /\u003e` 이나 `\u003cobject /\u003e` 의 보안문제를 피하기 위해, PDF 라이브러리를 사용하고자 하였습니다.\n\n하지만 브라우저의 내장 PDF 뷰어의 강력한 기능들을 포기하거나 직접 구현해야 하는 문제가 있습니다.\n\n\u003cbr /\u003e\n\n이러한 이유로 `\u003cobject /\u003e` 태그를 사용하여 PDF 뷰어를 사용하기로 하였습니다.\n\n또한 `\u003ciframe /\u003e` 보다는 `\u003cobject /\u003e` 태그가 PDF 에는 적합하다는 MDN 공식문서에 따르게 되었습니다.\n\n* 참고: [MDN 공식 문서](https://developer.mozilla.org/ko/docs/Learn/HTML/Multimedia_and_embedding/Other_embedding_technologies#embed_%EC%99%80_object_%EC%9A%94%EC%86%8C)\n\n\n\n\u003cbr /\u003e\n\n\n\n## `\u003cobject /\u003e` 를 사용하여 간단한 PDF 뷰어 만들기\n\n아래와 같이 `\u003cobject /\u003e` 태그를 사용하여 간단하게 PDF 뷰어 기능을 사용할 수 있습니다.\n\n```tsx title=\"PDF 뷰어 예시 코드\" showLineNumbers\ntype TMyPdfViewerProps = {\n    url: string;\n}\n\nfunction MyPdfViewer(props: TMyPdfViewerProps) {\n    const {\n        url,\n    } = props;\n\n    const data = `${url}#view=FitH`;\n\n    return (\u003c\u003e\n        \u003cobject \n            data={data}\n            type='application/pdf' \n            width='100%' \n            height='100%' /\u003e\n    \u003c/\u003e);\n}\n\nexport default MyPdfViewer;\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## AWS S3 에 업로드한 PDF 파일이 다운로드되는 이슈\n\nAWS S3 는 널리 사용되는 클라우드 스토리지 입니다.\n\nPDF 파일을 S3 에 업로드한 후, `\u003cMyPdfViewer /\u003e` 컴포넌트로 보여주고자 합니다.\n\n만약 단순히 S3 에 PDF 파일을 업로드 했다면, `\u003cobject /\u003e` 에 연동한 **PDF 파일이 렌더링 되지 않고 다운로드되는 현상**을 마주하게 됩니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## PDF 파일이 다운로드만 되는 이유\n\nAWS S3 에 파일을 업로드할 경우, 별도의 설정을 하지 않는다면 아래와 같은 **Metadata** 기본값으로 설정됩니다.\n\n* `Content-Type: binary/octet-stream`\n* `Content-Disposition: attachment`\n\n\u003cbr /\u003e\n\n위와 같은 파일을 브라우저에서 요청할 경우, 해당 파일은 첨부파일로 인식하고 다운로드하는 동작을 하게 됩니다.\n\nAWS S3 에 업로드한 파일이 **단순 첨부파일 응답 으로 처리되기 때문에** `\u003cobject /\u003e` 태그에 렌더링되는 것이 아닌 다운로드가 됩니다.\n\n\u003cbr /\u003e\n\n이를 PDF 뷰어로 동작하도록 하려면, **AWS S3 에 업로드한 PDF 파일의 Metadata 를 아래와 같이 수정** 해서 해결할 수 있습니다.\n\n* `Content-Type: application/pdf`\n* `Content-Disposition: inline`\n\n\u003cbr /\u003e\n\n위와 같이 Metadata 를 변경했다면, `\u003cobject /\u003e` 태그에서 요청한 PDF 파일은 다운로드되지 않고 브라우저 내장 PDF 뷰어로 렌더링됩니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\n이번 이슈를 해결하기 위해, 최초 시도했던 방법은 AWS S3 에 PDF 파일을 별도로 요청한 후, 응답 결과인 PDF 파일 데이터를 `Blob` 으로 wrapping 하는 방식을 구현했습니다.\n\n하지만 이렇게 wrapping 한 Blob 은 파일내용에 따라 렌더링이 되지 않는 이슈가 발생하였습니다.\n\nBlob 으로 변환한 PDF 파일을 다운로드하여 확인하면 정상적으로 열리지만 `\u003cobject /\u003e` 태그에 렌더링되지 않는 경우가 있다보니, AWS S3 에 업로드한 파일의 Metadata 를 수정하는 방법을 사용하게 되었습니다.\n\n이번 이슈를 통해, 파일을 다루는 경우에는 Metadata 에 대한 확인 및 설정이 필요하다는 것을 배우게 되었습니다.\n"])</script><script>self.__next_f.push([1,"13:T1598,"])</script><script>self.__next_f.push([1,"---\nid: 4\ntitle: 'Nextjs 의 useRouter mock 정의하기'\ndescription: 'Nextjs 의 useRouter 를 사용하는 컴포넌트를 테스트하기 위한 방법을 정리합니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'jest',\n    '@testing-library',\n    'useRouter',\n    'next-router-mock',\n    '유닛 테스트',\n]\n\ncreatedAt: '2024-01-06 17:30:00'\nmodifiedHistories: []\n---\n\n# Nextjs 의 useRouter mock 정의하기\n\n페이지 이동을 위한 컴포넌트는 웹페이지에서 빠질 수 없는 컴포넌트 입니다.\n\nNextjs 프로젝트에서 페이지 이동은 Nextjs 의 `useRouter` hook 을 사용하여 구현합니다.\n\n이러한 컴포넌트는 내부에서 `useRouter` 를 사용하고 있기 때문에, Jest 의 `render()` 를 사용한 렌더링 시, 에러가 발생하게 됩니다.\n\n이번 포스팅에서는 `useRouter` 를 mocking 하여 테스트 하는 방법에 대해 정리하고자 합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 컴포넌트 렌더링 실패\n\n`useRouter` 를 사용하는 컴포넌트를 아무런 설정없이 Jest 의 `render()` 를 실행시키면, 렌더링 에러가 발생합니다.\n\n이는 테스트 환경에서 `useRouter()` 가 렌더링 되지 않으면서 발생하게 됩니다.\n\n이를 해결하기 위해, `next-router-mock` 라이브러리를 활용할 수 있습니다.\n\n```bash\nyarn add -D next-router-mock\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## `useRouter` 를 사용하는 테스트용 컴포넌트\n\n이번 포스트에서 테스트할 컴포넌트는 아래와 같습니다.\n\n`onClick()` 내부에서 `router.push()` 를 사용하여 페이지를 이동 시키는 동작을 합니다.\n\n```tsx title=\"MyAnchor.tsx\" showLineNumbers\nimport {\n    useCallback,\n    PropsWithChildren,\n} from 'react';\nimport {\n    useRouter,\n} from 'next/navigation';\n\ntype TMyAnchorProps = PropsWithChildren\u003c{\n    className?: string;\n    href: string;\n}\u003e;\n\nfunction MyAnchor(props: TMyAnchorProps) {\n    const {\n        className,\n        href,\n        children,\n    } = props;\n\n    const router = useRouter();\n\n    const onClick = useCallback(() =\u003e {\n        router.push(href);\n    }, [href]);\n\n    return (\n        \u003ca \n            className={className}\n            href={href}\u003e\n            {children}\n        \u003c/a\u003e\n    );\n}\n\nexport default MyAnchor;\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## `jest.mock()` 을 사용하여 `useRouter()` mocking 하기\n\n`jest.mock()` 을 사용하면, 특정 모듈을 mocking 할 수 있습니다.\n\n이를 활용하여, `next/navigation` 모듈을 mocking 하여 `useRouter` 가 테스트 환경에서 렌더링될 수 있도록 합니다.\n\n```ts title=\"jest.mock() 으로 useRouter mocking 하기\"\njest.mock('next/navigation', () =\u003e jest.requireActual('next-router-mock'));\n```\n\n* `jest.mock()`: 특정 모듈을 mocking 합니다.\n    * 첫번째 인자: mocking 할 모듈명\n    * 두번째 인자: mocking 반환 함수\n* `jest.requireActual()`: 실제 모듈을 가져옵니다. (`import`, `require`)\n\n\u003cbr /\u003e\n\n위 코드를 사용하여 `useRouter` 를 mocking 하게 되면, 정상적으로 렌더링됨을 확인할 수 있습니다.\n\n아래는 테스트 예시 코드 입니다.\n\n```tsx title=\"MyAnchor 테스트\" showLineNumbers {7, 9, 12-15, 48-50}\nimport MyAnchor from './MyAnchor';\nimport {\n    render,\n    screen,\n} from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport mockRouter from 'next-router-mock';\n\njest.mock('next/navigation', () =\u003e jest.requireActual('next-router-mock'));\n\ndescribe('\u003cMyAnchor /\u003e 테스트', () =\u003e {\n    beforeEach(() =\u003e {\n        // mockRouter 의 pathname 을 '/' 으로 초기화 합니다.\n        mockRouter.push('/');\n    });\n\n    it('DOM 에 렌더링 된다.', () =\u003e {\n        render(\n            \u003cdiv data-testid=\"test-MyAnchor\"\u003e\n                \u003cMyAnchor href=\"/test-url\"\u003e\n                    Test Page\n                \u003c/MyAnchor\u003e\n            \u003c/div\u003e\n        );\n\n        const $anchor = screen.getByTestId('test-MyAnchor');\n\n        expect($anchor).toBeInTheDocument();\n    });\n\n    it('click 시, href 경로로 페이지 이동한다.', async () =\u003e {\n        render(\n            \u003cdiv data-testid=\"test-MyAnchor\"\u003e\n                \u003cMyAnchor \n                    className=\"test-className\"\n                    href=\"test-url\"\u003e\n                    Test Page\n                \u003c/MyAnchor\u003e\n            \u003c/div\u003e\n        );\n\n        const $anchor = screen\n            .getByTestId('test-MyAnchor')\n            .querySelector('.test-className');\n\n        await userEvent.click($anchor);\n\n        expect(mockRouter).toMatchObject({\n            pathname: '/test-url',\n        });\n    });\n});\n```\n\n\u003cbr /\u003e\n\n그리고 `router` 가 클릭된 후, 페이지 이동이 되었는지 테스트하기 위해, `mockRouter` 를 활용할 수 있습니다.\n\n`mockRouter` 의 `pathname` 에 이동할 페이지의 url 이 반영되었다면, 실제로는 페이지 이동이 된 것으로 볼 수 있습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\n프레임워크는 개발에 필요한 다양한 기능을 제공합니다.\n\n이를 테스트하기 위해서는 프레임워크와 동일한 환경을 만들어주어야 함을 알게 되었습니다.\n\n단순 컴포넌트나 함수를 테스트할 때는 신경쓰지 않았던 **모듈 mocking** 이 필요하고, `jest.mock()` 을 사용하여 mocking 할 수 있었습니다.\n\n`next-router-mock` 라이브러리 처럼 오픈 소스 문화가 있기에 저도 웹 개발을 할 수 있음을 새삼 느끼게 됩니다. 🫠\n"])</script><script>self.__next_f.push([1,"14:T14bb,"])</script><script>self.__next_f.push([1,"---\nid: 3\ntitle: '\"styled-components\" 로 구현한 컴포넌트 테스트하기'\ndescription: '\"styled-components\" 를 사용한 컴포넌트를 테스트하기 위한 환경설정에 대해 알아봅니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'jest',\n    'styled-components',\n    '@testing-library',\n    '유닛 테스트',\n]\n\ncreatedAt: '2023-12-26 23:50:00'\nmodifiedHistories: []\n---\n\n# styled-components 로 구현한 컴포넌트 테스트하기\n\n컴포넌트의 style 작성에는 여러가지 선택지가 있습니다.\n\n그 중 저는 **styled-components** 를 가장 선호합니다.\n\n이번 포스팅에서는 **styled-components** 를 사용한 컴포넌트를 테스트하기 위한 jest 환경을 설정해보겠습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 설정없이 jest 를 실행하면? throw Error!\n\n**styled-components** 는 `\u003cThemeProvider /\u003e` 하위에서 사용할 수 있습니다.\n\n만약 추가 설정없이 jest 를 실행하게 되면, `render()` 호출에서 에러가 발생합니다.\n\n```tsx title=\"에러 발생 예시\" showLineNumbers {10-12}\nimport MyComponent from './MyComponent';\nimport {\n    render,\n} from '@testing-library/react';\n\ndescribe('MyComponent 테스트', () =\u003e {\n    it('DOM 에 렌더링 된다.', () =\u003e {\n        // render() 호출 시, Error 발생\n        render(\n            \u003cdiv data-testid=\"my-component\"\u003e\n                \u003cMyComponent /\u003e\n            \u003c/div\u003e\n        );\n\n        const $myComponent = screen.getByTestId('my-component');\n\n        expect($myComponent).toBeInTheDocument();\n    });\n});\n```\n\n```bash title=\"에러 메시지\"\nTypeError: Cannot read properties of undefined (reading 'MarkdownAnchor')\n```\n\n\u003cbr /\u003e\n\n아래와 같이 `render()` 호출부에 `\u003cThemeProvider /\u003e` 를 함께 넘겨주면 테스트가 정상적으로 실행되는 것을 확인할 수 있습니다.\n\n```tsx title=\"테스트 정상 동작\" showLineNumbers {11, 13}\nimport MyComponent from './MyComponent';\nimport {\n    render,\n} from '@testing-library/react';\n\ndescribe('MyComponent 테스트', () =\u003e {\n    it('DOM 에 렌더링 된다.', () =\u003e {\n        // render() 성공\n        render(\n            \u003cdiv data-testid=\"my-component\"\u003e\n                \u003cThemeProvier theme={theme}\u003e\n                    \u003cMyComponent /\u003e\n                \u003c/ThemeProvier\u003e\n            \u003c/div\u003e\n        );\n\n        const $myComponent = screen.getByTestId('my-component');\n\n        // 테스트 통과\n        expect($myComponent).toBeInTheDocument();\n    });\n});\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## util 또는 hook 으로 `\u003cThemeProvider /\u003e` 제공하기\n\n테스트 코드를 작성할 때, 각 테스트 케이스별로 중복되는 코드들이 생기게 됩니다.\n\n이러한 부분들을 공통 함수로 묶어내거나 추상화하지 않는 이유는, 테스트 코드를 읽어나가는 것으로 어떤 테스트를 수행하는지 파악할 수 있는 것이 더 테스트 코드의 가치를 높이기 때문입니다.\n\n\u003cbr /\u003e\n\n하지만 `\u003cThemeProvider /\u003e` 를 감싸는 코드는 **styled-components** 설정을 테스트하는 것이 아닌 이상, 특정 컴포넌트를 테스트하는데 의미를 두기 어렵습니다.\n\n그러므로 이 부분은 별도의 **util 함수** 또는 **custom hook** 으로 분리하여 사용해도 무방해 보입니다.\n\n\u003cbr /\u003e\n\n저는 **@testing-library** 에서 제공하는 `render()` 함수 처럼 `util 함수` 로 만드는 것이 좀 더 일관되는 패턴으로 생각하여 아래와 같이 작성해 보았습니다.\n\n```tsx title=\"@/utils/testing-library/renderTestComponent.tsx\" showLineNumbers\n// react\nimport { \n    ReactElement,\n} from 'react';\n// jest\nimport { \n    render,\n} from '@testing-library/react';\n// styled-components\nimport { \n    ThemeProvider,\n} from 'styled-components';\nimport theme from '@/styles/theme';\n\nconst renderTestComponent = (element: ReactElement) =\u003e {\n    const { rerender } = render(\n        \u003cThemeProvider theme={theme('light')}\u003e\n            {element}\n        \u003c/ThemeProvider\u003e\n    );\n\n    return {\n        rerender,\n    };\n};\n\nexport default renderTestComponent;\n```\n\n\u003cbr /\u003e\n\n이를 테스트 코드에 적용하면 다음과 같습니다.\n\n```tsx title=\"util 함수를 적용한 테스트 코드\" showLineNumbers {5, 10}\nimport MyComponent from './MyComponent';\n// import {\n//     render,\n// } from '@testing-library/react';\nimport renderTestComponent from '@/utils/testing-library/renderTestComponent';\n\ndescribe('MyComponent 테스트', () =\u003e {\n    it('DOM 에 렌더링 된다.', () =\u003e {\n        // render() 성공\n        renderTestComponent(\n            \u003cdiv data-testid=\"my-component\"\u003e\n                \u003cMyComponent /\u003e\n            \u003c/div\u003e\n        );\n\n        const $myComponent = screen.getByTestId('my-component');\n\n        // 테스트 통과\n        expect($myComponent).toBeInTheDocument();\n    });\n});\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\n유닛 테스트를 하나씩 추가하며, coverage 가 높아져 가는 것이 하나의 재미요소가 되었습니다.\n\n`renderTestComponent()` 처럼 테스트 환경을 위한 기능을 만드는 과정은 성취감과 연결되었습니다.\n\n이 블로그 프로젝트는 개발 초기 시점인 만큼, 모든 컴포넌트를 테스트할 수 있도록 목표를 잡아야겠습니다!\n"])</script><script>self.__next_f.push([1,"15:T15fe,"])</script><script>self.__next_f.push([1,"---\nid: 2\ntitle: '\"jest.fn()\" 으로 함수 테스트하기'\ndescription: '컴포넌트 props 로 넘겨주는 함수를 테스트하는 방법으로 \"jest.fn()\" 사용방법에 대한 정리 입니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'jest.fn',\n    'jest',\n    '@testing-library',\n    '유닛 테스트',\n]\n\ncreatedAt: '2023-12-23 14:45:00'\nmodifiedHistories: []\n---\n\n# \"jest.fn()\" 으로 함수 테스트하기\n\n컴포넌트에는 props 를 사용하여 데이터와 함수를 넘겨주도록 만들 수 있습니다.\n\n이번 포스팅에서는 `jest.fn()` 을 사용하여 컴포넌트에 넘겨준 함수가 정상동작하는지 테스트하는 방법에 대해 정리합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 컴포넌트 props 에 넘겨주는 함수\n\n컴포넌트 props 에는 함수를 넘겨줄 수 있습니다.\n\n사용자 인터렉션을 처리하기 위한 함수가 될 수도 있고, 특정 동작에 대한 callback 으로 활용되도록 구현할 수 있습니다.\n\n이렇게 넘겨준 함수가 의도한 시점, 상황에 호출이 되는지 테스트하고자 합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 테스트 예시 컴포넌트\n\n이번 포스팅에서 테스트에 사용할 input 컴포넌트를 만들어보겠습니다.\n\n```typescript title=\"./ChocobeInput.tsx\" showLineNumbers\nimport {\n    useCallback,\n    memo,\n    ChangeEvent,\n} from 'react';\n\ntype TChocobeButtonProps = {\n    value: string;\n    onChange: (value: string) =\u003e void;\n};\n\nfunction ChocobeInput(props: TChocobeInputProps) {\n    const {\n        value,\n        onChange,\n    } = props;\n\n    //\n    // callback\n    //\n    const onChangeInput = useCallback((e: ChangeEvent\u003cHTMLInputElement\u003e) =\u003e {\n        const value = e.target.value;\n        onChange(value);\n    }, [onChange]);\n\n    return (\n        \u003cinput\n            value={value}\n            onChange={onChangeInput} /\u003e\n    );\n}\n\nexport default memo(ChocobeInput);\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## `jest.fn()` 으로 onChange mockup function 만들기\n\n* 참고: [[Jest 공식 문서] Using a mock function](https://jestjs.io/docs/mock-functions#using-a-mock-function)\n\n`Jest` 는 `fn()` 이라는 **함수 mockup 메소드** 를 제공하고 있습니다.\n\n위 예시 컴포넌트를 테스트한다면, `props.onChange()` 를 테스트하기 위해 `jest.fn()` 을 사용하게 됩니다.\n\n```typescript title=\"jest.fn() 으로 mockup function 생성하기\" showLineNumbers {11, 16}\n// UI Components\nimport ChocobeInput from './ChocobeInput';\n// jest\nimport {\n    render,\n    screen,\n} from '@testing-library/react';\n\ndescribe('ChocobeInput 컴포넌트 테스트', () =\u003e {\n    it('ChocobeInput 에 값을 입력하면 onChange() 가 호출된다.', async () =\u003e {\n        const fn_onChange = jest.fn();\n\n        render(\n            \u003cChocobeInput\n                value=\"\"\n                onChange={fn_onChange} /\u003e\n        );\n    });\n});\n```\n\n\n\n\u003cbr /\u003e\n\n## input 요소에 KeyboardEvent 발생시키기\n\n`fn_onChange()` 함수는 `\u003cChocobeInput /\u003e` 컴포넌트에 `KeyboardEvent` 가 발생하면 호출되는 구조 입니다.\n\n`userEvent` 를 사용하여 `KeyboardEvent` 나 `click` 이벤트 등을 발생시킬 수 있으며, `\u003cChocobeInput /\u003e` 컴포넌트의 경우에는 `KeyboardEvent` 가 발생하면 `onChange()` 가 호출됩니다.\n\n컴포넌트에 `KeyboardEvent` 를 발생시키려면 `userEvent.type()` 메소드를 활용하게 됩니다.\n\n```typescript title=\"userEvent.type() 으로 KeyboardEvent 발생시키기\" showLineNumbers {24}\n// UI Components\nimport ChocobeInput from './ChocobeInput';\n// jest\nimport {\n    render,\n    screen,\n} from '@testing-library/react';\nimport {\n    userEvent,\n} from '@testing-library/user-event';\n\ndescribe('ChocobeInput 컴포넌트 테스트', () =\u003e {\n    it('ChocobeInput 에 값을 입력하면 onChange() 가 호출된다.', async () =\u003e {\n        const fn_onChange = jest.fn();\n\n        render(\n            \u003cChocobeInput\n                value=\"\"\n                onChange={fn_onChange} /\u003e\n        );\n\n        const $chocobeInput = screen.getByRole('textbox');\n\n        await userEvent.type($chocobeInput, 'Hello');\n    });\n});\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## KeyboardEvent 에 의해 fn_onClick() 호출 여부 테스트하기\n\n위 예시 코드를 통해 `\u003cChocobeInput /\u003e` 컴포넌트에 `KeyboardEvent` 가 발생한 상태 입니다.\n\n`userEvent.type(요소, 입력값)` 으로 넘겨준 `입력값` 은 문자 1개당 1번의 KeyboardEvent 가 발생하게 되므로, 총 5번의 KeyboardEvent 가 발생한 상태 입니다.\n\n이를 테스트하면 다음과 같습니다.\n\n```typescript title=\"발생한 이벤트 테스트\" showLineNumbers\n// UI Components\nimport ChocobeInput from './ChocobeInput';\n// jest\nimport {\n    render,\n    screen,\n} from '@testing-library/react';\nimport {\n    userEvent,\n} from '@testing-library/user-event';\n\ndescribe('ChocobeInput 컴포넌트 테스트', () =\u003e {\n    it('ChocobeInput 에 값을 입력하면 onChange() 가 호출된다.', async () =\u003e {\n        const fn_onChange = jest.fn();\n\n        render(\n            \u003cChocobeInput\n                value=\"\"\n                onChange={fn_onChange} /\u003e\n        );\n\n        const $chocobeInput = screen.getByRole('textbox');\n\n        await userEvent.type($chocobeInput, 'Hello');\n\n        expect(fn_onChange).toHaveBeenCalledTimes(5);\n    });\n});\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\n함수 테스트는 `jest.fn()` 뿐만 아니라 `jest.spyOn()` 으로도 가능합니다.\n\n다음 포스팅에서는 `jest.spyOn()` 으로 테스트하는 방법과 `jest.fn()` 과 차이점에 대해 정리하겠습니다.\n"])</script><script>self.__next_f.push([1,"16:T1e27,"])</script><script>self.__next_f.push([1,"---\nid: 1\ntitle: LLMOps 와 친해지기 1 - 용어 정리\ndescription: 'AI 학습 모델인 Large Language Model 에 대한 정리입니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: []\n\ncreatedAt: '2023-12-16 15:00:00'\nmodifiedHistories: []\n---\n\n# LLMOps 와 친해지기 1 - 용어 정리\n\n**LLMOps** 란, Large Language Model 의 약자이며 대규모 언어 모델 입니다.\n\n사내 신규 프로젝트로 **LLMOps** 를 사용하기 위한 UI 툴 서비스를 개발하게 되었습니다.\n\n개발할 서비스에 대한 도메인 지식이 필요함을 느끼게 되었기에, 관련 용어와 개념을 정리하고자 합니다.\n\n일반인의 시야에서 조사한 내용을 정리하는 목적을 가지고 LLM 에 초점을 가지므로, 좀 더 정확한 내용은 첨부한 **참고 링크** 를 확인해주세요.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 용어 정리\n\n### 머신러닝\n\n\u003e 참고: [Machine learning (ML) –  머신러닝 이란?](https://www.ibm.com/kr-ko/topics/machine-learning)\n\n\u003cbr /\u003e\n\n기계학습 방법을 말합니다.\n\n**딥러닝** 이 아닌 **머신러닝** 은 정형화된 데이터를 학습하며 사람의 개입이 많이 필요합니다.\n\n정형화된 데이터란 데이터 각각에 대하여 **labeling** 이나 **tagging** 작업을 한 학습 데이터를 말합니다.\n\n데이터가 많을수록 좋은 결과를 기대할 수 있기 때문에, 정형화된 데이터를 만드는 과정부터 많은 시간과 노력이 필요하게 됩니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n### 딥러닝\n\n\u003e 참고: [Machine learning (ML) –  머신러닝 이란?](https://www.ibm.com/kr-ko/topics/machine-learning)\n\n\u003cbr /\u003e\n\n머신러닝의 하위 분야이며, 머신러닝 처럼 정형화된 데이터로 학습할 수 있으며, 추가로 비정형 데이터를 학습할 수도 있습니다.\n\n비정형 데이터 학습을 위해 사용되는 개념으로 **신경망** 이 있습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n### 신경망\n\n\u003e 참고: [AWS - 신경망이란 무엇인가요?](https://aws.amazon.com/ko/what-is/neural-network/)\n\u003e\n\u003e 참고: [Machine learning (ML) –  머신러닝 이란?](https://www.ibm.com/kr-ko/topics/machine-learning)\n\n\u003cbr /\u003e\n\n신경망은 머신러닝의 하위 분야이며 딥러닝의 기계 학습 알고리즘 중 하나입니다.\n\n신경망은 구조화 되지 않은 데이터와 명시적이지 않은 훈련 방식을 사용하며, 이렇게 학습한 데이터를 **일반화** 하고 **추론** 할 수 있습니다.\n\n예를 들면 다음과 같습니다.\n\n```bash\n질문1: \"결제 방법을 알려줘\"\n\n질문2: \"비용 송금 방법을 알려줘\"\n```\n\n위 질문은 문장은 다르지만, 컴퓨터는 신경망을 통해 \"결제 방법 안내\" 라는 동일한 문맥임을 이해합니다.\n\n\u003cbr /\u003e\n\n신경망은 **노드** 로 구성되며, 노드에는 **입력 노드**, **출력 노드** 등, 무수히 많은 노드로 구성됩니다.\n\n각 노드는 **관련성에 대한 임계치** 가 있으며, 임계치에 다다르면 활성화 되는데, 이러한 방식으로 관련된 노드들의 활성화를 통해 **일반화** 와 **추론** 을 할 수 있게 됩니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n### MLOps\n\n\u003e 참고: [MLOps란?](https://www.ibm.com/kr-ko/topics/machine-learning)\n\n\u003cbr /\u003e\n\n**MLOps** 는 **Machine Learning** 과 **Operations** 의 합성어로, 효율적인 머신러닝 **모델 개발**, **배포**, **운용** 을 위한 개발 방법론이며, **새로운 모델 개발이 목적** 입니다.\n\n**MLOps** 를 구성하는 요소는 다음과 같습니다.\n\n* 지속적 통합 (**CI**: Continuous Integration)\n* 지속적 배포 (**CD**: Continuous Deployment)\n* 지속적 학습 (**CT**: Continuous Training)\n\n\n\n\u003cbr /\u003e\n\n\n\n### FMOps\n\n\u003e 참고: [카카오엔터프라이즈 기술블로그 Tech\u0026(테크앤):티스토리](https://tech.kakaoenterprise.com/196)\n\n**FM(Foundation Model)** 을 한국어로 **기반 모델** 이라고 합니다.\n\n**FMOps(Foundation Model Operations)** 는 **기반 모델 개발**, **배포**, **운용** 을 위한 개발 방법론 입니다.\n\n**FMOps(Foundation Model Operations)** 에는 자연어 뿐만 아니라, 이미지나 음성을 기반으로 하는 모델(예시: **DALL-E**) 을 모두 포함합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n### LLMOps\n\n\u003e 참고: [카카오엔터프라이즈 기술블로그 Tech\u0026(테크앤):티스토리](https://tech.kakaoenterprise.com/196)\n\n\u003cbr /\u003e\n\n**FMOps** 에 포함되는 개념이며, **자연어 처리** 를 위한 개념으로 **LLM(Large Language Model)** 이 있습니다.\n\n**LLMOps(Large Langague Model Operations)** 는 **LLM 개발**, **배포**, **운용** 을 위한 개발 방법론입니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n### MLOps 와 FMOps 비교\n\n\u003e 참고: [카카오엔터프라이즈 기술블로그 Tech\u0026(테크앤):티스토리](https://tech.kakaoenterprise.com/196)\n\n\u003cbr /\u003e\n\n* 목적\n    * MLOps: **새로운 모델을 개발** 합니다.\n    * FMOps: 이미 학습이 완료된 모델과 자신의 데이터를 사용하여, **자신만의 AI 앱을 개발** 합니다.\n* 다루는 모델 유형\n    * MLOps: 기업이 직접 모델과 파이프라인 모두 개발하게 됩니다.\n    * FMOps: **API 를 통해서 원하는 모델을 사용** 합니다.\n* 산출물\n    * MLOps: **Model** 과 이를 사용할 수 있는 **API** 를 만들게 됩니다.\n    * FMOps: LLM 과 사용자의 커스텀 데이터를 사용한 **AI 어플리케이션** 을 만들게 됩니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n### 프롬프트\n\n\u003e [프롬프트 (Prompt) 란 무엇인가? - 정의, 원리, fine tuning](https://www.thedatahunt.com/trend-insight/what-is-prompt)\n\n\u003cbr /\u003e\n\n개발 환경에서는 다양한 설정과 실행방법이 있습니다.\n\n이를 UI 로 모두 제공하는 것은 어렵기도 하고, 사용성도 복잡해집니다.\n\n그래서 CLI 를 사용하는 경우가 많습니다.\n\n프롬프트란, 컴퓨터에게 실행할 태스크를 전달하는 메시지, **명령어** 라는 의미를 가집니다.\n\nAI 가 발전함에 따라 현재는 명령어뿐만 아니라, 자연어까지 컴퓨터가 이해할 수 있게 되어서, 프롬프트의 의미는 **컴퓨터에게 어떤 태스크를 수행할지 전달하는 자연어 메시지** 라는 의미로 확장되었습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n### 프롬프트 체이닝\n\n\u003e 참고: [카카오엔터프라이즈 기술블로그 Tech\u0026(테크앤):티스토리](https://tech.kakaoenterprise.com/196)\n\n\u003cbr /\u003e\n\n프롬프트를 잘 작성할수록 AI 는 더 정확한 응답을 할 수 있습니다.\n\nLLM 에 하나의 프롬프트를 연결하여 AI 앱을 만들수도 있지만, 더 정확한 기능을 구현하기 위해 LLM 에 외부의 프롬프트를 포함하여 복수의 프롬프트를 연결하여 개발하게 되는데, 이를 **프롬프트 체이닝(Prompt Chaing)** 이라고 합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n### LangChain\n\n\u003e 참고: [카카오엔터프라이즈 기술블로그 Tech\u0026(테크앤):티스토리](https://tech.kakaoenterprise.com/196)\n\n\u003cbr /\u003e\n\n**LangChain** 은 **프롬프트 체이닝** 을 지원하는 프레임워크 입니다.\n\nLLM 과 외부의 프롬프트들을 자유롭게 연결할 수 있는 기능을 제공합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n### LLM 앱 개발 플렛폼\n\nLLM 과 LangChain 을 사용하여 AI 앱을 만들 수 있는 플렛폼이 있습니다. (프롬프트 체이닝 서비스 플렛폼)\n\n대표적으로 **LangFlow** 와 **FlowiseAI** 가 있습니다.\n\n\u003cbr /\u003e\n\n* LangFlow:\n    * [LangFlow Github](https://github.com/logspace-ai/langflow)\n    * 서버: `Python`\n    * 프론트: `React(Typescript)`\n* FlowiseAI\n    * [FlowiseAI Github](https://github.com/FlowiseAI/Flowise)\n    * 서버: `Express(Typescript)`\n    * 프론트: `React(Javascript)`\n"])</script><script>self.__next_f.push([1,"17:T1d77,"])</script><script>self.__next_f.push([1,"---\nid: 1\ntitle: Nextjs 프로젝트의 유닛 테스트\ndescription: '유닛 테스트를 위해 Jest 와 @testing-library 설치 및 설정에 대한 정리 입니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'nextjs',\n    'jest',\n    '@testing-library',\n    'react',\n    '유닛 테스트',\n]\n\ncreatedAt: '2023-12-16 22:13:00'\nmodifiedHistories: []\n---\n\n# Nextjs 프로젝트의 유닛 테스트\n\n* 참고: [Next.js with React Testing Library, Jest, and TypeScript](https://medium.com/readytowork-org/next-js-with-react-testing-library-jest-and-typescript-a6aa11b85434)\n* 참고: [Nextjs 공식문서](https://nextjs.org/docs/pages/building-your-application/testing/jest)\n\n\n\n\u003cbr /\u003e\n\n\n\n\u003cdetails\u003e\n\u003csummary\u003e유닛 테스트를 멀리한 핑계와 결심\u003c/summary\u003e\n\n\u003cbr /\u003e\n\n스타트업에 재직하며 다양한 프로젝트를 개발하고 있습니다.\n\n진행했던 프로젝트를 되돌아보면, 한결같이 시간이 부족하였고, 이를 핑계삼아 유닛 테스트 없이 기능 구현만을 하였습니다.\n\n\u003cbr /\u003e\n\n### 🤪 유닛 테스트 없이도 개발 가능한데?\n\n테스트에 관한 블로그 글이나 **클린코드** 와 같은 책에서 언급한 **코드에 대한 신뢰도** 는 사실 체감을 하지 못하였습니다.\n\n오히려 유닛 테스트 작성 때문에 기능 구현할 시간을 뺏긴다는 느낌이 컸고, 유닛 테스트 없이도 기능 개발은 충분히 가능했습니다.\n\n\u003cbr /\u003e\n\n### 😰 `console.log` 와 수작업 테스트 노가다...\n\n기능 개발을 완료한 후, 기억이 흐릿해질 정도로 시간이 지나서 기능 추가/수정 작업이 생겼습니다.\n\n기억을 상기하기 위해 여기 저기에 `console.log()` 를 작성하였고, 기능 추가 후에는 남아있는 `console.log()` 를 제거하는 귀찮은 작업들이 남게 되었습니다.\n\n사실 함수명, 메소드명, 변수명 등이 모두 명확하고, 모든 코드가 서로 의존성 없이 독립적인 기능을 한다면 `console.log()` 로 확인하는 작업이 필요 없을 수 있습니다.\n\n하지만 기능이 언제나 단순 명료하게 구현될 수 없고, 더더욱 이 코드를 작성한 저의 코드 품질에 부족함이 많기 때문에 `console.log()` 노가다와 함께할 가능성이 보였습니다.\n\n**그리고 가장 큰 문제는, 변경된 기능이 다른 부분에 영향을 미치는지, 버그를 찾기위한 반복된 수작업 테스트를 하게 되었습니다.**\n\n기능을 추가하는 코드 베이스가 클 수록, 수작업 테스트는 상당한 시간을 소비하게 하였습니다.\n\n\u003cbr /\u003e\n\n### 🤓 유닛 테스트를 사용한 테스트 자동화가 필요해!\n\n만약 유닛 테스트를 작성해 두었다면, 아래와 같은 보상이 있었다고 생각됩니다.\n\n* 현재 코드가 테스트에 통과하고 있으므로, 적어도 작성된 **Test Case** 내에서는 신뢰할 수 있는 코드다.\n* 테스트 대상이 지원하는 모든 기능과 `porps` 에 대하여, 독립적인 **Use Case** 를 확인할 수 있다.\n* **수정한 코드가 의도한 부분에만 적용됨을 보장 받을 수 있다.**\n\n\u003cbr /\u003e\n\n위와 같은 기대값을 가지며, **유닛 테스트에 대한 결심** 을 하게 되었습니다.\n\n\u003c/details\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 유닛 테스트 라이브러리 설치\n\n유닛 테스트를 위해, `jest` 와 `@testing-library` 를 사용하고자 합니다.\n\n```bash title=\"jest 관련 패키지\"\nyarn add -D jest ts-jest ts-node jest-environment-jsdom @types/jest\n```\n\n```bash title=\"@testing-library 관련 패키지\"\nyarn add -D @testing-library/jest-dom @testing-library/react @testing-library/user-event\n```\n\n\n\u003cbr /\u003e\n\n\n\n## jest 실행을 위한 명령어 추가하기\n\n`package.json` 의 `scripts` 를 통해 프로젝트에 대한 명령어를 추가할 수 있습니다.\n\n단발성 테스트를 위한 명령어와 코드 변경마다 테스트를 실행하는 명령어를 추가합니다.\n\n```json title=\"package.json\" {5-7}\n{\n    // ...\n    \"scripts\": {\n        // ...\n        \"test\": \"jest\",\n        \"test:watch\": \"jest --watch\",\n        \"test:watchAll\": \"jest --watchAll\"\n    },\n    // ...\n}\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## jest 설정하기\n\n[Nextjs 공식 문서](https://nextjs.org/docs/pages/building-your-application/testing/jest#manual-setup) 에서도 **jest** 와 **@testing-library** 를 사용하는 방법에 대해 안내하고 있습니다.\n\n\u003cbr /\u003e\n\n**jest.config.ts** 파일을 사용하여 설정할 수 있습니다.\n\n직접 파일을 생성하지 않고, CLI 를 통해 설정 템플릿을 생성하여 수정하는 방향으로 설정하겠습니다.\n\n터미널에서 아래의 명령을 실행합니다.\n\n```bash title=\"npm 으로 jest.config.ts 생성하기\"\nnpm init jest@latest\n```\n\n```bash title=\"yarn 으로 jest.config.ts 생성하기\"\nyarn create jest@latest\n```\n\n\u003cbr /\u003e\n\n명령을 실행하면, 몇가지 질문(Y/N)으로 기본 설정값이 반영된 **jest.config.ts** 파일이 생성됩니다.\n\n생성된 **jest.config.ts** 를 아래와 같이 수정합니다.\n\n```typescript showLineNumbers\nimport {\n    Config,\n} from 'jest';\nimport nextJest from 'next/jest.js';\n\nconst createJestConfig = nextJest({\n    dir: './',\n});\n\n/**\n * For a detailed explanation regarding each configuration property, visit:\n * https://jestjs.io/docs/configuration\n */\n\nconst config: Config = {\n    // The directory where Jest should output its coverage files\n    coverageDirectory: \"coverage\",\n\n    // Indicates which provider should be used to instrument code for coverage\n    coverageProvider: \"babel\",\n\n    // A preset that is used as a base for Jest's configuration\n    preset: \"ts-jest\",\n\n    // A list of paths to modules that run some code to configure or set up the testing framework before each test\n    setupFilesAfterEnv: [\"\u003crootDir\u003e/jest.setup.ts\"],\n\n    // The test environment that will be used for testing\n    testEnvironment: \"jest-environment-jsdom\",\n};\n\nexport default createJestConfig(config);\n```\n\n\u003cbr /\u003e\n\n`jest.config.ts` 파일의 **26번줄** 에서 설정한 **jest.setup.ts** 파일을 생성하고 아래의 코드를 작성합니다.\n\n```typescript title=\"jest.setup.ts\"\nimport '@testing-library/jest-dom';\n```\n\n**jest.setup.ts** 에서 `import` 하는 모듈은 **@testing-library** 에서 제공하는 **확장 matcher** 를 사용할 수 있게 해줍니다.\n\n이로써 Nextjs 의 유닛 테스트 설정을 완료 하였습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 첫번째 컴포넌트 테스트 만들기\n\n먼저 테스트를 할 React 컴포넌트를 만들겠습니다.\n\n```tsx title=\"Hello.tsx\"\nfunction Hello() {\n    return (\n        \u003ch1\u003e\n            Hello World\n        \u003c/h1\u003e\n    );\n}\n\nexport default Hello;\n```\n\n\u003cbr /\u003e\n\n*Hello.tsx* 와 동일한 경로에 **Hello.spec.tsx** 파일을 생성하고, 유닛 테스트를 작성합니다.\n\n```typescript title=\"Hello.spec.tsx\"\nimport Hello from './Hello';\nimport {\n    render,\n    screen,\n} from '@testing-library/react';\n\ndescribe('\u003cHello /\u003e 컴포넌트 유닛 테스트', () =\u003e {\n    it('Dom 에 렌더링 됨', () =\u003e {\n        render(\u003cHello /\u003e);\n\n        const $hello = screen.getByRole('heading', {\n            level: 1,\n        });\n\n        expect($hello).toBeInTheDocument();\n    });\n});\n```\n\n\u003cbr /\u003e\n\n유닛 테스트를 작성한 후, 터미널에 아래의 명령어로 테스트를 실행할 수 있으며, 모든 테스트가 통과됨을 확인할 수 있습니다.\n\n```bash title=\"jest 실행하기\"\nyarn test\n```\n"])</script><script>self.__next_f.push([1,"18:T2361,"])</script><script>self.__next_f.push([1,"---\nid: 1\ntitle: Custom Hook 으로 분리하며 발생한 실수\ndescription: 'Custom Hook 으로 분리한 useEffect 가 여러번 호출 케이스 중 한가지를 정리합니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'react',\n    'custom hook',\n]\n\ncreatedAt: '2023-12-19 22:50:00'\nmodifiedHistories: []\n---\n\n# Custom Hook 으로 분리하며 발생한 실수\n\n## 실수가 발생한 상황\n\n페이지가 mount 되면 API 를 호출하는 흐름은 빈번히 사용됩니다.\n\n그리고 API 응답을 받으면, 후처리를 하는 `useEffect` 를 사용할 수 있습니다.\n\n\u003cbr /\u003e\n\n이번 이슈에서는 Custom Hook 으로 나누기 전까지는 의도한 대로 API 응답과 Effect 가 1:1 로 실행되었습니다.\n\n```tsx title=\"MyPage.tsx\" showLineNumbers {28-30, 32-34}\nimport {\n    useCallback,\n    useEffect,\n} from 'react';\nimport {\n    useAppSelector,\n} from '@/redux/hooks';\n\nfunction MyPage() {\n    const triggerState = useAppSelector(({ triggerState }) =\u003e triggerState);\n\n    const responseOfApi_1 = useAppSelector(({ api_1 }) =\u003e api_1);\n    const responseOfApi_2 = useAppSelector(({ api_2 }) =\u003e api_2);\n\n    const callApi_1 = useCallback(() =\u003e {\n        // API 호출 1\n    }, []);\n\n    const callApi_2 = useCallback(() =\u003e {\n        // API 호출 2\n    }, []);\n\n    useEffect(function handleTriggerState() {\n        callApi_1();\n        callApi_2();\n    }, [triggerState]);\n\n    useEffect(function onSuccessApi_1() {\n        // API 1 응답 후처리\n    }, [responseOfApi_1]);\n\n    useEffect(function onSuccessApi_2() {\n        // API 2 응답 후처리\n    }, [responseOfApi_2]);\n\n    return (\n        // ...\n    );\n}\n\nexport default MyPage;\n```\n\n\u003cbr /\u003e\n\n이런 방식으로 **호출하는 API 가 늘어나자, 컴포넌트가 점점 복잡해졌습니다.**\n\n**또한 사용자 인터렉션에 의해 다시 호출해야 하는 API 도 있어서** Custom Hook 으로 분리하여 재사용하는 방향으로 생각하게 되었습니다.\n\n\u003cbr /\u003e\n\n리펙토링 결과, API 후처리를 담당하는 `useEffect` 가 번복 실행되는 현상이 나타났습니다.\n\n```tsx title=\"./hooks/useApi_1.ts\" showLineNumbers {16-18}\nimport {\n    useCallback,\n    useEffect,\n} from 'react';\nimport {\n    useAppSelector\n} from '@/redux/hooks';\n\nconst useApi_1 = () =\u003e {\n    const responseOfApi_1 = useAppSelector(({ api_1 }) =\u003e api_1);\n\n    const callApi_1 = useCallback(() =\u003e {\n        // API 호출 1\n    }, []);\n\n    useEffect(function onSuccessApi_1() {\n        // (번복 실행됨) API 1 응답 후처리\n    }, [responseOfApi_1]);\n\n    return {\n        callApi_1,\n    };\n};\n\nexport default useApi_1;\n```\n\n```tsx title=\"./hooks/useApi_2.ts\" showLineNumbers {16-18}\nimport {\n    useCallback,\n    useEffect,\n} from 'react';\nimport {\n    useAppSelector\n} from '@/redux/hooks';\n\nconst useApi_2 = () =\u003e {\n    const responseOfApi_2 = useAppSelector(({ api_2 }) =\u003e api_2);\n\n    const callApi_2 = useCallback(() =\u003e {\n        // API 호출 2\n    }, []);\n\n    useEffect(function onSuccessApi_2() {\n        // (번복 실행됨) API 2 응답 후처리\n    }, [responseOfApi_2]);\n\n    return {\n        callApi_2,\n    };\n};\n\nexport default useApi_2;\n```\n\n```tsx title=\"MyPage.tsx\" showLineNumbers {10-11, 13-16}\nimport {\n    useEffect,\n} from 'react';\nimport useApi_1 from './hooks/useApi_1';\nimport useApi_2 from './hooks/useApi_2';\n\nfunction MyPage() {\n    const triggerState = useAppSelector(({ triggerState }) =\u003e triggerState);\n\n    const { callApi_1 } = useApi_1();\n    const { callApi_2 } = useApi_2();\n\n    useEffect(function onSuccessApi_2() {\n        callApi_1();\n        callApi_2();\n    }, [triggerState]);\n\n    return (\n        // ...\n    );\n};\n\nexport default MyPage;\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## useEffect 의 dependencies 는 무죄\n\n`useEffect` 의 `dependencies` 는 redux 에서 가져온 state 였습니다.\n\n(위의 예시 코드에서는 `triggerState` 로 표현하였습니다.)\n\n**`triggerState` 에 의도치 않은 mutate 가 발생하는 것인가** 라고 생각했지만, 이는 아니였습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## Custom Hook 을 재사용한 만큼 번복되는 useEffect\n\nCustom Hook 으로 분리하는 단위를 **특정 API 호출 함수** 와 **해당 API 응답 후처리 Effect** 로 묶어서 구성하였습니다.\n\n그리고 필요한 곳에서 재사용을 하였습니다.\n\n\u003cbr /\u003e\n\n결과적으로 재사용한 횟수만큼 `useEffect` 가 번복 실행된 것입니다.\n\nCustom Hook 은 사용하는 곳에 scope 를 만드는 것이므로, 당연한 결과임에도 알아차리지 못하였습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## API 호출함수와 Effect 를 분리한 Custom Hook 으로 이슈 해결\n\n원인을 찾은 후, API 의 후처리를 담당하는 `useEffect` 를 Custom Hook 에서 빼고, 기존의 `MyPage` 에 위치시켰습니다.\n\n그러자 번복되는 `useEffect` 이슈는 해결 되었습니다.\n\n\n```tsx title=\"./hooks/useApi_1.ts\" showLineNumbers {15-17}\nimport {\n    useCallback,\n} from 'react';\nimport {\n    useAppSelector\n} from '@/redux/hooks';\n\nconst useApi_1 = () =\u003e {\n    const responseOfApi_1 = useAppSelector(({ api_1 }) =\u003e api_1);\n\n    const callApi_1 = useCallback(() =\u003e {\n        // API 호출 1\n    }, []);\n\n    // useEffect(function onSuccessApi_1() {\n    //     // API 1 응답 후처리\n    // }, [responseOfApi_1]);\n\n    return {\n        callApi_1,\n    };\n};\n\nexport default useApi_1;\n```\n\n```tsx title=\"./hooks/useApi_2.ts\" showLineNumbers {15-17}\nimport {\n    useCallback,\n} from 'react';\nimport {\n    useAppSelector\n} from '@/redux/hooks';\n\nconst useApi_2 = () =\u003e {\n    const responseOfApi_2 = useAppSelector(({ api_2 }) =\u003e api_2);\n\n    const callApi_2 = useCallback(() =\u003e {\n        // API 호출 2\n    }, []);\n\n    // useEffect(function onSuccessApi_2() {\n    //     // API 2 응답 후처리\n    // }, [responseOfApi_2]);\n\n    return {\n        callApi_2,\n    };\n};\n\nexport default useApi_2;\n```\n\n```tsx title=\"MyPage.tsx\" showLineNumbers {20-22, 24-26}\nimport {\n    useEffect,\n} from 'react';\nimport useApi_1 from './hooks/useApi_1';\nimport useApi_2 from './hooks/useApi_2';\n\nfunction MyPage() {\n    const triggerState = useAppSelector(({ triggerState }) =\u003e triggerState);\n\n    const { callApi_1 } = useApi_1();\n    const { callApi_2 } = useApi_2();\n\n    useEffect(function onSuccessApi_2() {\n        callApi_1();\n        callApi_2();\n\n        // eslint-disable-next-line\n    }, [triggerState]);\n\n    useEffect(function onSuccessApi_1() {\n        // API 1 응답 후처리\n    }, [responseOfApi_1]);\n\n    useEffect(function onSuccessApi_2() {\n        // API 2 응답 후처리\n    }, [responseOfApi_2]);\n\n    return (\n        // ...\n    );\n};\n\nexport default MyPage;\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## MyPage 에서 API 후처리를 담당하는 useEffect 분리\n\n위 코드처럼 리펙토링한 이후, 의도한 동작은 되었습니다.\n\n하지만, **MyPage.tsx 파일을 열어보기 전까지는 API 후처리를 어디서 하는지 파악하기가 어렵다고 느껴졌습니다.**\n\n\u003cbr /\u003e\n\n그래서 MyPage.tsx 의 **API 후처리 Effect 들을 Custom Hook 으로** 나눠보기로 하였습니다.\n\n```ts title=\"./hooks/useMyPageApiEffects.ts\" showLineNumbers {9-11, 13-15}\nimport {\n    useEffect,\n} from 'react';\n\nconst useMyPageApiEffects = () =\u003e {\n    const responseOfApi_1 = useAppSelector(({ api_1 }) =\u003e api_1);\n    const responseOfApi_2 = useAppSelector(({ api_2 }) =\u003e api_2);\n\n    useEffect(function onSuccessApi_1() {\n        // API 1 응답 후처리\n    }, [responseOfApi_1]);\n\n    useEffect(function onSuccessApi_2() {\n        // API 2 응답 후처리\n    }, [responseOfApi_2]);\n}\n\nexport default useMyPageApiEffects;\n```\n\n```tsx title=\"MyPage.tsx\" showLineNumbers {13}\nimport {\n    useEffect,\n} from 'react';\nimport useApi_1 from './hooks/useApi_1';\nimport useApi_2 from './hooks/useApi_2';\nimport useMyPageApiEffects from './hooks/useMyPageApiEffects';\n\nfunction MyPage() {\n    const triggerState = useAppSelector(({ triggerState }) =\u003e triggerState);\n\n    const { callApi_1 } = useApi_1();\n    const { callApi_2 } = useApi_2();\n    useMyPagteApiEffects();\n\n    useEffect(function onSuccessApi_2() {\n        callApi_1();\n        callApi_2();\n    }, [triggerState]);\n\n    return (\n        // ...\n    );\n};\n\nexport default MyPage;\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\n여기까지 수정한 결과, MyPage.tsx 에서 API 에 대한 후처리 Effect 가 있다는 것을 파일 목록을 통해서도 파악할 수 있게 되었습니다.\n\n개인적으로는 위와 같은 구조의 Custom Hook 이 마음에 들었습니다.\n\n이렇게 분리한 Custom Hook 은 아래와 같은 파일 구조가 되었습니다.\n\n```bash\n└── MyPage\n    ├── MyPage.tsx\n    └── hooks\n        ├── useApi_1.ts\n        ├── useApi_2.ts\n        └── useMyPageApiEffects.ts\n``` \n\n\u003cbr /\u003e\n\n사소한 실수에 의한 이슈라서 자책 포인트가 되었지만, Custom Hook 으로 분리하는 구조를 생각할 수 있는 계기가 되어서 성취감이 느껴졌습니다.\n"])</script><script>self.__next_f.push([1,"19:T429f,"])</script><script>self.__next_f.push([1,"---\nid: 16\ntitle: 'Particle 로 반딧불이 표현하기'\ndescription: '3D 환경에서 반딧불이나 별을 표현할 때 Particle 을 활용합니다. 매우 많은 입자들로 표현하는 Particle 을 어떻게 구현하는지 정리하고자 합니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    '3D',\n    'Particle',\n    'BufferGeometry',\n    'PointsMaterial',\n    'Points',\n]\n\ncreatedAt: '2024-02-29 20:00:00'\nmodifiedHistories: []\n---\n\n# Particle 로 반딧불이 표현하기\n\n반딧불이나 별은 매우 많은 입자들로 표현합니다.\n\n이를 3D 그래픽스에서는 Particle 이라고 합니다.\n\n각각의 입자를 개별 Mesh 로 구현한다면 화면이 버벅이거나 실행할 수 없는 경우까지 발생할 수 있습니다.\n\n\u003cbr /\u003e\n\n이번 포스팅에서는 컴퓨터 성능을 저해하지 않으면서 Particle 을 구현하는 방법에 대해 정리하고자 합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 예시 코드\n\n\u003e [Model 다운로드 링크](https://polyhaven.com/a/coast_rocks_05)\n\n이번 포스팅의 예시코드는 위 모델을 렌더링한 시점입니다.\n\n```js title=\"예시 코드\" showLineNumbers\n// three.js\nimport {\n    WebGLRenderer,\n    ACESFilmicToneMapping,\n\n    Scene,\n\n    PerspectiveCamera,\n\n    AxesHelper,\n\n    Color,\n    DirectionalLight,\n    DirectionalLightHelper,\n} from 'three';\n// three.js - addons\nimport {\n    OrbitControls,\n} from 'three/examples/jsm/controls/OrbitControls';\nimport {\n    GLTFLoader,\n} from 'three/examples/jsm/loaders/GLTFLoader';\n// style\nimport './style.css';\n\n//\n// state\n//\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { OrbitControls } */\nlet controls;\n\n//\n// core\n//\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app?.appendChild($canvas);\n\n    return $canvas;\n}\n\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.setPixelRatio(window.devicePixelRatio);\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.toneMapping = ACESFilmicToneMapping;\n    renderer.shadowMap.enabled = true;\n}\n\nfunction initScene() {\n    scene = new Scene();\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n\n    camera.fov = 30;\n    camera.aspect = window.innerWidth / window.innerHeight;\n\n    camera.near = 0.5;\n    camera.far = 2_000;\n\n    camera.position.set(0, 0, 5);\n    camera.lookAt(0, 0, 0);\n\n    camera.updateProjectionMatrix();\n}\n\nfunction initAxesHelper() {\n    const helper = new AxesHelper(1);\n\n    scene.add(helper);\n}\n\nfunction initControls($target) {\n    controls = new OrbitControls(camera, $target);\n    controls.enableDamping = true;\n}\n\n//\n// light\n//\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n\n    const light = new DirectionalLight(\n        color,\n        Math.PI * 1\n    );\n\n    light.position.set(-2, 2, 1);\n    light.lookAt(0, 0, 0);\n\n    light.castShadow = true;\n\n    const helper = new DirectionalLightHelper(light);\n\n    scene.add(light);\n    scene.add(helper);\n}\n\n//\n// model\n//\nfunction initModel() {\n    const loader = new GLTFLoader();\n\n    loader.load('/gltf/coast-rocks-05/coast_rocks_05_4k.gltf', gltf =\u003e {\n        const model = gltf.scene;\n        model.position.set(0, -0.5, 0);\n\n        model.traverse(child =\u003e {\n            if (!child.isMesh) {\n                return;\n            }\n\n            child.castShadow = true;\n            child.receiveShadow = true;\n        });\n\n        scene.add(model);\n    });\n}\n\n//\n// executor\n//\nfunction render() {\n    window.requestAnimationFrame(render);\n\n    renderer.render(scene, camera);\n    controls?.update();\n}\n\n(function init() {\n    const $canvas = initCanvas();\n\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n    initAxesHelper();\n    initControls($canvas);\n\n    initDirectionalLight();\n\n    initModel();\n\n    render();\n}());\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-02-29-01/2024-02-29-01-01.png\" alt=\"예시 코드 결과\" /\u003e\n\n\n\n\n\u003cbr /\u003e\n\n\n\n## Particle 구현 흐름\n\n3D 환경에서 물체를 렌더링하기 위해, Geometry 와 Material 을 조합한 Mesh 를 사용합니다.\n\nParticle 은 Mesh 가 아닌 **Points** 객체로 만들 수 있습니다.\n\nPoints 를 생성할 때도 Mesh 처럼 Geometry 와 Material 이 필요합니다.\n\n\u003cbr /\u003e\n\nParticle 을 만드는 과정을 간략하게 표현하면 다음과 같습니다.\n\n1. **BufferGeometry** 객체 생성하기\n2. **PointsMaterial** 객체 생성하기\n3. BufferGeometry 와 PointsMaterial 을 인자로 사용하여 **Points** 객체 생성하기\n4. `scene.add()` 로 등록하기\n\n\n\n\u003cbr /\u003e\n\n\n\n## 1. BufferGeometry 만들기\n\nParticle 의 Geometry 는 **BufferGeometry** 로 만들 수 있습니다.\n\nBufferGeometry 는 buffer 라는 개념을 사용한 Geometry 이며, 다음과 같은 과정으로 생성합니다.\n\n1. **Float32Array** 객체 생성\n2. Float32Array 를 사용하여 **BufferAttribute** 객체 생성\n3. **BufferGeometry** 객체 생성\n4. **BufferGeometry** 의 position 속성에 BufferGeometry 적용\n\n\n\n\u003cbr /\u003e\n\n\n\n### 1. Float32Array 객체 생성\n\n* [참고: JavaScript 형식화 배열 - MDN 공식문서](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Typed_arrays)\n\n* [참고: Float32Array - MDN 공식문서](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Float32Array)\n\n\u003cbr /\u003e\n\nFloat32Array 는 **형식화 배열** 입니다.\n\n자바스크립트의 Array 는 배열 길이를 동적으로 사용할 수 있고, Tuple 로도 활용할 수 있습니다.\n\n형식화 배열은 Java 와 같은 정적 언어의 배열처럼 고정된 길이의 Array 입니다.\n\n참고로 형식화 배열은 자바스크립트에서 Array 와 구분하고 있으며, `형식화_배열.__proto__.isArray()` 는 **false** 를 반환합니다.\n\n\u003cbr /\u003e\n\nFloat32Array 는 **부동소수로 구성된 형식화 배열** 입니다.\n\n비디오나 오디오와 같은 리소스를 빠르게 제어하기 위해 사용되는 빌트인 객체 입니다.\n\n우리가 생성할 buffer 는 각 Particle 입자들의 x, y, z 좌표값으로 생성할 예정입니다.\n\n아래는 buffer 의 예시이며, 1차원 배열에 x, y, z 좌표값이 순서대로 나열된 형태 입니다.\n\n```bash title=\"buffer 구조 예시\"\n[\n    x1, y1, z1,\n    x2, y2, z2,\n    x3, y3, z3,\n]\n```\n\n\u003cbr /\u003e\n\n500개의 Particle 을 표현하기 위한 Float32Array 를 생성하면 다음과 같습니다.\n\n```js title=\"1. Float32Array 객체 생성\" showLineNumbers{140}\n//\n// particle\n//\nconst PARTICLE_AXIS = {\n    X: 0,\n    Y: 1,\n    Z: 2,\n};\n\nfunction initParticle() {\n    const buffer = new Float32Array(Array.from(\n        // 3개의 요소가 Particle 1개의 x, y, z 좌표값이 되며, 500 개를 생성합니다.\n        { length: 3 * 500 },\n        (_, i) =\u003e {\n            const randomValue = Math.random();\n            const axis = i % 3;\n\n            switch (axis) {\n                case PARTICLE_AXIS.X:\n                case PARTICLE_AXIS.Z:\n                    return (randomValue * 2 - 1) * 2;\n                case PARTICLE_AXIS.Y:\n                default:\n                    return randomValue * 2;\n            }\n        }\n    ));\n}\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n### 2. Float32Array 를 사용하여 **BufferAttribute** 객체 생성\n\nBufferGeometry 는 Particle 의 Geometry 로 활용됩니다.\n\nBufferGeometry 에 buffer 를 직접 적용할 수는 없고, **BufferAttribute** 객체를 통해서만 적용할 수 있습니다.\n\n```js title=\"BufferAttribute import 하기\" showLineNumbers {16}\n// three.js\nimport {\n    WebGLRenderer,\n    ACESFilmicToneMapping,\n\n    Scene,\n\n    PerspectiveCamera,\n\n    AxesHelper,\n\n    Color,\n    DirectionalLight,\n    DirectionalLightHelper,\n\n    BufferAttribute,\n} from 'three';\n```\n\n```js title=\"2. Float32Array 를 사용하여 BufferAttribute 객체 생성\" showLineNumbers{142} {28}\n//\n// particle\n//\nconst PARTICLE_AXIS = {\n    X: 0,\n    Y: 1,\n    Z: 2,\n};\n\nfunction initParticle() {\n    const buffer = new Float32Array(Array.from(\n        { length: 3 * 500 },\n        (_, i) =\u003e {\n            const randomValue = Math.random();\n            const axis = i % 3;\n\n            switch (axis) {\n                case PARTICLE_AXIS.X:\n                case PARTICLE_AXIS.Z:\n                    return (randomValue * 2 - 1) * 2;\n                case PARTICLE_AXIS.Y:\n                default:\n                    return randomValue * 2;\n            }\n        }\n    ));\n\n    const positionAttribute = new BufferAttribute(buffer, 3);\n}\n```\n\n\u003cbr /\u003e\n\nBufferAttribute 생성자는 다음과 같은 interface 를 가집니다.\n\n```typescript\nclass BufferAttribute {\n    constructor(\n        // 형식화 배열\n        array: TypedArray, \n\n        // 입자 하나를 이루는 요소(좌표값) 개수\n        itemSize: number\n    );\n}\n```\n\n\u003cbr /\u003e\n\n우리가 생성한 buffer 는 x, y, z 3개의 좌표가 1개의 입자를 표현하므로, 아래와 같이 BufferAttribute 를 생성하였습니다.\n\n```js\nconst positionAttribute = new BufferAttribute(buffer, 3);\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n### 3. **BufferGeometry** 객체 생성\n\nBufferGeometry 객체를 생성해 보겠습니다.\n\n```js title=\"BufferGeometry import 하기\" showLineNumbers {17}\n// three.js\nimport {\n    WebGLRenderer,\n    ACESFilmicToneMapping,\n\n    Scene,\n\n    PerspectiveCamera,\n\n    AxesHelper,\n\n    Color,\n    DirectionalLight,\n    DirectionalLightHelper,\n\n    BufferAttribute,\n    BufferGeometry,\n} from 'three';\n```\n\n```js title=\"BufferGeometry 객체 생성\" showLineNumbers{143} {30}\n//\n// particle\n//\nconst PARTICLE_AXIS = {\n    X: 0,\n    Y: 1,\n    Z: 2,\n};\n\nfunction initParticle() {\n    const buffer = new Float32Array(Array.from(\n        { length: 3 * 500 },\n        (_, i) =\u003e {\n            const randomValue = Math.random();\n            const axis = i % 3;\n\n            switch (axis) {\n                case PARTICLE_AXIS.X:\n                case PARTICLE_AXIS.Z:\n                    return (randomValue * 2 - 1) * 2;\n                case PARTICLE_AXIS.Y:\n                default:\n                    return randomValue * 2;\n            }\n        }\n    ));\n\n    const positionAttribute = new BufferAttribute(buffer, 3);\n\n    const geometry = new BufferGeometry();\n}\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 4. **BufferGeometry** 의 position 속성에 BufferGeometry 적용\n\nBufferGeometry 객체는 `setAttribute('속성명', BufferAttribute_객체)` 메소드를 사용하여 프로퍼티를 변경할 수 있습니다.\n\nBufferGeometry 의 attribute 중, 좌표값은 **'position'** 으로 사용합니다.\n\n```js title=\"BufferGeometry 의 position 속성에 BufferGeometry 적용\" showLineNumbers{143} {31}\n//\n// particle\n//\nconst PARTICLE_AXIS = {\n    X: 0,\n    Y: 1,\n    Z: 2,\n};\n\nfunction initParticle() {\n    const buffer = new Float32Array(Array.from(\n        { length: 3 * 500 },\n        (_, i) =\u003e {\n            const randomValue = Math.random();\n            const axis = i % 3;\n\n            switch (axis) {\n                case PARTICLE_AXIS.X:\n                case PARTICLE_AXIS.Z:\n                    return (randomValue * 2 - 1) * 2;\n                case PARTICLE_AXIS.Y:\n                default:\n                    return randomValue * 2;\n            }\n        }\n    ));\n\n    const positionAttribute = new BufferAttribute(buffer, 3);\n\n    const geometry = new BufferGeometry();\n    geometry.setAttribute('position', positionAttribute);\n}\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 2. **PointsMaterial** 객체 생성 및 Particle 렌더링하기\n\nParticle 의 Material 은 **PointsMaterial** 을 사용합니다.\n\n각 Particle 의 재질에 **이미지 파일** 을 패턴으로 사용하도록 만들고자 합니다.\n\n\u003cbr /\u003e\n\nPointsMaterial 과 BufferGeometry 를 생성하였으므로, **Points** 객체를 생성하여 Particle 을 렌더링할 수 있습니다.\n\n```js title=\"PointsMaterial, Points import 하기\" showLineNumbers {18-20}\n// three.js\nimport {\n    WebGLRenderer,\n    ACESFilmicToneMapping,\n\n    Scene,\n\n    PerspectiveCamera,\n\n    AxesHelper,\n\n    Color,\n    DirectionalLight,\n    DirectionalLightHelper,\n\n    BufferAttribute,\n    BufferGeometry,\n    PointsMaterial,\n    TextureLoader,\n    Points,\n} from 'three';\n```\n\n```js title=\"PointsMaterial 객체 생성 및 Particle 렌더링하기\" showLineNumbers{146} {33-40}\n//\n// particle\n//\nconst PARTICLE_AXIS = {\n    X: 0,\n    Y: 1,\n    Z: 2,\n};\n\nfunction initParticle() {\n    const buffer = new Float32Array(Array.from(\n        { length: 3 * 500 },\n        (_, i) =\u003e {\n            const randomValue = Math.random();\n            const axis = i % 3;\n\n            switch (axis) {\n                case PARTICLE_AXIS.X:\n                case PARTICLE_AXIS.Z:\n                    return (randomValue * 2 - 1) * 2;\n                case PARTICLE_AXIS.Y:\n                default:\n                    return randomValue * 2;\n            }\n        }\n    ));\n\n    const positionAttribute = new BufferAttribute(buffer, 3);\n\n    const geometry = new BufferGeometry();\n    geometry.setAttribute('position', positionAttribute);\n\n    const material = new PointsMaterial({\n        map: new TextureLoader().load('/particle/circle.png'),\n        size: 1,\n    });\n\n    const particle = new Points(geometry, material);\n\n    scene.add(particle);\n}\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-02-29-01/2024-02-29-01-02.png\" alt=\"Particle 만들기\" /\u003e\n\n\u003cbr /\u003e\n\n위 코드에서 PointsMaterial 을 생성하는 부분을 살펴보겠습니다.\n\nPointsMaterial 생성자에 넘겨준 params 에 `map` 속성이 있습니다.\n\n`map` 속성을 사용하여 Particle 하나에 적용시킬 이미지를 **Texture** 로 넘겨줄 수 있습니다.\n\n```js\nconst loader = new TextureLoader();\nconst texture = loader.load('이미지_경로');\n```\n\n\u003cbr /\u003e\n\n우리가 넘겨준 이미지는 배경을 투명하게 처리한 `png` 임에도 불구하고, 렌더링 결과에는 이미지의 투명도가 적용되지 않은 상태 입니다.\n\n이를 해결하기 위해, PointsMaterial 생성자 params 에 추가 설정이 필요합니다.\n\n아래와 같이 추가해 보겠습니다.\n\n```js title=\"AdditiveBelnding import 하기\" showLineNumbers {21}\n// three.js\nimport {\n    WebGLRenderer,\n    ACESFilmicToneMapping,\n\n    Scene,\n\n    PerspectiveCamera,\n\n    AxesHelper,\n\n    Color,\n    DirectionalLight,\n    DirectionalLightHelper,\n\n    BufferAttribute,\n    BufferGeometry,\n    PointsMaterial,\n    TextureLoader,\n    Points,\n    AdditiveBlending,\n} from 'three';\n```\n\n```js title=\"PointsMaterial 에 투명도 설정하기\" showLineNumbers{147} {36-48}\n//\n// particle\n//\nconst PARTICLE_AXIS = {\n    X: 0,\n    Y: 1,\n    Z: 2,\n};\n\nfunction initParticle() {\n    const buffer = new Float32Array(Array.from(\n        { length: 3 * 500 },\n        (_, i) =\u003e {\n            const randomValue = Math.random();\n            const axis = i % 3;\n\n            switch (axis) {\n                case PARTICLE_AXIS.X:\n                case PARTICLE_AXIS.Z:\n                    return (randomValue * 2 - 1) * 2;\n                case PARTICLE_AXIS.Y:\n                default:\n                    return randomValue * 2;\n            }\n        }\n    ));\n\n    const positionAttribute = new BufferAttribute(buffer, 3);\n\n    const geometry = new BufferGeometry();\n    geometry.setAttribute('position', positionAttribute);\n\n    const material = new PointsMaterial({\n        map: new TextureLoader().load('/particle/circle.png'),\n\n        // Particle 1개의 크기\n        size: 0.5,\n        // Particle 색상\n        color: new Color('#006400'),\n        // Particle 투명도\n        opacity: 0.5,\n\n        // 투명도 사용여부\n        transparent: true,\n        // Particle 과 겹치는 부분의 색상을 처리(섞는) 방식 설정\n        blending: AdditiveBlending,\n        // Particle 의 깊이 표현 여부\n        depthWrite: false,\n    });\n\n    const particle = new Points(geometry, material);\n\n    scene.add(particle);\n}\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-02-29-01/2024-02-29-01-03.png\" alt=\"Particle 만들기\" /\u003e\n\n\u003cbr /\u003e\n\n**PointsMaterial** 에 투명도를 설정할 때는 아래의 설정이 함께 필요합니다.\n\n* `transparent: true`\n* `blending: AdditiveBlending`\n* `depthWrite: true`\n\n\n\n\u003cbr /\u003e\n\n\n\n### 마치며\n\nThree.js 의 Particle 생성 방법을 스터디하기 전까지는 개별 Particle 요소를 하나하나 만들어야 하는 것 같았습니다.\n\n이번 포스팅을 통해 Particle 을 효과적으로 활용할 수 있을 것 같습니다.\n\n\u003cbr /\u003e\n\n다만 위 예제처럼 `scene.background` 와 `scene.fog` 를 어두운 색(`#383841`) 일 경우에 한하여 의도한 결과가 렌더링되었습니다.\n\n`scene.background` 와 `scene.fog` 를 밝은 색상으로 설정하면, 여전히 Particle 의 외곽선이 보이는 현상이 있습니다.\n\n차후 관련하여 좀 더 찾아본 후, 해결방법을 정리하겠습니다.\n"])</script><script>self.__next_f.push([1,"1a:Tf6c,"])</script><script>self.__next_f.push([1,"---\nid: 15\ntitle: 'Material 의 map, bumpMap, normalMap'\ndescription: 'Material 의 표현 방식과 울퉁불퉁한 재질을 처리하는 방식을 정리합니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    '3D',\n    'Material',\n    'Texture',\n    'map',\n    'bumpMap',\n    'normalMap',\n]\n\ncreatedAt: '2024-02-12 15:17:30'\nmodifiedHistories: []\n---\n\n# Material 의 map, bumpMap, normalMap\n\nMesh 는 형태를 정의하는 Geometry 와 재질을 표현하는 Material 로 구성합니다.\n\n이번 포스팅에서는 Material 의 표면 처리 방식에 대해 정리합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## Material 에 Texture Image 설정\n\nMaterial 은 다양한 종류가 있습니다.\n\n재질을 표현하기 위해 **Texture Image** 를 입힐 때, `TextureLoader` class 를 사용하여 **이미지 파일 (.png 등)** 을 사용할 수 있습니다.\n\nTexture Image 를 Material 에 적용하는 가장 기본 속성은 `map` 입니다.\n\n아래는 MeshStandardMaterial 에 map 을 사용하여 Texture Image 를 입히는 예시코드 입니다.\n\n```js title=\"map 속성으로 Texture Image 입히기\"\nimport {\n    MeshStandardMaterial,\n    TextureLoader,\n} from 'three';\n\nfunction createMaterial() {\n    const material = new MeshStandardMaterial({\n        map: new TextureLoader().load('/imgs/my-image.png'),\n    });\n}\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## bumpMap 과 normalMap\n\n모든 Material 이 갖지는 않지만, **MeshStandardMaterial** 과 **MeshPhysicalMaterial** 등 에는 또다른 map 속성이 있습니다.\n\n```js title=\"bumpMap 과 normalMap 속성\"\nimport {\n    MeshStandardMaterial,\n    TextureLoader,\n} from 'three';\n\nfunction initMaterial() {\n    const material = new MeshStandardMaterial({\n        map: new TextureLoader().load('/imgs/my-image.png'),\n        bumpMap: new TextureLoader().load('/imgs/my-image.png'),\n        normalMap: new TextureLoader().load('/imgs/my-image.png'),\n    });\n}\n```\n\n* `bumpMap`\n* `normalMap`\n\n\u003cbr /\u003e\n\n물론 `map` 속성도 사용할 수 있지만, 재질을 표현하는 방식과 결과에 차이가 있습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## map, bumpMap, normalMap 정의\n\n* map\n    * 단순 이미지(.png 등) 을 표면에 입혀줍니다.\n    * Light 에 영향을 받지 않습니다.\n    * 가장 낮은 성능을 사용합니다.\n* bumpMap\n    * 3D Graphics 용어 의미\n        * **표면이 조금씩 불규칙한 부분** 을 의미합니다.\n    * 이미지의 밝거나 어두운 부분을 표면의 시각적인 높낮이로 표현합니다.\n        * 밝은 부분: 높게 표현\n        * 어두운 부분: 낮게 표현\n    * Light 에 영향을 받지 않습니다.\n    * map 보다 많은 성능을 사용합니다.\n* normalMap\n    * 3D Graphics 용어 의미\n        * **표면의 수직 방향 벡터** 를 의미합니다.\n    * **법선 벡터 (Normal Vector)** 를 사용하여 **Light 의 반사 방향** 조정하며, 결과적으로 **Light 와 상호작용하여 입체감을 표현** 합니다.\n    * bumpMap 보다 많은 성능을 사용합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## map, bumpMap, normalMap 사용처\n\nmap 방식에 따라 성능차이와 렌더링 차이가 있으므로, 사용처에 따라 적합한 선택이 필요 합니다.\n\n* map\n    * 단순 이미지를 입히거나 패턴으로 사용할 때 적합합니다.\n* bumpMap\n    * 흙이나 벽돌처럼 울퉁불퉁한 질감을 표현할 때 사용합니다.\n* normalMap\n    * 울퉁불퉁함을 넘어 입체감까지 표현할 때 사용합니다.\n    * Light 와 상호작용이 필요할 때 사용합니다.\n\n\u003cbr /\u003e\n\n표현할 재질에 따라 map, bumpMap, normalMap 을 혼합하여 사용하기도 합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며...\n\nThree.js 자체의 학습보다는 3D Graphics 개념을 파악하는 것이 더 어려운 것 같습니다.\n\nThree.js 공식 문서는 API 소개 정도만 안내하고 있어서 아쉽습니다.\n"])</script><script>self.__next_f.push([1,"1b:T4780,"])</script><script>self.__next_f.push([1,"---\nid: 14\ntitle: 'click 이벤트에 animation 연동하기'\ndescription: '특정 버튼을 click 했을 때 animation 을 실행하는 방법을 정리합니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    '3D',\n    'mouse event',\n    'click interaction',\n    'animation',\n    'AnimationMixer',\n    'AnimationClip',\n    'AnimationAction',\n]\n\ncreatedAt: '2024-02-06 15:00:00'\nmodifiedHistories: []\n---\n\n# click 이벤트에 animation 연동하기\n\nAnimation 은 이전 포스팅 [Model 에 Animation 효과 적용하기](https://chocobe.github.io/blog/threejs/2024-01-26-01) 에서 한번 사용해 보았습니다.\n\n사용자 인터렉션이 아닌, 동영상 링크처럼 자동 재생되는 형식으로 구현했습니다.\n\n이번 포스팅에서는 버튼을 click 했을 때, 해당 버튼의 Animation 만 실행되도록 구현해 보고자 합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 예시 코드\n\n예시코드에서 사용한 Model 은 [상상력을 자극하는 고퀄리티 3D 인터랙티브 웹 제작 (최인 강사님)](https://coloso.co.kr/products/graphicdesign-choiin) 강좌 리소스를 사용하였습니다.\n\n3D Tool 에서 Model 에 Keyframe Animation 을 함께 포함시켰을 때, 이 Animation 을 Three.js 에서 필요한 시점에만 실행시키는 동작을 구현할 예정입니다.\n\n\u003cbr /\u003e\n\n아래 예시 코드는 클릭한 버튼의 color 를 scene 의 배경과 rocket model 에 적용하는 기능까지 구현한 상태 입니다.\n\n```js title=\"예시 코드\" showLineNumbers\n// three\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n    ACESFilmicToneMapping,\n\n    Color,\n    DirectionalLight,\n    HemisphereLight,\n\n    MeshStandardMaterial,\n\n    Vector2,\n    Raycaster,\n} from 'three';\n// three.js - addons\nimport {\n    GLTFLoader,\n} from 'three/examples/jsm/loaders/GLTFLoader';\n// style\nimport './style.css';\n\n//\n// state\n//\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n//\n// core\n//\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.setPixelRatio(window.devicePixelRatio);\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.toneMapping = ACESFilmicToneMapping;\n    renderer.shadowMap.enabled = true;\n}\n\nfunction initScene() {\n    scene = new Scene();\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n\n    camera.fov = 45;\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.near = 0.5;\n    camera.far = 2000;\n\n    camera.position.set(100, 100, 100);\n    camera.lookAt(-20, 0, -20);\n\n    camera.updateProjectionMatrix();\n}\n\n//\n// light\n//\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n\n    const light = new DirectionalLight(\n        color,\n        Math.PI * 1\n    );\n\n    light.position.set(-1, 1, 0.5);\n    light.lookAt(0, 0, 0);\n    light.castShadow = true;\n\n    light.shadow.mapSize.set(1024, 1024);\n    light.shadow.camera.near = 0.5;\n    light.shadow.camera.far = 500;\n    light.shadow.camera.top = 180;\n    light.shadow.camera.bottom = -120;\n    light.shadow.camera.left = -100;\n    light.shadow.camera.right = 100;\n\n    scene.add(light);\n}\n\nfunction initHemisphereLight() {\n    const skyColor = new Color('#fff');\n    const groundColor = new Color('#555');\n\n    const light = new HemisphereLight(\n        skyColor,\n        groundColor,\n        Math.PI * 0.5\n    );\n\n    light.position.set(0, -1, 0);\n\n    scene.add(light);\n}\n\n//\n// model\n//\nfunction initModel() {\n    const loader = new GLTFLoader();\n\n    loader.load('/gltf/click.glb', gltf =\u003e {\n        const model = gltf.scene;\n\n        const ratio = 0.1;\n        model.scale.set(ratio, ratio, ratio);\n        model.position.set(0, 0, 0);\n\n        model.traverse(child =\u003e {\n            if (!child.isMesh) {\n                return;\n            }\n\n            child.castShadow = true;\n            child.receiveShadow = true;\n\n            child.material = new MeshStandardMaterial({\n                color: child.material.color,\n                roughness: 0.3,\n            });\n        });\n\n        scene.add(model);\n    });\n}\n\n//\n// interaction\n//\nfunction initResize() {\n    window.addEventListener('resize', () =\u003e {\n        renderer.setSize(window.innerWidth, window.innerHeight);\n\n        camera.aspect = window.innerWidth / window.innerHeight;\n        camera.updateProjectionMatrix();\n    });\n}\n\nfunction initClickInteraction($target) {\n    const raycaster = new Raycaster();\n\n    $target.addEventListener('click', e =\u003e {\n        const {\n            clientX,\n            clientY,\n        } = e;\n\n        const mouseCoord = new Vector2(\n            (clientX / window.innerWidth) * 2 - 1,\n            -(clientY / window.innerHeight) * 2 + 1\n        );\n\n        raycaster.setFromCamera(mouseCoord, camera);\n\n        const intersects = raycaster.intersectObjects(scene.children, true);\n        const firstModel = intersects[0]?.object;\n\n        if (!firstModel || !firstModel.name.match(/^button.*/)) {\n            return;\n        }\n\n        const rocketChangingModel = scene.getObjectByName('change');\n\n        const buttonColor = firstModel.material.color;\n\n        rocketChangingModel.material.color = buttonColor;\n        scene.background = buttonColor;\n    });\n}\n\n//\n// executor\n//\nfunction render() {\n    window.requestAnimationFrame(render);\n\n    renderer.render(scene, camera);\n}\n\n(function init() {\n    const $canvas = initCanvas();\n\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n\n    initDirectionalLight();\n    initHemisphereLight();\n\n    initModel();\n\n    initResize();\n    initClickInteraction($canvas);\n\n    render();\n}());\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## AnimationMixer 만들기\n\nModel 에 포함된 Animation 을 실행시키기 위해서는 **AnimationMixer** 가 필요 합니다.\n\nAnimationMixer 는 **애니메이션 플레이어** 역할을 합니다.\n\n실행시킬 Animation 을 AnimationMixer 에 등록 시켜주고, `render()` 함수에서 `animationMixer.update(프레임)` 으로 다음 장면을 업데이트 해주는 방식으로 동작합니다.\n\n\u003cbr /\u003e\n\n이와 관련한 class 를 살펴보면 다음과 같습니다.\n\n* AnimationMixer: 애니메이션 플레이어 역할을 합니다.\n* AnimationClip: 실행할 애니메이션 1개의 정보를 담고 있습니다.\n* AnimationAction: AnimationClip 을 재생, 정지, 반복 등의 컨트롤 기능을 제공하는 객체 입니다.\n\n\u003cbr /\u003e\n\n애니메이션을 실행하는데 필요한 작업은 다음과 같은 과정이 필요합니다.\n\n1. 애니메이션 대상이 되는 Model 을 사용하여 AnimationMixer 인스턴스를 생성합니다.\n2. Model 에 포함된 `gltf.animations` 를 AnimationMixer 의 `clipAction(clip)` 으로 **AnimationAction** 으로 만듭니다.\n3. click 이벤트가 발생하면, 원하는 AnimationAction 을 실행시킵니다.\n4. 프레임마다 실행되는 `render()` 함수 내부에서 AnimationMixer 의 `update()` 로 장면을 갱신해줍니다.\n\n```js title=\"AnimationMixer import 하기\" showLineNumbers {17-19, 40-41, 43-44}\n// three\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n    ACESFilmicToneMapping,\n\n    Color,\n    DirectionalLight,\n    HemisphereLight,\n\n    MeshStandardMaterial,\n\n    Vector2,\n    Raycaster,\n\n    AnimationMixer,\n    AnimationAction,\n    LoopOnce,\n} from 'three';\n// three.js - addons\nimport {\n    GLTFLoader,\n} from 'three/examples/jsm/loaders/GLTFLoader';\n// style\nimport './style.css';\n\n//\n// state\n//\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { AnimationMixer } */\nlet animationMixer;\n\n/** @type { Record\u003cstring, AnimationAction\u003e } */\nlet animationActions = {};\n```\n\n```js title=\"AnimationMixer 및 AnimationAction 인스턴스 생성하기\" showLineNumbers{129} {28-29, 31-37}\n//\n// model\n//\nfunction initModel() {\n    const loader = new GLTFLoader();\n\n    loader.load('/gltf/click.glb', gltf =\u003e {\n        const model = gltf.scene;\n\n        const ratio = 0.1;\n        model.scale.set(ratio, ratio, ratio);\n        model.position.set(0, 0, 0);\n\n        model.traverse(child =\u003e {\n            if (!child.isMesh) {\n                return;\n            }\n\n            child.castShadow = true;\n            child.receiveShadow = true;\n\n            child.material = new MeshStandardMaterial({\n                color: child.material.color,\n                roughness: 0.3,\n            });\n        });\n\n        // 1. AnimationMixer 생성하기\n        animationMixer = new AnimationMixer(model);\n\n        // 2. AnimationAction 생성하기\n        gltf.animations.forEach(clip =\u003e {\n            const animationAction = animationMixer.clipAction(clip);\n            animationAction.loop = LoopOnce;\n\n            animationActions.push(animationAction);\n        });\n\n        scene.add(model);\n    });\n}\n```\n\n```js title=\"click 시, AnimationAction play() 하기\" showLineNumbers{183} {31-34}\nfunction initClickInteraction($target) {\n    const raycaster = new Raycaster();\n\n    $target.addEventListener('click', e =\u003e {\n        const {\n            clientX,\n            clientY,\n        } = e;\n\n        const mouseCoord = new Vector2(\n            (clientX / window.innerWidth) * 2 - 1,\n            -(clientY / window.innerHeight) * 2 + 1\n        );\n\n        raycaster.setFromCamera(mouseCoord, camera);\n\n        const intersects = raycaster.intersectObjects(scene.children, true);\n        const firstModel = intersects[0]?.object;\n\n        if (!firstModel || !firstModel.name.match(/^button.*/)) {\n            return;\n        }\n\n        const rocketChangingModel = scene.getObjectByName('change');\n\n        const buttonColor = firstModel.material.color;\n\n        rocketChangingModel.material.color = buttonColor;\n        scene.background = buttonColor;\n\n        animationActions.forEach(animationAction =\u003e {\n            animationAction.reset();\n            animationAction.play();\n        });\n    });\n}\n```\n\n```js title=\"render() 함수에서 animationMixer.update() 호출하기\" showLineNumbers{220} {9}\n//\n// executor\n//\nfunction render() {\n    window.requestAnimationFrame(render);\n\n    renderer.render(scene, camera);\n\n    animationMixer?.update(1 / 60);\n}\n```\n\n\u003cvideo width=\"100%\" height=\"auto\" preload=\"none\" autoPlay={true} loop={true} muted={true} controls={false}\u003e\n    \u003csource src=\"/markdownAssets/threejs/2024-02-06-01/2024-02-06-01-01.webm\" type=\"video/webm\" /\u003e\n    animation\n\u003c/video\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## click 한 버튼만 Animation 실행시키기\n\n버튼을 click 하면 모든 버튼의 Animation 이 플레이 되는 것을 볼 수 있습니다.\n\n현재는 click 이벤트가 발생하면, 모든 AnimationAction 을 `play()` 하기 때문입니다.\n\n\u003cbr /\u003e\n\n버튼별 Animation 을 적용하기 위해, Model 에 포함된 `animations` 구조를 파악해야 합니다.\n\n이는 3D Tool 로 구현한 Animations 의 구조에 따라 다르기 때문에, Model animations 의 구조를 파악하고 사용하기 편하게 재구성할 수 있는 능력이 필요합니다.\n\n\u003cbr /\u003e\n\n먼저 Model 의 animations 를 `console` 에서 확인하면 다음과 같습니다.\n\n```js title=\"gltf.animations 구조\" showLineNumbers{129} {39}\n//\n// model\n//\nfunction initModel() {\n    const loader = new GLTFLoader();\n\n    loader.load('/gltf/click.glb', gltf =\u003e {\n        const model = gltf.scene;\n\n        const ratio = 0.1;\n        model.scale.set(ratio, ratio, ratio);\n        model.position.set(0, 0, 0);\n\n        model.traverse(child =\u003e {\n            if (!child.isMesh) {\n                return;\n            }\n\n            child.castShadow = true;\n            child.receiveShadow = true;\n\n            child.material = new MeshStandardMaterial({\n                color: child.material.color,\n                roughness: 0.3,\n            });\n        });\n\n        // 1. AnimationMixer 생성하기\n        animationMixer = new AnimationMixer(model);\n\n        // 2. AnimationAction 생성하기\n        gltf.animations.forEach(clip =\u003e {\n            const animationAction = animationMixer.clipAction(clip);\n            animationAction.loop = LoopOnce;\n\n            animationActions.push(animationAction);\n        });\n\n        console.log('gltf.animations: ', gltf.animations);\n\n        scene.add(model);\n    });\n}\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-02-06-01/2024-02-06-01-02.png\" alt=\"gltf.animations\" /\u003e\n\n\u003cbr /\u003e\n\n* `name`\n    * AnimationClip 의 이름입니다.\n    * `animation_0` 이라는 이름이라서, 버튼별 식별자로 사용할 수는 없어 보입니다.\n* `tracks`\n    * AnimationClip 을 이루는 **최소 단위 Animation** 의 리스트입니다.\n    * 하나의 Animation 에서 회전, 위치 등이 동시에 변형될 수도 있는데, 이를 **VectorKeyframeTrack** 인스턴스로 표현합니다.\n    * `console` 에서 확인하면, **각 track 의 name** 으로 **특정 버튼을 식별** 할 수 있을 것 같습니다.\n        * `button.position`, `button.scale`\n        * `button_1.position`, `button_1.scale`\n        * `button_2.position`, `button_2.scale`\n        * `button_3.position`, `button_3.scale`\n        * `button_4.position`, `button_4.scale`\n        * `button_5.position`, `button_5.scale`\n        * `button_6.position`, `button_6.scale`\n\n\u003cbr /\u003e\n\nclick 이벤트가 발생하면 Raycaster 의 `intersectObjects()` 로 대상 Model 을 참조할 수 있었습니다.\n\n그리고 아래와 같이 대상 Model 의 name 을 참조할 수 있습니다.\n\n```js\nconst intersects = raycaster.intersectObjects(scene.children, true);\n\nconst targetModel = intersects[0].object;\n\nconst targetModelName = targetModel.name;\n```\n\n대상 Model 의 name 과 VectorKeyframeTract 의 name 의 관계를 찾아보면 다음과 같습니다.\n\n```js\nif (targetModelName === track.name.split('.')[0]) {\n    // targetModel 에 대한 track 식별 성공\n}\n```\n\n\u003cbr /\u003e\n\n지금까지 파악한 Model 의 animations 를 요약하면 다음과 같습니다.\n\n* 단일 AnimationClip 이 존재합니다.\n* 모든 버튼의 VectorKeyframeTrack 이 단일 AnimationClip 에 묶여있습니다.\n\n묶여있는 VectorKeyframeTrack 을 각 버튼별 AnimationClip 으로 재구성해야 버튼별 Animation 을 개별로 플레이 할 수 있습니다.\n\n단일 AnimationClip 을 버튼별 AnimationClip 으로 재구성하면 다음과 같습니다.\n\n```js title=\"animationActions 를 animationActionMapper 로 변경\" showLineNumbers\n/** @type { Record\u003cstring, AnimationAction\u003e } */\nlet animationActionMapper = {};\n```\n\n```js title=\"버튼별 AnimationClip 으로 재구성하기\" showLineNumbers{130} {39-63}\n//\n// model\n//\nfunction initModel() {\n    const loader = new GLTFLoader();\n\n    loader.load('/gltf/click.glb', gltf =\u003e {\n        const model = gltf.scene;\n\n        const ratio = 0.1;\n        model.scale.set(ratio, ratio, ratio);\n        model.position.set(0, 0, 0);\n\n        model.traverse(child =\u003e {\n            if (!child.isMesh) {\n                return;\n            }\n\n            child.castShadow = true;\n            child.receiveShadow = true;\n\n            child.material = new MeshStandardMaterial({\n                color: child.material.color,\n                roughness: 0.3,\n            });\n        });\n\n        // 1. AnimationMixer 생성하기\n        animationMixer = new AnimationMixer(model);\n\n        // 2. AnimationAction 생성하기\n        // gltf.animations.forEach(clip =\u003e {\n        //     const animationAction = animationMixer.clipAction(clip);\n        //     animationAction.loop = LoopOnce;\n\n        //     animationActions.push(animationAction);\n        // });\n\n        /** @type { Record\u003cstring, AnimationClip\u003e } */\n        const animationClipMapper = {};\n\n        gltf.animations[0].tracks.forEach(track =\u003e {\n            const name = track.name.split('.')[0];\n            const targetClip = animationClipMapper[name];\n\n            if (targetClip) {\n                targetClip.tracks.push(track);\n            } else {\n                const newClip = new AnimationClip(name, -1, [\n                    track,\n                ]);\n                animationClipMapper[name] = newClip;\n            }\n        });\n\n        Object\n            .entries(animationClipMapper)\n            .forEach(([name, clip]) =\u003e {\n                const clipAction = animationMixer.clipAction(clip);\n                clipAction.loop = LoopOnce;\n\n                animationActionMapper[name] = clipAction;\n            });\n\n        scene.add(model);\n    });\n}\n```\n\n```js title=\"click 한 버튼의 animationAction 만 플레이 하기\" showLineNumbers{212} {35-37}\nfunction initClickInteraction($target) {\n    const raycaster = new Raycaster();\n\n    $target.addEventListener('click', e =\u003e {\n        const {\n            clientX,\n            clientY,\n        } = e;\n\n        const mouseCoord = new Vector2(\n            (clientX / window.innerWidth) * 2 - 1,\n            -(clientY / window.innerHeight) * 2 + 1\n        );\n\n        raycaster.setFromCamera(mouseCoord, camera);\n\n        const intersects = raycaster.intersectObjects(scene.children, true);\n        const firstModel = intersects[0]?.object;\n\n        if (!firstModel || !firstModel.name.match(/^button.*/)) {\n            return;\n        }\n\n        const rocketChangingModel = scene.getObjectByName('change');\n\n        const buttonColor = firstModel.material.color;\n\n        rocketChangingModel.material.color = buttonColor;\n        scene.background = buttonColor;\n\n        // animationActions.forEach(animationAction =\u003e {\n        //     animationAction.reset();\n        //     animationAction.play();\n        // });\n        const targetAnimationAction = animationActionMapper[firstModel.name];\n        targetAnimationAction?.reset();\n        targetAnimationAction?.play();\n    });\n}\n```\n\n\u003cvideo width=\"100%\" height=\"auto\" preload=\"none\" autoPlay={true} loop={true} muted={true} controls={false}\u003e\n    \u003csource src=\"/markdownAssets/threejs/2024-02-06-01/2024-02-06-01-03.webm\" type=\"video/webm\" /\u003e\n    animation\n\u003c/video\u003e"])</script><script>self.__next_f.push([1,"1c:T3178,"])</script><script>self.__next_f.push([1,"---\nid: 13\ntitle: 'Model 에 Click Event 적용하기 (추가: ToneMapping, light.shadow.camera)'\ndescription: 'Canvas 에 렌더링된 Model 에 Click 인터렉션을 적용 해봅니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    '3D',\n    'mouse event',\n    'click interaction',\n]\n\ncreatedAt: '2024-02-03 16:00:00'\nmodifiedHistories: []\n---\n\n# Model 에 Click Event 적용하기 (추가: ToneMapping, light.shadow.camera)\n\nCanvas 에 렌더링된 Model 에 Click 기능을 추가해 보겠습니다.\n\nDOM 과 다르게 Canvas 에 그려지는 Model 은 직접 eventListener 를 적용할 수 없습니다.\n\n그래서 **Raycasting** 이라는 개념을 사용하여 Click Event 를 구현합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 예시 코드\n\n이번 포스팅에서 사용할 예시코드는 다음과 같습니다.\n\n\u003cbr /\u003e\n\n예시코드에서 사용한 Model 은 [상상력을 자극하는 고퀄리티 3D 인터랙티브 웹 제작 (최인 강사님)](https://coloso.co.kr/products/graphicdesign-choiin) 강좌 리소스를 사용하였습니다.\n\n```js title=\"예시 코드\" showLineNumbers {6, 57}\n// three/js\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n    ACESFilmicToneMapping,\n\n    Color,\n    DirectionalLight,\n    HemisphereLight,\n\n    MeshStandardMaterial,\n} from 'three';\n// three.js - addons\nimport {\n    GLTFLoader,\n} from 'three/examples/jsm/loaders/GLTFLoader';\n// style\nimport './style.css';\n\n//\n// state\n//\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { Parameters\u003cParameters\u003cGLTFLoader['load']\u003e[1]\u003e[0]['scene'] } */\nlet mainModel;\n\n//\n// core\n//\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.setPixelRatio(window.devicePixelRatio);\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.shadowMap.enabled = true;\n    renderer.toneMapping = ACESFilmicToneMapping;\n}\n\nfunction initScene() {\n    scene = new Scene();\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n\n    camera.fov = 45;\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.near = 0.5;\n    camera.far = 2000;\n    camera.position.set(100, 100, 100);\n    camera.lookAt(-20, 0, -20);\n\n    camera.updateProjectionMatrix();\n}\n\n//\n// light\n//\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n\n    const light = new DirectionalLight(\n        color,\n        Math.PI * 1\n    );\n\n    light.position.set(-1, 1, 0.5);\n    light.castShadow = true;\n\n    light.shadow.mapSize.set(1024, 1024);\n    light.shadow.camera.near = 0.5;\n    light.shadow.camera.far = 500;\n\n    light.shadow.camera.top = 180;\n    light.shadow.camera.bottom = -100;\n    light.shadow.camera.left = -120;\n    light.shadow.camera.right = 120;\n\n    scene.add(light);\n}\n\nfunction initHemisphereLight() {\n    const skyColor = new Color('#fff');\n    const groundColor = new Color('#555');\n\n    const light = new HemisphereLight(\n        skyColor,\n        groundColor,\n        Math.PI * 0.5\n    );\n\n    light.position.set(0, -1, 0);\n\n    scene.add(light);\n}\n\n//\n// model\n//\nfunction initMainModel() {\n    const loader = new GLTFLoader();\n\n    loader.load('/gltf/click.glb', gltf =\u003e {\n        const ratio = 0.1;\n\n        mainModel = gltf.scene;\n        mainModel.position.set(0, 0, 0);\n        mainModel.scale.set(ratio, ratio, ratio);\n\n        mainModel.traverse(child =\u003e {\n            if (!child.isMesh) {\n                return;\n            }\n\n            child.material = new MeshStandardMaterial({\n                color: child.material.color,\n                roughness: 0.3,\n            });\n\n            child.castShadow = true;\n            child.receiveShadow = true;\n        });\n\n        scene.add(mainModel);\n    });\n}\n\n//\n// executor\n//\nfunction render() {\n    window.requestAnimationFrame(render);\n\n    renderer.render(scene, camera);\n}\n\n(function init() {\n    const $canvas = initCanvas();\n\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n\n    initDirectionalLight();\n    initHemisphereLight();\n\n    initMainModel();\n\n    render();\n}());\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## toneMapping 이란?\n\n예시 코드 57번줄을 보면 다음과 같은 코드가 있습니다.\n\n```js title=\"toneMapping 설정\"\nrenderer.toneMapping = ACESFilmicToneMapping;\n```\n\n\u003cbr /\u003e\n\nHDR(High Dynamic Range) 과 같은 Model 을 LDR(Low Dynamic Range) 로 변환하는 방식을 설정하는 부분입니다.\n\n3D Model 의 경우 HDR 로 만드는데, 사용자의 모니터나 모바일 화면은 LDR 입니다.\n\n고해상도를 저해상도로 변환하는 원리는, 복수 Pixel 의 근사치를 구하여 하나의 Pixel 로 만드는 것입니다.\n\n설정한 방식의 HDR =\u003e LDR 변환 방식을 사용하여 렌더링을 하게 되므로, 선명도가 다르거나 색상의 밝기가 달라지는 차이를 확인할 수 있습니다.\n\n\u003cbr /\u003e\n\n예시 코드에서 사용한 **ACESFilmicToneMapping** 은 toneMapping 중 하나입니다.\n\n* ACESFilmicToneMapping: Academy Color Encoding System FIlmic Tone Mapping\n\nACESFilmicToneMapping 는 영화 예술 과학 아카데미의 후원으로 개발한 무료 ToneMapping 방식입니다.\n\n**실제 사진과 유사한 시각혁 효과를 만들 때 사용합니다.**\n\n\u003cbr /\u003e\n\n어떤 toneMapping 을 사용할지는 자신의 시각적 취향이나 개발 요구사항에 맞게 선택하면 됩니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## DirectionalLight 의 shadow 설정\n\n예시 코드의 DirectionalLight 생성 함수를 보면, shadow 관련 설정이 있습니다.\n\n```js title=\"DirectionalLight 의 shadow 설정\"\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n\n    const light = new DirectionalLight(\n        color,\n        Math.PI * 1\n    );\n\n    light.position.set(-1, 1, 0.5);\n    light.castShadow = true;\n\n    light.shadow.mapSize.set(1024, 1024);\n    light.shadow.camera.near = 0.5;\n    light.shadow.camera.far = 500;\n\n    light.shadow.camera.top = 180;\n    light.shadow.camera.bottom = -100;\n    light.shadow.camera.left = -120;\n    light.shadow.camera.right = 120;\n\n    scene.add(light);\n}\n```\n\n이 중, `light.shahdow.camera` 속성을 살펴보고자 합니다.\n\n\u003cbr /\u003e\n\nLight 는 빛을 만들고 Mesh 의 그림자도 만들어 줍니다.\n\n위 코드를 보면 `shadow` 속성 하위에 `camera` 속성이 있습니다.\n\n쏘아지는 빛에 의한 **그림자를 만드는 시점 설정** 으로 볼 수 있습니다.\n\n\u003cbr /\u003e\n\n`light.shadow.camera` 는 **OrthographicCamera** 객체 입니다.\n\n우리가 지금까지 사용했던 Camera 인 **PerspectiveCamera** 와 다른점은 다음과 같습니다.\n\n* PerspectiveCamera: 3D 환경처럼 **원근법** 이 표현되는 카메라 입니다.\n* OrthographicCamera: 2D 환경처럼 원근법이 나타나지 않는 카메라 입니다.\n\n즉, light 가 비추는 빛은 2D 환경과 같이 원근법을 계산하지 않는 방식을 사용합니다.\n\n\u003cbr /\u003e\n\n그림자는 Light 가 비추는 범위 내에 Mesh 가 있어야 생성됩니다.\n\n이 범위는 **절두체(frustum)** 로 표현됩니다.\n\n\u003e [이미지 출처: 위키백과](https://ko.wikipedia.org/wiki/%EC%A0%88%EB%91%90%EC%B2%B4)\n\n\u003cimg src=\"/markdownAssets/threejs/2024-02-03-02/2024-02-03-02-01.png\" alt=\"절두체\" /\u003e\n\n\u003cbr /\u003e\n\n`light.shadow.camera.top` 설정은 카메라가 비추는 절두체 영역의 중신점에서 **top (위쪽)** 까지의 거리를 설정하는 것입니다.\n\n마찬가지로 bottom, left, right 도 같은 맥락의 설정입니다.\n\n\u003e [이미지 출처: 게임을 게임답게](https://m.blog.naver.com/canny708/221547085908)\n\n\u003cimg src=\"/markdownAssets/threejs/2024-02-03-02/2024-02-03-02-02.png\" alt=\"절두체\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## Raycaster 를 사용하여 Click 이벤트 만들기\n\n이번 포스팅의 메인 내용인 Click 이벤트에 대해 알아보겠습니다.\n\ncanvas 에 렌더링하는 요소는 DOM 이벤트로 감지할 수 없습니다.\n\n그래서 **Raycasting** 이라는 개념을 사용합니다.\n\n\u003e 참고: [위키백과](https://ko.wikipedia.org/wiki/%EA%B4%91%EC%84%A0_%ED%88%AC%EC%82%AC)\n\n* Raycasting: 가상의 광선을 쏘아서 물체와 교차되는 좌표값을 계산하기 위한 기법\n\n\u003cbr /\u003e\n\nThree.js 에서는 `Raycaster` 인스턴스를 생성하여 Mesh, Model 을 특정할 수 있습니다.\n\nHTMLCanvasElement 에 click 이벤트를 추가하고, handler 에서 Raycaster 를 사용하여 어떤 Mesh, Model 이 교차되었는지 식별하는 방법으로 구현합니다.\n\n\u003cbr /\u003e\n\n```js title=\"Raycaster import 하기\" showLineNumbers {14-15}\n// three/js\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n    ACESFilmicToneMapping,\n\n    Color,\n    DirectionalLight,\n    HemisphereLight,\n\n    MeshStandardMaterial,\n\n    Raycaster,\n    Vector2,\n} from 'three';\n```\n\n```js title=\"Raycaster 로 click 이벤트 만들기\" showLineNumbers{152} {4-9, 11-42, 65}\n//\n// interaction\n//\nfunction changeColor(color) {\n    scene.background = color;\n\n    const targetModel = scene.getObjectByName('change');\n    targetModel.material.color = color;\n}\n\nfunction initClickInteraction() {\n    const raycaster = new Raycaster();\n\n    window.addEventListener('click', e =\u003e {\n        const {\n            clientX,\n            clientY,\n        } = e;\n\n        // Raycaster 좌표계로 변환 및 Vector2 인스턴스 생성\n        const mouseCoord = new Vector2();\n        mouseCoord.x = (clientX / window.innerWidth) * 2 - 1;\n        mouseCoord.y = -(clientY / window.innerHeight) * 2 + 1;\n\n        // Raycaster 에 좌표값과 대상 카메라 적용\n        raycaster.setFromCamera(mouseCoord, camera);\n\n        // `Ray(광선)` 과 교차하는 Mesh, Model 을 추출\n        const intersects = raycaster.intersectObjects(scene.children, true);\n        const firstIntersect = intersects[0];\n        const firstModel = firstIntersect?.object;\n\n        if (!firstModel) {\n            return;\n        }\n\n        if (!firstModel.name.match(/^button.*/)) {\n            return;\n        }\n\n        const buttonColor = firstModel.material.color;\n\n        changeColor(buttonColor);\n    });\n}\n\n//\n// executor\n//\nfunction render() {\n    window.requestAnimationFrame(render);\n\n    renderer.render(scene, camera);\n}\n\n(function init() {\n    const $canvas = initCanvas();\n\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n\n    initDirectionalLight();\n    initHemisphereLight();\n\n    initMainModel();\n\n    initClickInteraction();\n\n    render();\n}());\n```\n\n\u003cvideo width=\"100%\" height=\"auto\" preload=\"none\" autoPlay={true} loop={true} muted={true} controls={false}\u003e\n    \u003csource src=\"/markdownAssets/threejs/2024-02-03-02/2024-02-03-02-03.webm\" type=\"video/webm\" /\u003e\n    Raycaster\n\u003c/video\u003e\n\n\u003cbr /\u003e\n\nclick 이벤트를 초기화 하는 `initClickInteraction` 함수를 살펴보겠습니다.\n\nRaycasting 을 사용하기 위해 `new Raycaster()` 로 인스턴스를 만듭니다.\n\n그리고 click 이벤트가 발생하면, raycaster 인스턴스를 사용하게 됩니다.\n\n\u003cbr /\u003e\n\n위 코드에서 사용한 Raycaster 메소드는 다음과 같습니다.\n\n* `setFromCamera(좌표값, 카메라)`\n* `intersectObjects(감지대상_리스트, 재귀_여부)`\n\n\u003cbr /\u003e\n\nclick 이벤트가 발생하면, 마우스위 위치를 알 수 있습니다.\n\n이 좌표값을 사용하여 **Vector2** 인스턴스를 생성할 수 있습니다.\n\n\u003e 참고: [Three.js 공식문서 - Raycaster](https://threejs.org/docs/?q=raycaster#api/en/core/Raycaster)\n\n여기서 중요한 점은 **Raycaster 의 좌표계** 에 맞도록 변환하는 것입니다.\n\nRaycaster 의 좌표계는 2D 이며 다음과 같습니다.\n\n* X축: **-1 ~ 1**\n* Y축: **-1 ~ 1**\n\n\u003cbr /\u003e\n\n그래서 clientX, clientY 좌표값을 아래와 같은 공식으로 변환하여 Vector2 인스턴스를 생성하게 됩니다.\n\n```js title=\"Raycaster 좌표계로 변환\"\nwindow.addEventListener('click', e =\u003e {\n    const {\n        clientX,\n        clientY,\n    } = e;\n\n    const x = (clientX / window.innerWidth) * 2 - 1;\n    const y = -(clientY / window.innerHeight) * 2 + 1;\n});\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\nPath2D 를 사용하여 구현했었던 Canvas API 에 비해, Raycaster 는 코드상으로도 가독성이 좋은 것 같습니다.\n\nThree.js 를 좀 더 잘 사용할 수 있게된다면, 지금까지 사용했던 Canvas API 를 대체하여 사용하고 싶습니다.\n"])</script><script>self.__next_f.push([1,"1d:T1049,"])</script><script>self.__next_f.push([1,"---\nid: 13\ntitle: '(Issue) 조명이 어둡게 보이는 현상'\ndescription: '강좌의 결과물에 비해 실습 결과물의 밝기가 어둡게 렌더링되는 현상이 발생하였습니다. 현상 원인과 해결 방법에 대해 정리하고자 합니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    '3D',\n    'DirectionalLgith',\n    'HemisphereLight',\n    'intensity'\n]\n\ncreatedAt: '2024-02-03 14:00:00'\nmodifiedHistories: []\n---\n\n# (Issue) 조명이 어둡게 보이는 현상\n\n강좌에서 제공하는 프로젝트 환경에서 실습을 하였습니다.\n\n그 후, Vite 프로젝트를 생성하여 복습한 결과, 어둡게 렌더링되는 현상이 발생하였습니다.\n\n* 강좌 결과: 밝게 렌더링\n* 복습 결과: 어둡게 렌더링\n\n\u003cimg src=\"/markdownAssets/threejs/2024-02-03-01/2024-02-03-01-01.png\" alt=\"발기 차이\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 원인은 Three.js 버전\n\n강좌에서 사용한 Three.js 버전은 **0.132.2**, 복습에서는 **0.162.2** 을 사용하였습니다.\n\n\u003cbr /\u003e\n\n동일한 코드임에도 불구하고 복습 결과가 더 어둡게 렌더링된 것은, Three.js 의 버전이 올라가면서 Light 의 **intensity** 값에 대한 단위가 바뀌었기 때문입니다.\n\n\u003e 참고: [Three.js 포럼](https://discourse.threejs.org/t/breaking-changes-between-r132-vs-r133/30629)\n\u003e\n\u003e 참고: [Three.js 포럼 질문](https://discourse.threejs.org/t/r132-r133-darkened-scene/30951)\n\n\n\n\u003cbr /\u003e\n\n\n\n## 해결 방법 1 (deprecated)\n\nWebGLRenderer 인스턴스의 `useLegacyLights` 속성을 `true` 설정하면 강좌 처럼 밝게 렌더링됩니다.\n\n다만 `useLegacyLights` 는 deprecated 된 속성이기 때문에 권장하는 방법이 필요합니다.\n\n```js title=\"useLegacyLights 설정\" {6}\nconst renderer = new WebGLRenderer({\n    canvas,\n    antialias: true,\n});\n\nrenderer.useLegacyLights = true;\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 해결 방법 2 (recommanded)\n\n어둡게 렌더링되는 원인인 Light 의 intensity 값을 조정하는 방법을 권장합니다.\n\n기존에는 intensity 값을 **정수** 를 기준으로 하였지만, **PI** 값을 기준으로 변경되었습니다.\n\n그래서 기존과 동일한 밝기로 렌더링하고자 한다면, **기존_intensity_값 * PI** 를 사용하여 얻을 수 있습니다.\n\n* v0.131.0 에서 Light intensity: **1**\n* 이후 버전에서 Light intensity: **1 * Math.PI**\n\n\u003cbr /\u003e\n\n```js title=\"Light intensity 에 PI 적용\"\nconst directionalLight = new DirectionalLight(\n    new Color('#fff'),\n    Math.PI * 1\n);\n\nconst hemisphereLight = new HemisphereLight(\n    new Color('#fff'),\n    new Color('#000'),\n    Math.PI * 0.5\n);\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-02-03-01/2024-02-03-01-02.png\" alt=\"Light intensity 에 PI 적용\" /\u003e\n\n\u003cbr /\u003e\n\nLight 의 intensity 를 사용하여 기존과 거의 유사한 밝기의 결과를 확인할 수 있습니다.\n\n다만 완벽히 동일한 결과를 얻을수는 없습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## Light 의 intensity 단위가 바뀐 이유\n\n\u003e [참고: Physically Based Rendering and Lighting](https://discoverthreejs.com/book/first-steps/physically-based-rendering/)\n\n**물리 기반 렌더링 (Phycally Based Renderering)** 을 위해 Light 의 intensity 값에 PI 를 도입하게 되었다고 합니다.\n\n물리 기반이란, Light 와 물체의 거리에 따라 생성할 그림자에 물리 법칙을 적용하여 더 사실적으로 렌더링할 수 있게 됩니다.\n\n\u003cbr /\u003e\n\nintensity 에 PI 를 적용하도록 변경된 Light 는 다음과 같습니다.\n\n* AmbientLight\n* DirectionalLight\n* HemisphereLight\n* SpotLight\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\n복습한 결과가 강좌의 결과와 다른 이유가 너무나 궁금하였습니다.\n\n만약 이번 이슈를 해결하지 못하고 넘어간다면, 의도한 밝기의 결과를 만들지 못한다는 걱정이 컸습니다.\n\n다행히 Three.js 포럼에 관련 질문과 설명이 있었습니다.\n\n\u003cbr /\u003e\n\nThree.js 의 공식 문서는 개요 파악 정도로 사용하고, Three.js 포럼에서 좀 더 자세한 내용을 찾아보아야 할 것 같습니다.\n"])</script><script>self.__next_f.push([1,"1e:T2afe,"])</script><script>self.__next_f.push([1,"---\nid: 12\ntitle: '키보드를 사용하여 카메라 이동 인터렉션 만들기'\ndescription: '키보드 입력에 대한 event listener 를 사용하여 카메라를 이동할 수 있는 인터렉션을 구현해 봅니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    '3D',\n    'keyboard event',\n    'camera',\n    'interaction',\n]\n\ncreatedAt: '2024-01-30 18:00:00'\nmodifiedHistories: []\n---\n\n# 키보드를 사용하여 카메라 이동 인터렉션 만들기\n\n이번에는 사용자 인터렉션을 구현해 보겠습니다.\n\n키보드 입력값에 따라 카메라를 이동할 수 있는 기능을 구현해 보고자 합니다.\n\n추가로 브라우저 resize 이벤트를 사용하여 canvas 의 크기를 조정하는 기능까지 구현해 보겠습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 예시 코드\n\n이번 포스팅에서 사용할 예시 코드는 다음과 같습니다.\n\n```js title=\"예시 코드\" showLineNumbers\n// three.js\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n\n    Color,\n    PointLight,\n    HemisphereLight,\n\n    MeshBasicMaterial,\n    MeshStandardMaterial,\n} from 'three';\n// three.js - addons\nimport {\n    GLTFLoader,\n} from 'three/examples/jsm/loaders/GLTFLoader';\n// style\nimport './style.css';\n\n/** @type { WebGLRenderer} */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n//\n// core\n//\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.setPixelRatio(window.devicePixelRatio);\n    renderer.setSize(\n        window.innerWidth,\n        window.innerHeight\n    );\n}\n\nfunction initScene() {\n    scene = new Scene();\n    scene.background = new Color('#000');\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n    camera.fov = 45;\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.near = 0.1;\n    camera.far = 3000;\n    camera.position.set(0, 0, 0);\n    camera.lookAt(0, 0, 0);\n\n    camera.updateProjectionMatrix();\n}\n\n//\n// light\n//\nfunction initPointLight() {\n    const color = new Color('#fff');\n\n    const light = new PointLight(color, 1);\n    light.position.set(0, 0, 0);\n\n    scene.add(light);\n}\n\nfunction initHemisphereLight() {\n    const skyColor = new Color('#000');\n    const groundColor = new Color('#fff');\n\n    const light = new HemisphereLight(\n        skyColor,\n        groundColor,\n        0.4\n    );\n    light.position.set(1, 0, 1);\n\n    scene.add(light);\n}\n\n//\n// model\n//\nfunction initMoveModel() {\n    const loader = new GLTFLoader();\n\n    loader.load('/gltf/move.glb', gltf =\u003e {\n        const moveModel = gltf.scene;\n\n        // Model 의 크기가 너무 커서, 0.1 배로 줄여서 사용합니다.\n        const ratio = 0.1;\n\n        moveModel.scale.set(\n            ratio,\n            ratio,\n            ratio\n        );\n        moveModel.position.set(0, 0, 0);\n\n        moveModel.traverse(child =\u003e {\n            if (!child.isMesh) {\n                return;\n            }\n\n            switch(child.name) {\n                case 'light':\n                    child.material = new MeshBasicMaterial({\n                        color: new Color('#fff'),\n                    });\n                    break;\n                default:\n                    child.material = new MeshStandardMaterial({\n                        color: new Color('#fff'),\n                        roughness: 0.5,\n                    });\n            }\n        });\n\n        // Model 에 포함되어 있는 카메라 위치값을 사용합니다.\n        const moveModelCamera = gltf.cameras[0];\n        camera.position.set(\n            moveModelCamera.position.x * ratio,\n            moveModelCamera.position.y * ratio,\n            moveModelCamera.position.z * ratio\n        );\n\n        scene.add(moveModel);\n    });\n}\n\n//\n// executor\n//\nfunction render() {\n    window.requestAnimationFrame(render);\n\n    renderer.render(scene, camera);\n}\n\n(function init() {\n    const $canvas = initCanvas();\n\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n\n    initPointLight();\n    initHemisphereLight();\n\n    initMoveModel();\n\n    render();\n}());\n```\n\n\u003cbr /\u003e\n\n예시코드에서 사용한 Model 은 [상상력을 자극하는 고퀄리티 3D 인터랙티브 웹 제작 (최인 강사님)](https://coloso.co.kr/products/graphicdesign-choiin) 강좌 리소스를 사용하였습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 이동 상태값 만들기\n\n눌러진 키보드 방향키에 따라 카메라의 Z 축 위치를 변경하는 인터렉션을 만들고자 합니다.\n\n* ArrowUp(위쪽 방향키): 카메라가 -Z 축으로 이동합니다.\n* ArrowDown(아래쪽 방향키): 카메라가 +Z 축으로 이동합니다.\n\n\u003cbr /\u003e\n\nArrowUp, ArrowDown 키가 눌려졌는지 상태값이 필요합니다.\n\n이 상태값을 사용하여, 키가 눌려졌다면 Camera 의 `position.z` 값을 증감시켜서, 마치 화면(카메라) 가 이동하는 듯한 효과를 연출하겠습니다.\n\n\u003cbr /\u003e\n\n```js title=\"이동 상태값 만들기\" showLineNumbers{21} {10-13}\n/** @type { WebGLRenderer} */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\nconst moveInteractionState = {\n    forward: false,\n    backward: false,\n};\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 키보드 이벤트 리스너 만들기\n\nArrowUp, ArrowDown 에 대한 키보드 이벤트 리스너를 추가해 보겠습니다.\n\n이벤트 리스너는 `moveInteractionState` 의 값을 변경하여, 해당 키가 눌려졌는지에 대한 상태를 변경하는 역할을 하게 됩니다.\n\n```js title=\"키보드 이벤트 리스너 만들기\" showLineNumbers{153}\n//\n// interaction\n//\nfunction initMoveInteraction() {\n    window.addEventListener('keydown', e =\u003e {\n        const key = e.key.toLowerCase();\n\n        switch(key) {\n            case 'up':\n            case 'arrowup':\n                moveInteractionState.forward = true;\n                break;\n            case 'down':\n            case 'arrowdown':\n                moveInteractionState.backward = true;\n                break;\n        }\n    });\n\n    window.addEventListener('keyup', e =\u003e {\n        const key = e.key.toLowerCase();\n\n        switch(key) {\n            case 'up':\n            case 'arrowup':\n                moveInteractionState.forward = false;\n                break;\n            case 'down':\n            case 'arrowdown':\n                moveInteractionState.backward = false;\n                break;\n        }\n    });\n}\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 키보드 상태값으로 카메라 이동시키기\n\n예시 코드의 `render()` 함수는 60 프레임으로 호출됩니다.\n\n매 프레임마다 키보드 상태값에 따라 카메라의 위치를 증감 시켜주는 기능을 추가하여, 카메라를 이동시키는 기능을 구현할 수 있습니다.\n\n\u003cbr /\u003e\n\n카메라를 이동시키는 기능으로 `animateCamera()` 함수를 만들면 다음과 같습니다.\n\n```js title=\"키보다 상태값으로 카메라 이동시키기\" showLineNumbers {4-13, 23, 38}\n//\n// animation\n//\nfunction animateCamera() {\n    switch(true) {\n        case moveInteractionState.forward:\n            camera.position.z -= 6;\n            break;\n        case moveInteractionState.backward:\n            camera.position.z += 6;\n            break;\n    }\n}\n\n//\n// executor\n//\nfunction render() {\n    window.requestAnimationFrame(render);\n\n    renderer.render(scene, camera);\n\n    animateCamera();\n}\n\n(function init() {\n    const $canvas = initCanvas();\n\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n\n    initPointLight();\n    initHemisphereLight();\n\n    initMoveModel();\n\n    initMoveInteraction();\n\n    render();\n}());\n```\n\n\u003cvideo width=\"100%\" height=\"auto\" preload=\"none\" autoPlay={true} loop={true} muted={true} controls={false}\u003e\n    \u003csource src=\"/markdownAssets/threejs/2024-01-30-01/2024-01-30-01-01.webm\" type=\"video/webm\" /\u003e\n    키보드 상태값으로 카메라 이동시키기\n\u003c/video\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 브라우저 resize 이벤트로 canvas 크기 조정하기\n\n**resize** 이벤트는 브라우저의 크기가 변경되면 발생하는 이벤트 입니다.\n\nresize 이벤트가 발생했을 때, canvas 의 크기를 변경된 브라우저 크기로 변경하는 기능을 구현해 보겠습니다.\n\n\u003cbr /\u003e\n\n먼저 canvas 의 크기를 변경하기 위에 `renderer.setSize()` 메솓드를 사용합니다.\n\n```js title=\"브라우저 resize 이벤트로 canvas 크기 조정하기\" showLineNumbers{47} {13-18}\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.setPixelRatio(window.devicePixelRatio);\n    renderer.setSize(\n        window.innerWidth,\n        window.innerHeight\n    );\n\n    window.addEventListener('resize', () =\u003e {\n        renderer.setSize(\n            window.innerWidth,\n            window.innerHeight\n        );\n    });\n}\n```\n\n\u003cbr /\u003e\n\n위 코드를 적용한 후, 브라우저 크기를 변경해보면, canvas 의 크기도 함께 조정됩니다.\n\n하지만 찌그러진 결과가 렌더링됨을 볼 수 있습니다.\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-30-01/2024-01-30-01-02.png\" alt=\"찌그러진 결과\" /\u003e\n\n\u003cbr /\u003e\n\n이 현상은 **Camera** 의 **비율 (aspect ratio)** 는 최초 브라우저의 비율을 그대로 사용하고 있기 때문입니다.\n\n`camera.aspect` 속성에도 변경된 브라우저 크기의 비율을 적용하여 문제를 해결할 수 있습니다.\n\n```js title=\"찌그러짐 해소\" showLineNumbers{47} {19-20}\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.setPixelRatio(window.devicePixelRatio);\n    renderer.setSize(\n        window.innerWidth,\n        window.innerHeight\n    );\n\n    window.addEventListener('resize', () =\u003e {\n        renderer.setSize(\n            window.innerWidth,\n            window.innerHeight\n        );\n\n        camera.aspect = window.innerWidth / window.innerHeight;\n        camera.updateProjectionMatrix();\n    });\n}\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\n처음으로 사용자 인터렉션을 적용해 보았습니다.\n\nJavascript 의 이벤트 처리 방식을 그대로 따르는 방법이라서 친숙하였습니다.\n\n\u003cbr /\u003e\n\n그리고 인터렉션에 의한 렌더링을 변경할 때, **프레임** 을 그리는 `render()` 함수에서 변화를 적용하여야 함을 알게 되었습니다.\n\n만약 화면을 변경하는 부분을 `render()` 함수가 아닌, event listener 에서 직접 하게 되면, **뚝뚝 끊기면서 렌더링되는 현상** 이 나타났습니다.\n\n이는 키보드를 누르고 있을 때, 체터링 간격이 `1 /60` 보다 큰 값인 것으로 추측되었습니다.\n"])</script><script>self.__next_f.push([1,"1f:T1d82,"])</script><script>self.__next_f.push([1,"---\nid: 11\ntitle: 'canvas 크기 설정 및 material 렌더링 side 설정'\ndescription: '사용자 모니터 대응을 위한 WebGLRenderer 설정과 material 의 렌더링 side 설정에 대해 정리합니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    'setSize()',\n    'setPixelRatio()',\n    'material',\n    'FrontSide',\n    'BackSide',\n    'DoubleSide',\n]\n\ncreatedAt: '2024-01-28 23:00:00'\nmodifiedHistories: []\n---\n\n# canvas 크기 설정 및 material 렌더링 side 설정\n\n지금까지는 HTMLCanvasElement 인스턴스의 width, height 를 직접 설정하여 사용하고 있었습니다.\n\n이번에는 좀 더 사용자 장치(모니터)에 적합한 렌더링이 되도록 설정하는 방법과 material 의 side 속성에 대해 정리하겠습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## WebGLRenderer 를 사용한 canvas 크기 및 Pixel 비율 설정\n\n지금까지는 HTMLCanvasElement 의 크기를 아래와 같이 설정하였습니다.\n\n```js title=\"HTMLCanvasElement 크기 설정하기\" showLineNumbers\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n    $canvas.width = window.innerWidth;\n    $canvas.height = window.innerHeight;\n\n    // ...\n}\n```\n\n이렇게 설정하여도 일반적인 모니터에서는 문제없이 렌더링 됩니다.\n\n이는 **Pixel Ratio** 가 **1** 인 모니터에 대한 설정이며, 기본 설정값입니다.\n\n\u003cbr /\u003e\n\n\u003e 참고: [Window: devicePixelRatio 속성 - MDN](https://developer.mozilla.org/ko/docs/Web/API/Window/devicePixelRatio)\n\nPixel Ratio 이란, **렌더링할 Pixel 크기** 와 **모니터의 물리적 Pixel 크기** 에 대한 비율입니다.\n\n웹을 기준으로 본다면, 아래의 값이 Pixel Ratio 를 도출할 수 있습니다.\n\n* `물리적(모니터) Pixel 크기` / `CSS Pixel 크기`\n\n즉, 일반적인 모니터의 **Pixel Ratio** 가 **1** 이라는 뜻은, **CSS Pixel 1개** 당 **모니터의 실제 Pixel 1개** 를 사용하여 렌더링한다는 의미입니다.\n\n\u003cbr /\u003e\n\n**HiDPI** 와 **Apple 의 retina** 디스플레이는 Pixel Ratio 가 2인 모니터입니다.\n\n이는 기존의 **CSS Pixel 1개** 를 **모니터의 실제 Pixel 2개** 에 렌더링한다는 의미가 되며, 이러한 제품은 더 많은 물리적 Pixel 을 사용하여 더 선명한 화질을 제공하기 위함입니다.\n\n\u003cbr /\u003e\n\n우리가 Web 에서 사용하는 HTMLCanvasElement 에 Pixel Ratio 를 적용하려면, 아래와 같은 설정이 필요합니다.\n\n```js title=\"HTMLCanvasElement 에 Pixel Ratio 적용하기\" showLineNumbers\nconst pixelRatio = window.devicePixelRatio;\n\nconst $canvas = document.createElement('canvas');\n\n$canvas.style.width = `${window.innerWidth}px`;\n$canvas.style.height = `${window.innerHeight}px`;\n\n$canvas.width = window.innerWidth * pixelRatio;\n$canvas.width = window.innerHeight * pixelRatio;\n```\n\n\u003cbr /\u003e\n\n이렇게 설정하게 되면, 아래와 같이 선명도의 차이가 나타납니다.\n\n\u003e 이미지 출처: [Window: devicePixelRatio 속성 - MDN](https://developer.mozilla.org/ko/docs/Web/API/Window/devicePixelRatio)\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-28-02/2024-01-28-02-01.png\" alt=\"Pixel Ratio\" /\u003e\n\n\u003cbr /\u003e\n\nThree.js 는 WebGLRenderer 인스턴스를 사용하여 Pixel Ratio 를 설정할 수 있습니다.\n\n```js title=\"Three.js 에 Pixel Ratio 설정하기\"\nconst renderer = new WebGLRenderer();\n\nrenderer.setPixelRatio(window.devicePixelRatio);\n```\n\n\u003cbr /\u003e\n\n추가로 HTMLCanvasElement 의 width 와 height 를 직접 설정하는 것이 아닌 WebGLRenderer 의 `setSize()` 메소드를 사용하여 설정할 수 있습니다.\n\n`setSize()` 는 HTMLCanvasElement 의 크기 변경과 함께, **Viewport** 까지 **Fit** 하게 설정해 줍니다.\n\n이를 적용하면 아래와 같이 코드를 작성할 수 있습니다.\n\n```js title=\"WebGLRenderer 설정\" showLineNumbers\nimport {\n    WebGLRenderer,\n} from 'three';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.setPixelRatio(window.devicePixelRatio);\n    renderer.setSize(\n        window.innerWidth,\n        window.innerHeight\n    );\n}\n\nfunction init() {\n    const $canvas = initCanvas();\n\n    initRenderer($canvas);\n}\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## Material 의 side 프로퍼티\n\nMaterial 은 Model 의 재질을 담당하며, 렌더링 대상 중 하나입니다.\n\n렌더링 대상이 많을수록 더 많은 PC 성능을 요구하게 되므로, Material 도 최적화가 필요합니다.\n\n\u003cbr /\u003e\n\nThree.js 의 Material 인스턴스는 `side` 라는 프로퍼티를 제공합니다.\n\n이는 실제로 렌더링할 **면** 을 지정하여, 렌더링 대상에 속한 Material 만 렌더링하게 됩니다.\n\n\u003cbr /\u003e\n\nMaterial 의 `side` 는 다음과 같은 설정을 할 수 있습니다.\n\n* `FrontSide`\n    * Mesh 의 **앞면** 에 해당하는 Material 만 렌더링 합니다.\n    * 뒷면은 렌더링하지 않습니다.\n    * 기본값 입니다.\n* `BackSide`\n    * Mesh 의 **뒷면** 에 해당하는 Material 만 렌더링 합니다.\n    * 앞면은 렌더링하지 않습니다.\n* `DoubleSide`\n    * Mesh 의 전체 Material 을 렌더링 합니다.\n\n\u003cbr /\u003e\n\nGLTFLoader 를 사용하여 불러온 Model 에 `side` 를 적용하면 다음과 같습니다.\n\n```js title=\"Material 의 side 설정\" showLineNumbers\nimport {\n    FrontSide,\n    BackSide,\n    DoubleSide,\n} from 'three';\nimport {\n    GLTFLoader,\n} from 'three/examples/jsm/loader/GLTFLoader';\n\nfunction initFrontSideModel() {\n    const loader = new GLTFLoader();\n\n    loader.load('/gltf/someModel.gltf', gltf =\u003e {\n        gltf.scene.traverse(child =\u003e {\n            if (!child.isMesh) {\n                return;\n            }\n\n            // `앞면` 만 렌더링\n            child.material.side = FrontSide;\n        });\n    });\n}\n\nfunction initBackSideModel() {\n    const loader = new GLTFLoader();\n\n    loader.load('/gltf/someModel.gltf', gltf =\u003e {\n        gltf.scene.traverse(child =\u003e {\n            if (!child.isMesh) {\n                return;\n            }\n\n            // `뒷면` 만 렌더링\n            child.material.side = BackSide;\n        });\n    });\n}\n\nfunction initDoubleSideModel() {\n    const loader = new GLTFLoader();\n\n    loader.load('/gltf/someModel.gltf', gltf =\u003e {\n        gltf.scene.traverse(child =\u003e {\n            if (!child.isMesh) {\n                return;\n            }\n\n            // 앞, 뒤 모두 렌더링\n            child.material.side = DoubleSide;\n        });\n    });\n}\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\n스터디를 한 후, 내용이 이해되지 않거나 전혀 생각나지 않을 경우, 상실감을 느낍니다.\n\n그래서 강의 수강과 함께 정리를 병행하고 있습니다.\n\n내용에 따라 하나의 강의를 분리하여 정리하기도 합니다.\n\n이렇게 학습하게 되면, 비교적 학습시간이 많이 필요하게 되지만, 많은 것을 기억할 수 있습니다.\n\n\u003cbr /\u003e\n\n느린 학습 속도에 조바심이 나기도 하고, 정리에 대한 부담감도 생깁니다.\n\n100% 를 기억하지는 못하더라도, 맥락과 주요 개념을 기억하기 위해서는 당연한 방법이라고 생각합니다.\n\n다만 투자하는 시간에 대한 아쉬움으로 짧은 푸념을 남깁니다.\n"])</script><script>self.__next_f.push([1,"20:T2b48,"])</script><script>self.__next_f.push([1,"---\nid: 9\ntitle: 'Model 에 Animation 효과 적용하기'\ndescription: 'Model 파일인 .gltf, .glb 에 Animation 을 적용하는 방법에 대해 정리합니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    'javascript',\n    '3d',\n    '.gltf',\n    '.glb',\n    'model',\n    'animation',\n]\n\ncreatedAt: '2024-01-26 20:00:00'\nmodifiedHistories: []\n---\n\n# Model 에 Animation 효과 적용하기\n\nC4D 또는 Blender 를 사용하여 Model 을 만들고 Three.js 에 렌더링할 수 있게 되었습니다.\n\n이번 포스팅에서는 Model 에 Animation 효과를 적용하는 방법에 대해 알아보고자 합니다.\n\n\u003cbr /\u003e\n\n예시코드에서 사용한 Model 은 [상상력을 자극하는 고퀄리티 3D 인터랙티브 웹 제작 (최인 강사님)](https://coloso.co.kr/products/graphicdesign-choiin) 강좌 리소스를 사용하였습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## Model 의 Animation 을 적용하는 방법\n\nAnimation 은 2가지 방법으로 적용할 수 있습니다.\n\n* 첫번쨰 방법: Model 의 position, rotation, scale 등의 값을 직접 update 하는 방법\n* 두번째 방법: 3D Tool 에서 Model 에 적용한 Keyframe Animation 을 불러와서 Update 하는 방법\n\n\u003cbr /\u003e\n\n두가지 방법 모두 원리는 HTMLCanvasElement 를 사용한 Animation 을 적용하는 방법과 동일합니다.\n\n첫번째 방법은 가속도와 같은 자연스러운 효과를 구현하기 어렵지만, 두번째 방법을 사용하면 3D Tool 에서 정교하게 만든 Animation 을 사용할 수 있습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 예시 코드\n\n이번 포스팅은 Rocket Model 을 렌더링 한 시점부터 시작합니다.\n\n```js title=\"예시 코드\" showLineNumbers\n// three.js\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n\n    Color,\n    DirectionalLight,\n} from 'three';\nimport {\n    OrbitControls,\n} from 'three/examples/jsm/controls/OrbitControls';\nimport {\n    GLTFLoader,\n} from 'three/examples/jsm/loaders/GLTFLoader';\n// style\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { OrbitControls } */\nlet controls;\n\n//\n// core\n//\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n    $canvas.width = window.innerWidth;\n    $canvas.height = window.innerHeight;\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.shadowMap.enabled = true;\n}\n\nfunction initScene() {\n    scene = new Scene();\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n    camera.fov = 35;\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.position.set(0, 0, 30);\n\n    camera.updateProjectionMatrix();\n}\n\nfunction initControls($target) {\n    controls = new OrbitControls(camera, $target);\n    controls.enableDamping = true;\n}\n\n//\n// light\n//\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n\n    const light = new DirectionalLight(color, 1);\n    light.castShadow = true;\n    light.shadow.mapSize.set(2048, 2048);\n    light.shadow.radius = 8;\n    light.position.set(10, 10, 10);\n    light.lookAt(0, 0, 0);\n\n    scene.add(light);\n}\n\n//\n// model\n//\nfunction initRocketModel() {\n    const loader = new GLTFLoader();\n\n    loader.load('/gltf/rocket.glb', gltf =\u003e {\n        gltf.scene.position.set(0, -5, 5);\n        gltf.scene.traverse(child =\u003e {\n            if (!child.isMesh) {\n                return;\n            }\n\n            child.castShadow = true;\n            child.receiveShadow = true;\n            child.material.metalness = 0;\n        });\n\n        scene.add(gltf.scene);\n    });\n}\n\n//\n// executor\n//\nfunction render() {\n    window.requestAnimationFrame(render);\n\n    renderer.render(scene, camera);\n    controls.update();\n}\n\n(function init() {\n    const $canvas = initCanvas();\n\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n    initControls($canvas);\n\n    initDirectionalLight();\n\n    initRocketModel();\n\n    render();\n}());\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-26-01/2024-01-26-01-01.png\" alt=\"예시 코드 결과\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 첫번째 방법: Model 을 직접 변형하여 Animation 효과 구현하기\n\nGLTFLoader 를 사용하여 Model 을 불러옵니다.\n\n불러온 Model 의 position, roation, scale 을 변경하는 함수를 만들고, 매 Frame 을 렌더링할 때마다 update 시켜줍니다.\n\n\u003cbr /\u003e\n\n아래 코드는 Model 의 rotation.y 의 좌표값을 변경하여, 로켓 Model 이 회전하는 Animation 을 구현합니다.\n\n```js title=\"첫번째 방법: rocketModel global 변수 추가\" showLineNumbers {10, 33-34}\n// three.js\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n\n    Color,\n    DirectionalLight,\n\n    Mesh,\n} from 'three';\nimport {\n    OrbitControls,\n} from 'three/examples/jsm/controls/OrbitControls';\nimport {\n    GLTFLoader,\n} from 'three/examples/jsm/loaders/GLTFLoader';\n// style\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { OrbitControls } */\nlet controls;\n\n/** @type { Mesh } */\nlet rocketModel;\n```\n\n```js title=\"첫번쨰 방법 - Animation 구현\" showLineNumbers{93} {8, 25-34, 45}\n//\n// model\n//\nfunction initRocketModel() {\n    const loader = new GLTFLoader();\n\n    loader.load('/gltf/rocket.glb', gltf =\u003e {\n        rocketModel = gltf.scene;\n\n        gltf.scene.position.set(0, -5, 5);\n        gltf.scene.traverse(child =\u003e {\n            if (!child.isMesh) {\n                return;\n            }\n\n            child.castShadow = true;\n            child.receiveShadow = true;\n            child.material.metalness = 0;\n        });\n\n        scene.add(gltf.scene);\n    });\n}\n\n//\n// animation\n//\nfunction animateRocket() {\n    if (!rocketModel) {\n        return;\n    }\n\n    rocketModel.rotation.y += 0.1;\n}\n\n//\n// executor\n//\nfunction render() {\n    window.requestAnimationFrame(render);\n\n    renderer.render(scene, camera);\n    controls.update();\n\n    animateRocket();\n}\n```\n\n\u003cvideo width=\"100%\" height=\"auto\" preload=\"none\" autoPlay={true} loop={true} muted={true} controls={false}\u003e\n    \u003csource src=\"/markdownAssets/threejs/2024-01-26-01/2024-01-26-01-02.webm\" type=\"video/webm\" /\u003e\n    첫번쨰 방법 - Animation 구현\n\u003c/video\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 두번째 방법: 3D Model 의 Keyframe Animation 사용하기\n\n첫번쨰 방법으로는 복잡한 Animation 을 구현하기 어렵습니다.\n\n3D Tool 을 사용하여 Model 의 Keyframe Animation 을 만들 수 있으며, Model 이 가진 Animation 을 그대로 사용할 수 있으므로, 정교하고 자연스러운 Animation 을 연출할 수 있습니다.\n\n\u003cbr /\u003e\n\nGLTFLoader 를 사용하여 Model 을 불러오면, callback 을 통하여 gltf 객체에 접근할 수 있습니다.\n\ngltf 객체에는 animations 속성이 Model 의 Keyframe Animation 을 가지고 있습니다.\n\n\u003cbr /\u003e\n\ngltf 객체의 animations 를 사용하기 위해 `THREE.AnimationMixer` 객체를 생성합니다.\n\n아래는 `THREE.AnimationMixer` 를 사용하여 Animation 을 적용한 코드 입니다.\n\n```js title=\"두번째 방법 - AnimationMixer global 변수 정의\" showLineNumbers {12, 38-39}\n// three.js\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n\n    Color,\n    DirectionalLight,\n\n    Mesh,\n\n    AnimationMixer,\n} from 'three';\nimport {\n    OrbitControls,\n} from 'three/examples/jsm/controls/OrbitControls';\nimport {\n    GLTFLoader,\n} from 'three/examples/jsm/loaders/GLTFLoader';\n// style\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { OrbitControls } */\nlet controls;\n\n/** @type { Mesh } */\nlet rocketModel;\n\n/** @type { AnimationMixer } */\nlet animationMixer;\n```\n\n```js title=\"두번째 방법: Animation 구현\" showLineNumbers{98} {10-13, 40-44}\n//\n// model\n//\nfunction initRocketModel() {\n    const loader = new GLTFLoader();\n\n    loader.load('/gltf/rocket.glb', gltf =\u003e {\n        rocketModel = gltf.scene;\n\n        animationMixer = new AnimationMixer(rocketModel);\n        gltf.animations.forEach(clip =\u003e {\n            animationMixer.clipAction(clip).play();\n        });\n\n        gltf.scene.position.set(0, -5, 5);\n        gltf.scene.traverse(child =\u003e {\n            if (!child.isMesh) {\n                return;\n            }\n\n            child.castShadow = true;\n            child.receiveShadow = true;\n            child.material.metalness = 0;\n        });\n\n        scene.add(gltf.scene);\n    });\n}\n\n//\n// animation\n//\nfunction animateRocket() {\n    // if (!rocketModel) {\n    //     return;\n    // }\n\n    // rocketModel.rotation.y += 0.1;\n\n    if (!animationMixer) {\n        return;\n    }\n\n    animationMixer.update(1 / 60);\n}\n```\n\n\u003cvideo width=\"100%\" height=\"auto\" preload=\"none\" autoPlay={true} loop={true} muted={true} controls={false}\u003e\n    \u003csource src=\"/markdownAssets/threejs/2024-01-26-01/2024-01-26-01-03.webm\" type=\"video/webm\" /\u003e\n    두번쨰 방법 - Animation 구현\n\u003c/video\u003e\n\n\u003cbr /\u003e\n\n위 코드를 살펴 보겠습니다.\n\n먼저 `AnimationMixer` 타입 변수를 선언하고 있습니다.\n\n이는 `AnimationMixer` 인스턴스를 생성하는 곳과 사용하는 scope 가 달라서 global 변수로 선언합니다.\n\n\u003cbr /\u003e\n\n그리고 GLTFLoader 를 사용하여 gltf 파일을 로드하게 되면, `AnimationMixer` 인스턴스를 생성합니다.\n\n여기서 중요한 점은 `gltf.animations` 의 구성요소인 `animationClip` 객체를 `AnimationMixer` 에 모두 등록`(clipAction())` 해주고 `play()` 시켜주는 것 입니다.\n\n이렇게 등록하게 되면, Frame 을 그릴때 마다 호출하는 `animate()` 함수 내부에서 `AnimationMixer` 의 `update(프레임_증감_값)` 으로 다음 Frame 을 그리게 됩니다.\n\n결과적으로 `AnimationMixer` 에 등록한 Model 의 `animations` 속성을 렌더링하여, Animation 효과가 연출됩니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 추가: gltf.animations 구성\n\n* `AnimationClip` 타입: `gltf.animations` 를 구성하는 객체 타입\n\n\n\n\n\u003cbr /\u003e\n\n\n\n## 추가: AnimationClip 구성\n\n* `duration`: Animation 의 길이(`초` 단위 시간값)\n* `tracks`: Animation 을 구성하는 변화 데이터\n    * `VectorKeyframeTrack` 타입 객체: Model 의 위치를 변경하는 Track\n    * `QuaternionKeyframeTrack` 타입 객체: Model 을 회전시키는 Track\n    * `tracks` 하위의 타입은 Three.js 에서 변경하기 보다, 어떤 효과로 구성된 Animation 인지 파악하는 정도로만 사용하면 될 것 같습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\n원하는 Animation 을 구현하기 위해서는 3D Tool 사용방법도 익혀야 할 것 같습니다.\n\nModel 의 Animation 을 코드로 구현하는 것은 원하는 결과를 얻기에는 쉽지 않을 것으로 생각되었습니다.\n"])</script><script>self.__next_f.push([1,"21:T25c2,"])</script><script>self.__next_f.push([1,"---\nid: 8\ntitle: 'Model (.gltf, .glb) 객체 구조파악 및 그림자 적용'\ndescription: 'Three.js 환경에 불러온 Model 객체의 주요 구성요소를 파악하고, 속성값을 변경하여 그림자를 만들어 봅니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    'javascript',\n    '3d',\n    '.gltf',\n    '.glb',\n    'model',\n    'traverse',\n    'shadow',\n]\n\ncreatedAt: '2024-01-21 16:00:00'\nmodifiedHistories: []\n---\n\n# Model (.gltf, .glb) 객체 구조파악 및 그림자 적용\n\n3D Tool (Cinema3D, Blender...) 에서 만든 Model 파일은 Three.js 에서 제공하는 `GLTFLoader` 를 사용하여 불러올 수 있습니다.\n\n이렇게 불러온 Model 객체에 원하는 연출을 적용하려면, 불러온 Model 객체의 속성값을 변경하며 설정해주어야 합니다.\n\n\u003cbr /\u003e\n\n예를들어 그림자 효과는 Three.js 환경에 불러온 Model 객체의 `castShadow` 또는 `receiveShadow` 를 `true` 로 설정해주어야 적용됩니다.\n\n뿐만아니라 렌더링 된 Model 의 Material 을 수정한다거나 하는 작업들을 통해서 **빛에 대한 Model 의 양감** 을 변경할 수도 있습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 예시코드\n\n\u003e [Model 다운로드 링크](https://polyhaven.com/a/coast_rocks_05)\n\n이번 포스팅의 예시코드는 위 모델을 렌더링한 시점입니다.\n\n```js title=\"예시코드\" showLineNumbers {63-64, 82-84, 92-98}\n// three.js\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n\n    Color,\n    DirectionalLight,\n} from 'three';\nimport {\n    OrbitControls,\n} from 'three/examples/jsm/controls/OrbitControls';\nimport {\n    GLTFLoader,\n} from 'three/examples/jsm/loaders/GLTFLoader';\n// style\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { OrbitControls } */\nlet controls;\n\n//\n// core\n//\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n    $canvas.width = window.innerWidth;\n    $canvas.height = window.innerHeight;\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.shadowMap.enabled = true;\n}\n\nfunction initScene() {\n    scene = new Scene();\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n    camera.fov = 35;\n    camera.aspect = window.innerWidth / window.innerHeight;\n\n    camera.position.set(-3, 3, 3);\n    camera.lookAt(0, 0, 0);\n\n    camera.updateProjectionMatrix();\n}\n\nfunction initControls($target) {\n    controls = new OrbitControls(camera, $target);\n    controls.enableDamping = true;\n}\n\n//\n// light\n//\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n    const light = new DirectionalLight(color, 0.75);\n\n    light.position.set(10, 10, 10);\n    light.castShadow = true;\n    light.shadow.mapSize.width = 2048;\n    light.shadow.mapSize.height = 2048;\n\n    scene.add(light);\n}\n\n//\n// mesh\n//\nfunction initCoastRocksMesh() {\n    const loader = new GLTFLoader();\n\n    loader.load('/gltf/coast-rocks-05/coast_rocks_05_4k.gltf', gltf =\u003e {\n        scene.add(gltf.scene);\n    });\n}\n\n//\n// executor\n//\nfunction render() {\n    window.requestAnimationFrame(render);\n\n    renderer.render(scene, camera);\n    controls.update();\n}\n\n(function init() {\n    const $canvas = initCanvas();\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n    initControls($canvas);\n\n    initDirectionalLight();\n\n    initCoastRocksMesh();\n\n    render();\n}());\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-21-01/2024-01-21-01-01.png\" alt=\"예시코드 결과\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## Model 객체 구성요소\n\n`GLTFLoader` 를 사용하여 불러온 Model 은 3D Tool 로 개발한 Model 의 정보를 포함하고 있습니다.\n\n3D Tool 에서 parent 와 children 구조를 사용하여 Model 을 만들었다면, Three.js 에서 불러온 Model 객체 역시 동일한 구조를 가지게 됩니다.\n\n그리고 Three.js 에서 활용하기 위한 추가적인 정보와 메소드 등을 가지고 있습니다.\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-21-01/2024-01-21-01-02.png\" alt=\"Model 객체\" /\u003e\n\n\u003cbr /\u003e\n\n* `animations`: 3D Tool 에서 만든 Animation 객체\n* `scene`: Model 의 Mesh 객체\n\n\u003cbr /\u003e\n\n이번 포스팅에서는 **scene** 속성의 일부를 살펴보겠습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## Model 객체의 **scene** 속성\n\nModel 객체의 Scene 속성은 **Group** type 이며, Model 의 최상위 Mesh 역할을 합니다.\n\n우리가 Three.js 에 렌더링할 때 사용했던 속성입니다.\n\n그리고 중첩된 **children** 속성으로 하위 Mesh 를 포함하고 있습니다.\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-21-01/2024-01-21-01-03.png\" alt=\"Model Scene 객체\" /\u003e\n\n\u003cbr /\u003e\n\n**children** 의 구성요소로 사용되는 대표적인 **type** 은 다음과 같습니다.\n\n* **Mesh** 타입: 3D Tool 에서 만든 Mesh 객체만이 이 타입의 인스턴스가 됩니다.\n* **Object3D** 타입: **Mesh 타입이 아닌 모든 객체** 가 이 타입의 인스턴스로 표현됩니다.\n    * 3D Tool 의 **Null Object (group)**\n    * 3D Tool 의 **대칭 생성(Symmetry)**, **부드러운 면 만들기(Subdivision surface)** 등의 유틸 객체\n\n\n\n\u003cbr /\u003e\n\n\n\n## Mesh 타입 객체의 주요 속성\n\n* `name`: 3D Tool 에서 명명한 이름입니다.\n* `isMesh`: `true` 값을 가지며, 이 객체가 **Mesh 타입 객체** 라는 것을 단언할 수 있는 상태값입니다.\n* `type`: 이 객체의 type 명입니다.\n* `material`: `Material` 객체 입니다.\n    * 그림자, 재질 등을 변경할 때 사용하게 될 속성(객체) 입니다.\n* `position`: Three.js 에 렌더링할 좌표값 입니다.\n* `rotation`: Three.js 에서 얼만큼 회전시켜서 렌더링할지 설정값 입니다.\n* `scale`: Three.js 상에서 얼만큼 확대/축소 할지에 대한 설정값 입니다.\n* `castShadow`: 그림자 생성 여부에 대한 설정 입니다.\n* `receiveShadow`: 다른 Mesh 의 그림자에 영향을 받을지에 대한 설정 입니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## `traverse` 메서드\n\nModel 은 복수의 Mesh 객체들로 구성될 수 있습니다.\n\n이는 **children** 속성으로 중첩된 구조를 갖습니다.\n\n만약 그림자 설정을 변경한다면, Model 을 구성하는 모든 Mesh 객체의 그림자 설정값을 변경해주어야 합니다.\n\n\u003cbr /\u003e\n\n3D Tool 에서 만든 Model 이 어떤 구조로 되어있는지 모든 구조를 파악하고 설정을 바꿔주는 것은 매우 어려워 보입니다.\n\n그래서 Model 객체의 **scene** 속성(객체) 는 `traverse()` 메서드를 제공합니다.\n\n\u003cbr /\u003e\n\n`traverse()` 메소드는 Model 을 구성하는 모든 **children** 을 깊은 탐색하는 기능을 수행합니다.\n\n즉, 그림자 설정을 변경한다면, `traverse()` 메소드를 사용하여 모든 하위 Mesh 에 설정을 일괄 변경할 수 있습니다.\n\n\u003cbr /\u003e\n\n탐색 대상이 되는 children 구성요소는 Mesh 타입이 아닐수도 있습니다.\n\n이때 Mesh 객체인지 식별하기 위해 `isMesh` 속성을 사용하게 됩니다.\n\n\u003cbr /\u003e\n\n아래 코드는 `traverse()` 메소드를 사용하여 그림자 설정을 활성화 하고 있습니다.\n\n```js title=\"traverse() 를 사용한 그림자 설정\" showLineNumbers{92} {5-12}\nfunction initCoastRocksMesh() {\n    const loader = new GLTFLoader();\n\n    loader.load('/gltf/coast-rocks-05/coast_rocks_05_4k.gltf', gltf =\u003e {\n        gltf.scene.traverse(obj =\u003e {\n            if (!obj.isMesh) {\n                return;\n            }\n\n            obj.castShadow = true;\n            obj.receiveShadow = true;\n        });\n\n        scene.add(gltf.scene);\n    });\n}\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-21-01/2024-01-21-01-04.png\" alt=\"traverse() 메소드\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 추가: 빛에 대한 Model 객체의 양감 설정하기\n\n`traverse()` 메소드를 사용하여 Mesh 객체의 **material** 속성을 일괄 변경할 수 있습니다.\n\nMesh 객체는 **material** 속성을 가지고 있으므로, 이를 사용하여 Mesh 의 양감을 변경할 수 있습니다.\n\n\u003cbr /\u003e\n\n양감은 Mesh 의 색상이 뚜렷하게 렌더링되는 경우에 풍부하게 연출됩니다.\n\nmaterial 의 `metalness` 값을 `0` 으로 설정하면, 주변 배경을 반사하는 것이 아닌, Mesh 본연의 색상에서 빛의 반사효과만 렌더링됩니다.\n\n\u003cbr /\u003e\n\n또한 `roughness` 값을 변경하여 빛이 얼마나 뚜렷하게 비춰질지 설정할 수도 있습니다.\n\n```js title=\"빛에 대한 Metal 객체의 양감 설정하기\" showLineNumbers{92} {12-13}\nfunction initCoastRocksMesh() {\n    const loader = new GLTFLoader();\n\n    loader.load('/gltf/coast-rocks-05/coast_rocks_05_4k.gltf', gltf =\u003e {\n        gltf.scene.traverse(obj =\u003e {\n            if (!obj.isMesh) {\n                return;\n            }\n\n            obj.castShadow = true;\n            obj.receiveShadow = true;\n            obj.material.metalness = 0;\n            obj.material.roughness = 0;\n        });\n\n        scene.add(gltf.scene);\n    });\n}\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\nModel 에 그림자 설정을 위한 코드는 `traverse()` 메소드를 사용하면 간단하게 적용할 수 있었습니다.\n\nModel 객체가 어떻게 구성되고, 설정을 변경하는 이유 등을 파악하는 것이 쉽지는 않았습니다.\n\n이번 포스팅에서 정리한 내용은 Three.js 전반에 필요한 개념으로 생각되어 성취감이 느껴집니다.\n"])</script><script>self.__next_f.push([1,"22:T2000,"])</script><script>self.__next_f.push([1,"---\nid: 7\ntitle: 모델 파일을 Three.js 에 렌더링하기\ndescription: '.gltf 또는 .glb 확장자인 모델 파일을 Three.js 에 불러오고 렌더링하는 방법을 정리합니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    'javascript',\n    '3d',\n    'hdr',\n    '.gltf',\n    '.glb',\n    'model',\n]\n\ncreatedAt: '2024-01-10 23:50:00'\nmodifiedHistories: []\n---\n\n# 모델 파일을 Three.js 에 렌더링하기\n\n3D 모델 파일의 확장자는 아래와 같습니다.\n\n* .gltf\n    * 3D 모델 파일이며 JSON 형식의 데이터입니다.\n* .glb\n    * 3D 모델 파일이며 Binary 데이터입니다.\n    * **3D 모델을 렌더링하여 사용할 목적이라면, .glb 파일의 용량이 더 적으므로 적합합니다.**\n\n\u003cbr /\u003e\n\n이번 포스팅에서는 3D 모델 파일을 Three.js 에 렌더링하는 방법과 불러온 모델 객체를 수정하는 방법에 대해 정리하고자 합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 용어 정리\n\n### Luminance\n\nLuminance 는 **휘도** 라는 뜻을 가집니다.\n\nThree.js 에서는 **emissive** 가 **빛을 방출하는 정도에 대한 속성** 이지만, 3D Tool 중 Cinema4D 에서는 **Luminance** 로 표기되어 있습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 예시 코드\n\n이번 포스팅에서 사용할 예시 코드는 다음과 같습니다.\n\n```js title=\"예시 코드\" showLineNumbers\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n\n    Color,\n    DirectionalLight,\n    HemisphereLight,\n\n    SphereGeometry,\n    MeshStandardMaterial,\n    Mesh,\n} from 'three';\nimport {\n    OrbitControls,\n} from 'three/examples/jsm/controls/OrbitControls';\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { OrbitControls } */\nlet controls;\n\n//\n// core\n//\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n    $canvas.width = window.innerWidth;\n    $canvas.height = window.innerHeight;\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.shadowMap.enabled = true;\n}\n\nfunction initScene() {\n    scene = new Scene();\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n    camera.fov = 35;\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.position.set(0, 0, 2);\n\n    camera.updateProjectionMatrix();\n}\n\nfunction initControls($emitter) {\n    controls = new OrbitControls(camera, $emitter);\n    controls.enableDamping = true;\n}\n\n//\n// light\n//\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n\n    const light = new DirectionalLight(color);\n    light.position.set(1, 1, 1);\n    light.castShadow = true;\n\n    scene.add(light);\n}\n\nfunction initHemisphereLight() {\n    const skyColor = new Color('#fff');\n    const groundColor = new Color('#000');\n\n    const light = new HemisphereLight(\n        skyColor,\n        groundColor,\n        0.25\n    );\n\n    scene.add(light);\n}\n\n//\n// mesh\n//\nfunction initSphereMesh() {\n    const geometry = new SphereGeometry();\n    const material = new MeshStandardMaterial();\n    const sphere = new Mesh(geometry, material);\n\n    scene.add(sphere);\n}\n\n//\n// executor\n//\nfunction render() {\n    window.requestAnimationFrame(render);\n\n    renderer.render(scene, camera);\n    controls.update();\n}\n\nfunction init() {\n    const $canvas = initCanvas();\n\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n    initControls($canvas);\n\n    initDirectionalLight();\n    initHemisphereLight();\n\n    initSphereMesh();\n\n    render();\n}\n\ninit();\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## GLTFLoader 를 사용하여 3D 모델 파일 불러오기\n\n.glb 또는 .gltf 파일을 불러오기 위해서는 Loader 가 필요합니다.\n\n이 때 사용하는 Loader 는 GLTFLoader 인스턴스 입니다.\n\n아래는 .gltf 파일을 불러온 후, 불러온 모델 객체를 `console.log()` 로 출력하고 있습니다.\n\n```js title=\"GLTFLoader import 하기\" showLineNumbers{17}\nimport {\n    GLTFLoader,\n} from 'three/examples/jsm/loaders/GLTFLoader';\n```\n\n```js title=\"GLTFLoader 로 .gltf 파일 불러오기\" showLineNumbers{112}\nfunction initRubberDuck() {\n    const loader = new GLTFLoader();\n    loader.load('/gltf/rubberDuck/rubber_duck_toy_4k.gltf', gltf =\u003e {\n        console.group('onLoad()');\n        console.log('gltf: ', gltf);\n        console.groupEnd();\n    });\n}\n```\n\n```js title=\"iniRubberDuct 함수 호출\" showLineNumbers{131} {13}\nfunction init() {\n    const $canvas = initCanvas();\n\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n    initControls($canvas);\n\n    initDirectionalLight();\n    initHemisphereLight();\n\n    initSphereMesh();\n    initRubberDuck();\n\n    render();\n}\n```\n\n\u003cbr /\u003e\n\n부라우저 콘솔에서 확인하면, GLTFLoader 가 불러온 3D 모델 객체를 확인할 수 있습니다.\n\n\n\n## 불러온 3D 모델 객체 렌더링하기\n\n불러온 3D 모델 객체에는 **scene 속성** 이 있습니다.\n\n**scene 속성** 을 Mesh 와 동일하게 취급할 수 있습니다.\n\n따라서 기존의 sphere Mesh 를 `scene.add()` 메서드로 추가했던 것과 동일한 방법으로 `scene` 에 추가할 수 있습니다.\n\n```js title=\"3D 모델 객체 렌더링\" showLineNumbers{112} {8-9}\nfunction initRubberDuck() {\n    const loader = new GLTFLoader();\n    loader.load('/gltf/rubberDuck/rubber_duck_toy_4k.gltf', gltf =\u003e {\n        console.group('onLoad()');\n        console.log('gltf: ', gltf);\n        console.groupEnd();\n\n        gltf.scene.position.set(0, -0.15, 0);\n        scene.add(gltf.scene);\n    });\n}\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-10-01/2024-01-10-01-01.png\" alt=\"3D 모델 렌더링\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 추가: 불러온 3D 모델이 깨지는 현상\n\n3D 모델을 Three.js 에 렌더링했을 때, 깨지는 현상이 발생할 수 있습니다.\n\n이는 3D Tool(예: Cinema4D, Blender) 를 사용하여, 모델의 **Material** 을 수정하여 해결할 수 있습니다.\n\n가장 유력한 케이스는 **Material** 설정 중, **Alpha** 설정이 활성화된 경우 입니다.\n\n만약 **Alpha** 설정이 활성화되어 있었다면, 해제 후 export 한 파일을 사용해봅니다.\n\n\u003cbr /\u003e\n\nThree.js 는 브라우저 환경에서 동작하기 때문에 3D Tool 의 무거운 기능들은 지원하지 않습니다.\n\n이러한 현상이 나타난다면, **Material** 을 좀 더 가볍게 하면 해소할 수 있습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 3D 모델 객체 구조 살펴보기\n\nThree.js 에 불러온 3D 모델을 그대로 렌더링했을 때, 원하는 결과를 얻지 못할 가능성이 큽니다.\n\n특히 그림자 설정은 3D 모델을 개발할 때 설정하는 것이 아닌, Three.js 에 렌더링할 객체의 설정이 필요한 경우입니다.\n\n이러한 이유로 Three.js 에 불러온 3D 모델 객체의 주요 속성들을 수정하기 위해, 먼저 속성들을 살펴보겠습니다.\n\n\u003cbr /\u003e\n\nGLTFLoader 로 불러운 3D 모델을 gltf 로 칭하겠습니다.\n\ngltf 객체는 크게 다음과 같은 속성이 있습니다.\n\n* scene\n    * Mesh 처럼 다룰 수 있으며, 렌더링할 때도 사용합니다.\n* animations\n    * 애니메이션 객체 입니다.\n* children\n    * 3D Tool 로 개발할 때 만든 부모-자식 계층 입니다.\n* material\n    * 현재 Mesh 의 Material 설정입니다.\n\n\u003cbr /\u003e\n\ngltf 객체의 scene 과 children 의 중첩구조를 살펴보면 크게 2가지 타입으로 이루어져 있습니다.\n\n* Mesh\n    * 실제 Mesh 객체입니다.\n* Object3D\n    * Mesh 가 아닌 기타 타입입니다.\n    * 3D Tool 의 Symmetry(대칭복사), Subdivision(곡선생성) 등의 기능으로 만든 부분 (엄밀히 Mesh 는 아니기 때문)\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\n3D Mesh 파일(.glTF, .gbl) 을 불러온 상태에서는 빛 반사나 그림자와 같은 효과는 적용되지 않습니다.\n\n다음 포스팅에서는 3D Mesh 불러온 후, Mesh 내부 속성을 변경하는 방법을 알아보겠습니다.\n"])</script><script>self.__next_f.push([1,"23:T3408,"])</script><script>self.__next_f.push([1,"---\nid: 6\ntitle: 배경화면 및 환경조명 설정하기\ndescription: '360도 이미지 확장자인 .hdr 파일을 사용하여 배경화면을 설정하고, 배경화면에 의한 환경조명 설정에 대한 정리입니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    'javascript',\n    '3d',\n    'hdr',\n    'background',\n    '3D 배경화면',\n    '환경조명',\n]\n\ncreatedAt: '2024-01-08 23:50:00'\nmodifiedHistories: []\n---\n\n# 배경화면 및 환경조명 설정하기\n\n지금까지는 배경이 없는 환경에서 물체를 렌더링하였습니다.\n\n3D 환경에서 배경화면을 설정하기 위해 360도 이미지 파일인 **.hdr (Hign Dynamic Range)** 파일을 설정해 보고자 합니다.\n\n\u003cbr /\u003e\n\n추가로 배경화면이 물체에 반사되는 환경조명까지 설정해 보겠습니다.\n\n환경조명을 설정하게 되면, 배경이 스틸에 반사되는 효과를 연출할 수 있습니다.\n\n이를 위해 **Material** 설정 방법에 대해서도 정리합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 예시 코드\n\n이번 포스팅에서 사용할 예시 코드는 다음과 같습니다.\n\n```js title=\"예시 코드\" showLineNumbers\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n\n    Color,\n\n    DirectionalLight,\n    DirectionalLightHelper,\n    HemisphereLight,\n    HemisphereLightHelper,\n\n    Mesh,\n    MeshStandardMaterial,\n\n    SphereGeometry,\n    PlaneGeometry,\n\n    VSMShadowMap,\n} from 'three';\nimport {\n    OrbitControls,\n} from 'three/examples/jsm/controls/OrbitControls';\n\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { OrbitControls } */\nlet controls;\n\n//\n// core\n//\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n    $canvas.width = window.innerWidth;\n    $canvas.height = window.innerHeight;\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.shadowMap.enabled = true;\n    renderer.shadowMap.type = VSMShadowMap;\n}\n\nfunction initScene() {\n    scene = new Scene();\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n    camera.fov = 75;\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.position.set(-3, 3, 5);\n\n    camera.updateProjectionMatrix();\n}\n\nfunction initControls($canvas) {\n    controls = new OrbitControls(camera, $canvas);\n    controls.enableDamping = true;\n}\n\n//\n// light\n//\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n\n    const light = new DirectionalLight(\n        color,\n        0.75\n    );\n    light.position.set(1, 1, 1);\n    light.castShadow = true;\n    light.shadow.blurSamples = 30;\n    light.shadow.radius = 12;\n\n    const helper = new DirectionalLightHelper(light);\n\n    scene.add(light);\n    scene.add(helper);\n}\n\nfunction initHemisphereLight() {\n    const skyColor = new Color('#fff');\n    const groundColor = new Color('#000');\n\n    const light = new HemisphereLight(\n        skyColor,\n        groundColor,\n        0.25\n    );\n\n    const helper = new HemisphereLightHelper(light);\n\n    scene.add(light);\n    scene.add(helper);\n}\n\n//\n// mesh\n//\nfunction initSphereMesh() {\n    const geometry = new SphereGeometry();\n    const material = new MeshStandardMaterial();\n    const sphere = new Mesh(geometry, material);\n    sphere.castShadow = true;\n\n    scene.add(sphere);\n}\n\nfunction initPlaneMesh() {\n    const geometry = new PlaneGeometry(10, 10);\n    const material = new MeshStandardMaterial();\n    const plane = new Mesh(geometry, material);\n    plane.position.set(0, -1, 0);\n    plane.rotation.set(Math.PI / -2, 0, 0);\n    plane.receiveShadow = true;\n\n    scene.add(plane);\n}\n\n//\n// executor\n//\nfunction render() {\n    window.requestAnimationFrame(render);\n\n    controls.update();\n    renderer.render(scene, camera);\n}\n\n(function init() {\n    const $canvas = initCanvas();\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n    initControls($canvas);\n\n    initDirectionalLight();\n    initHemisphereLight();\n\n    initSphereMesh();\n    initPlaneMesh();\n\n    render();\n\n    console.log('init()');\n}());\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## **.hdr** 파일이란?\n\nThree.js 는 3D 환경입니다.\n\n배경화면을 설정하려면 일반적인 2D 이미지를 사용해서는 연출할 수 없습니다.\n\n**.hdr (High Dynamic Range)** 확장자를 가진 파일은 360도 이미지 파일이며, 이 파일을 사용하여 3D 환경에 배경화면을 설정할 수 있습니다.\n\n\u003cbr /\u003e\n\n360도 배경화면은 아래의 플렛폼에서 오픈소스로 다운로드할 수 있습니다.\n\n* [polyhaven.com](https://polyhaven.com/hdris)\n\n\n\n\u003cbr /\u003e\n\n\n\n## 용어 정리\n\n이번 포스팅에서 사용하게될 컴퓨터 그래픽스 용어에 대해 간단하게 정리하고 가겠습니다.\n\n### Vertex\n\n3D 공간에서 가장 작은 단위인 **점** 을 말합니다.\n\n### Edge\n\n2개의 Vertex 를 연결하여 생성된 **선** 을 말합니다.\n\n### Polygon\n\n복수의 Edge 를 연결하여 만들어진 **면** 을 말합니다.\n\n가장 작은 Polygon 은 3개의 Edge 로 만들 수 있는 삼각형 입니다.\n\n### Mesh\n\n복수의 Polygon 으로 만들 수 있는 다각형으로, 지금까지 사용해보았던 Sphere, Box, Plane 등을 말합니다.\n\n### Texture\n\n[참고: 나무위키](https://namu.wiki/w/%ED%85%8D%EC%8A%A4%EC%B2%98)\n\n3D 물체의 표면에 2D 이미지를 입혀서 렌더링 하는 방식을 말합니다.\n\nMesh 를 구성하는 Polygon 이 많을수록 성능을 많이 사용하게 되는데, 이를 해소하기 위해 Mesh 의 표면에 2D 이미지를 입히는 방식의 렌더링 요소 입니다.\n\n### emissive\n\nemission 은 **(빛)방사** 라는 뜻을 가집니다.\n\n컴퓨터 그래픽스에서 **emissive** 라는 용어를 사용하는데, 이는 Mesh 가 광원이 되여 빛을 방출한다는 것을 말합니다.\n\n### (영단어) equirectangular\n\n정사각형\n\n### (영단어) reflection\n\n반사\n\n### (영단어) refraction\n\n굴절\n\n\n\n\u003cbr /\u003e\n\n\n\n## RGBELoader 를 사용하여 .hdr 파일을 Texture 로 만들기\n\n3D 공간 자체를 하나의 Mesh 라고 가정해 보겠습니다.\n\nThree.js 에서는 `Scene` 객체가 배경의 역할을 하고 있습니다.\n\n배경화면을 설정하기 위해서는 `Scene` 의 `background` 에 `Texture` 를 입혀서 표현할 수 있습니다.\n\n\u003cbr /\u003e\n\nThree.js 는 다양한 **DataTextureLoader** 를 제공하는데, Loader 를 사용하면 360도 이미지인 `.hdr` 파일을 읽어서 `Texture` 객체로 만들 수 있습니다.\n\n생성한 `Texture` 를 `Scene` 의 `background` 로 입혀주는 것으로 배경화면을 설정할 수 있습니다.\n\n[Three.js 공식문서 - DataTextureLoader](https://threejs.org/docs/#api/en/loaders/DataTextureLoader)\n\n\u003cbr /\u003e\n\n```js title=\"import 하기\" showLineNumbers {21, 27}\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n\n    Color,\n\n    DirectionalLight,\n    DirectionalLightHelper,\n    HemisphereLight,\n    HemisphereLightHelper,\n\n    Mesh,\n    MeshStandardMaterial,\n\n    SphereGeometry,\n    PlaneGeometry,\n\n    VSMShadowMap,\n\n    EquirectangularReflectionMapping,\n} from 'three';\nimport {\n    OrbitControls,\n} from 'three/examples/jsm/controls/OrbitControls';\nimport {\n    RGBELoader,\n} from 'three/examples/jsm/loaders/RGBELoader';\n```\n\n```js title=\"Scene 에 배경화면 설정하기\" showLineNumbers{68} {4-9}\nfunction initScene() {\n    scene = new Scene();\n\n    const loader = new RGBELoader();\n    loader.load('/hrd/background.hdr', texture =\u003e {\n        texture.mapping = EquirectangularReflectionMapping;\n\n        scene.background = texture;\n    });\n}\n```\n\n\u003cbr /\u003e\n\n먼저 import 부분을 살펴보겠습니다.\n\n**EquirectangularReflectionMapping** 은 Texture 의 mapping 방식을 제공하는 **객체** 입니다.\n\nTexture 객체의 `mapping` 속성에 **EquirectangularReflectionMapping** 객체를 대입하는 것으로 mapping 방식을 설정하게 됩니다.\n\n\u003cbr /\u003e\n\nThree.js 에서 제공하는 Texture mapping 방식은 여러가지가 있습니다.\n\n[Three.js 공식문서 - Texture Constants](https://threejs.org/docs/index.html?q=texture#api/en/constants/Textures)\n\n* UVMapping (default)\n* CubeReflectionMapping \n* CubeRefractionMapping\n* EquirectangularReflectionMapping\n* EquirectangularRefractionMapping \n* CubeUVReflectionMapping\n\n\u003cbr /\u003e\n\n위에서 사용한 **EquirectangularReflectionMapping** 은 **environment map** 에 사용하는 Texture mapping 방식 입니다.\n\n이 mapping 방식을 사용하게 되면 `.hdr` 이미지가 마치 배경처럼 렌더링됩니다.\n\n\u003cbr /\u003e\n\nTexture 의 mapping 방식을 설정해준 뒤, **Scene** 의 `background` 속성에 Texture 를 대입하면 배경화면이 렌더링된 것을 볼 수 있습니다.\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-08-01/2024-01-08-01-01.png\" alt=\"배경화면 설정\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 환경조명 설정\n\n빛이 있어야 물체가 렌더링 됩니다.\n\n지금까지는 DirectionalLight 나 HemisphereLight 처럼 조명 객체를 생성하여 빛을 만들었습니다.\n\n이번에는 조명을 모두 제거하고, 환경조명으로 렌더링하고자 합니다.\n\n\u003cbr /\u003e\n\n**Scene** 의 `environment` 속성에 환경조명으로 사용할 Texture 를 대입하여 설정할 수 있습니다.\n\n`background` 로 사용했던 Texture 를 환경조명으로도 사용하도록 해보겠습니다.\n\n```js title=\"환경조명 설정하기\" showLineNumbers{68} {9}\nfunction initScene() {\n    scene = new Scene();\n\n    const loader = new RGBELoader();\n    loader.load('/hdr/background.hdr', texture =\u003e {\n        texture.mapping = EquirectangularReflectionMapping;\n\n        scene.background = texture;\n        scene.environment = texture;\n    });\n}\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-08-01/2024-01-08-01-02.png\" alt=\"환경조명 설정하기\" /\u003e\n\n\u003cbr /\u003e\n\n환경조명으로 설정한 Texture 의 밝은 부분과 어두운 부분이 조명의 세기로 적용되어 배경화면과 자연스러운 연출이 됩니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 배경화면을 반사하는 Mesh 만들기\n\nSphere 와 Plane Mesh 를 렌더링하고 있습니다.\n\n현재는 각 Mesh 에 설정한 **MeshStandardMaterial** 색상 그대로 렌더링되는 상태입니다.\n\n이번에는 Mesh 의 Material 에 설정을 추가하여, 배경화면이 Mesh 에 비추어지는 효과를 연출해 보겠습니다.\n\n\u003cbr /\u003e\n\nMesh 의 외관은 Material 에 의해 렌더링 결과가 달라집니다.\n\nMaterial 은 Mesh 의 색상이나 질감을 표현하는 객체입니다.\n\n배경화면을 반사하는 Mesh 를 만들기 위해서는 Material 설정을 사용하여 구현할 수 있습니다.\n\n```js title=\"배경화면을 반사하는 Mesh 설정하기\" showLineNumbers{134} {3-8}\nfunction initSphereMesh() {\n    const geometry = new SphereGeometry();\n    const material = new MeshStandardMaterial({\n        color: new Color('#fff'),\n        roughness: 0,\n        metalness: 1,\n        // emissive: Color('#000'),\n    });\n    const sphere = new Mesh(geometry, material);\n    sphere.castShadow = true;\n\n    scene.add(sphere);\n}\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-08-01/2024-01-08-01-03.png\" alt=\"Material 설정\" /\u003e\n\n\u003cbr /\u003e\n\n**MeshStandardMaterial** 생성자 params 를 사용하여 Material 를 설정하고 있습니다.\n\nparams 의 각 속성은 다음고 같은 설정을 가집니다.\n\n* `color`: \n    * Material 자체의 색상입니다. (Mesh 의 색상이 됩니다.)\n* `roughness`: \n    * 배경화면을 반사하는 Mesh 의 질감을 얼만큼 거칠게 표현할지에 대한 설정입니다.\n    * `0` 설정 시, 배경화면이 깔끔하게 반사됩니다.\n    * `1` 설정 시, 반사되는 배경화면이 분간하기 어려울 정도로 어글어져서 렌더링됩니다.\n* `metalness`:\n    * 매탈 재질처럼 보이는 정도를 설정합니다.\n    * `0` 설정 시, 메탈 느낌 보다는 플라스틱 느낌이 강하며, 함께 설정한 `color` 의 비중이 더 크게 렌더링됩니다.\n    * `1` 설정 시, 함께 설정한 `color` 는 거의 보이지 않고, 메탈 느낌으로 렌더링됩니다.\n* `emissive`:\n    * Mesh(Material) 이 방출하는 빛의 색상을 설정합니다.\n    * `밝은색` 설정 시, 광원처럼 밝은 빛을 내며, 자신의 그림자가 거의 생기지 않습니다.\n    * `어두운색` 설정 시, 발광하는 빛이 거의 없으며, 자신의 그림자가 비교적 선명하게 생깁니다.\n    * 일반적으로 활용도가 떨어지는 설정이라서, 잘 사용하지 않습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\nMaterial 설정을 통해 배경화면을 반사하는 효과를 연출해 보았습니다.\n\n이번에 사용한 반사효과는 배경화면만을 반사하고, Mesh 간의 반사는 렌더링되지 않습니다.\n\n**Post Processing** 기능을 사용하면, 거울처럼 다른 Mesh 와 상호작용하며 반사하는 연출이 가능해집니다.\n\n이 부분은 차후 정리할 예정입니다.\n\n[Three.js 공식문서 - 거울효과 예시](https://threejs.org/examples/?q=mirror#webgl_mirror)\n"])</script><script>self.__next_f.push([1,"24:T2c06,"])</script><script>self.__next_f.push([1,"---\nid: 5\ntitle: 그림자 표현하기\ndescription: '그림자 설정방법과 특징에 대해 정리합니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    'javascript',\n    '3d',\n    'shadow',\n]\n\ncreatedAt: '2024-01-07 23:50:00'\nmodifiedHistories: []\n---\n\n# 그림자 표현하기\n\n그림자를 표현하기 위해서는 물체와 조명의 각도, 그림자의 크기, 형태 등의 상호작용 연산이 필요합니다.\n\n그래서 Three.js 의 그림자 설정의 기본값은 모두 미사용으로 설정되어 있습니다.\n\n이 덕분에 개발자가 원하는 조명과 원하는 물체의 그림자를 직접 지정하여 표현할 수 있습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 예시 코드\n\n이전 포스팅에서 바닥(땅) 을 만들었던 코드에 그림자 설정을 추가해 보겠습니다.\n\n```js title=\"예시 코드\" showLineNumbers\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n\n    Mesh,\n    MeshStandardMaterial,\n    SphereGeometry,\n    PlaneGeometry,\n\n    Color,\n    HemisphereLight,\n    HemisphereLightHelper,\n    DirectionalLight,\n    DirectionalLightHelper,\n} from 'three';\nimport {\n    OrbitControls,\n} from 'three/examples/jsm/controls/OrbitControls';\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { OrbitControls } */\nlet controls;\n\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n    $canvas.width = window.innerWidth;\n    $canvas.height = window.innerHeight;\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\nfunction initScene() {\n    scene = new Scene();\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n    camera.fov = 35;\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.position.set(0, 0, 12);\n\n    camera.updateProjectionMatrix();\n}\n\nfunction initControls($canvas) {\n    controls = new OrbitControls(camera, $canvas);\n    controls.enableDamping = true;\n}\n\nfunction initHemisphereLight() {\n    const skyColor = new Color('#fff');\n    const groundColor = new Color('#000');\n    const light = new HemisphereLight(\n        skyColor,\n        groundColor,\n        0.75\n    );\n\n    const helper = new HemisphereLightHelper(light);\n\n    scene.add(light);\n    scene.add(helper);\n}\n\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n    const light = new DirectionalLight(color);\n    light.position.set(2, 2, 2);\n\n    const helper = new DirectionalLightHelper(light);\n\n    scene.add(light);\n    scene.add(helper);\n}\n\nfunction initSphereMesh() {\n    const geometry = new SphereGeometry();\n    const material = new MeshStandardMaterial();\n    const sphere = new Mesh(geometry, material);\n\n    scene.add(sphere);\n}\n\nfunction initPlaneMesh() {\n    const geometry = new PlaneGeometry(10, 10);\n    const material = new MeshStandardMaterial();\n    const plane = new Mesh(geometry, material);\n    plane.position.set(0, -1, 0);\n    plane.rotation.set(\n        Math.PI * -0.5,\n        0,\n        0\n    );\n\n    scene.add(plane);\n}\n\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n}\n\nfunction render() {\n    window.requestAnimationFrame(render);\n\n    renderer.render(scene, camera);\n    controls.update();\n}\n\n(function init() {\n    const $canvas = initCanvas();\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n    initControls($canvas);\n\n    initHemisphereLight();\n    initDirectionalLight();\n\n    initSphereMesh();\n    initPlaneMesh();\n\n    render();\n}());\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 그림자 종류\n\nThree.js 에서 제공하는 그림자는 크게 2가지로 볼 수 있습니다.\n\n* Hard Shadow: 선명하며 거친 그림자를 표현합니다.\n* Soft Shadow: 부드러운 그림자를 표현합니다.\n\n\u003cbr /\u003e\n\nSoft Shadow 는 그림자에 Blur 를 적용하여 부드럽게 표현합니다.\n\n주의할 점은 Blur 값을 크게 설정할수록 부드럽게 표현하지만, 사용자 PC 의 연산량이 커진다는 것 입니다.\n\n\u003cbr /\u003e\n\nThree.js 의 그림자 설정은 다음과 같은 과정으로 만들 수 있습니다.\n\n1. Hard Shadow 설정하기\n2. Soft Shadow 설정 추가하기\n\n\n\n\u003cbr /\u003e\n\n\n\n## 그림자 설정이 필요한 인스턴스들\n\n그림자를 표현하려면 몇가지 설정을 함께 해주어야 합니다.\n\n아래는 그림자 설정이 필요한 인스턴스들 입니다.\n\n* WebGLRenderer 인스턴스\n* Light 인스턴스\n* Mesh 인스턴스\n\n\n\n\u003cbr /\u003e\n\n\n\n## WebGLRenderer 에 shadow 설정하기\n\nWebGLRenderer 는 **ShadowMap** 이라는 메커니즘을 제공합니다.\n\n지금은 컴퓨터 그래픽스에서 그림자를 표현하는 여러 알고리즘 중 한가지 라는 것 정도로 정리하고자 합니다.\n\n* WebGLRenderer shadowMap 은 그림자를 이미지로 생성한 후, 그림자를 씌우는 방식으로 동작합니다.\n\n\u003cbr /\u003e\n\n아래 코드는 WebGLRenderer 가 그림자를 표현하도록 설정합니다.\n\n```js title=\"WebGLRenderer 그림자 사용 설정\" showLineNumbers{111} {7}\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.shadowMap.enabled = true;\n}\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## Light 와 Mesh 의 그림자 설정 (Hard Shadow)\n\nLight 와 Mesh 의 그림자 설정 속성은 동일한 인터페이스를 가집니다.\n\n그림자 설정 속성은 크게 두가지가 있습니다.\n\n* 그림자를 만들어내는 설정: `castShadow`\n* 다른 Mesh 의 그림자를 받는 설정: `receiveShadow`\n\n\u003cbr /\u003e\n\nLight 가 비추는 빛은 다른 Mesh 에 의해 그림자를 생성하게 됩니다.\n\n그러므로 Light 의 **castShadow** 를 `true` 로 설정해줍니다.\n\n```js title=\"DirectionalLight shadow 설정\" showLineNumbers{78} {5}\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n    const light = new DirectionalLight(color);\n    light.position.set(2, 2, 2);\n    light.castShadow = true;\n\n    const helper = new DirectionalLightHelper(light);\n\n    scene.add(light);\n    scene.add(helper);\n}\n```\n\n\u003cbr /\u003e\n\n빛에 의해 그림자를 만들어내는 Mesh 역시 그림자를 생성하므로, **caseShadow** 를 `true` 로 설정해줍니다.\n\n```js title=\"Sphere Mesh shadow 설정\" showLineNumbers{90} {5}\nfunction initSphereMesh() {\n    const geometry = new SphereGeometry();\n    const material = new MeshStandardMaterial();\n    const sphere = new Mesh(geometry, material);\n    sphere.castShadow = true;\n\n    scene.add(sphere);\n}\n```\n\n\u003cbr /\u003e\n\n바닥(땅) 을 표현한 Plane Mesh 는 다른 Mesh 의 그림자를 받게 되므로, **receiveShadow** 를 `true` 로 설정해줍니다.\n\n```js title=\"Plane Mesh shadow 설정\" showLineNumbers{99} {12}\nfunction initPlaneMesh() {\n    const geometry = new PlaneGeometry(10, 10);\n    const material = new MeshStandardMaterial();\n    const plane = new Mesh(geometry, material);\n    plane.position.set(0, -1, 0);\n    plane.rotation.set(\n        Math.PI * -0.5,\n        0,\n        0\n    );\n\n    plane.receiveShadow = true;\n\n    scene.add(plane);\n}\n```\n\n\u003cbr /\u003e\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-07-02/2024-01-07-02-01.png\" alt=\"Hard Shadow\" /\u003e\n\n\u003cbr /\u003e\n\n지금까지 설정하여 만들어낸 그림자는 **Hard Shadow** 입니다.\n\nBlur 처리를 하지 않기 때문에 선명한 그림자가 그려지고, 곡선에서 픽셀이 보이는 특징이 있습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## Soft Shadow 설정 추가하기\n\nHard Shadow 설정을 한 후, WebGLRenderer 의 `shadowMap.type` 을 `VSMShadowMap` 으로 설정하므로써 Soft Shadow 로 표현됩니다.\n\n```js title=\"VSMShadowMap import 하기\" showLineNumbers {16}\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n\n    Mesh,\n    MeshStandardMaterial,\n    SphereGeometry,\n    PlaneGeometry,\n\n    Color,\n    HemisphereLight,\n    HemisphereLightHelper,\n    DirectionalLight,\n    DirectionalLightHelper,\n    VSMShadowMap,\n} from 'three';\n```\n\n```js title=\"Soft Shadow\" showLineNumbers{116} {8}\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.shadowMap.enabled = true;\n    renderer.shadowMap.type = VSMShadowMap;\n}\n```\n\n\u003cbr /\u003e\n\n위 코드에서 사용한 `VSMShadowMap` 이외에도 다른 종류의 shadowMap 을 사용할 수도 있습니다. (이번 포스팅에서는 `VSMShadowMap` 을 사용합니다.)\n\n[Three.js 공식 문서 - WebGLRenderer.shadowMap](https://threejs.org/docs/index.html?q=webglRenderer#api/en/renderers/WebGLRenderer.shadowMap)\n\n* BasicShadowMap\n* PCFShadowMap (default)\n* PCFSoftShadowMap\n* VSMShadowMap\n\n\u003cbr /\u003e\n\n위 설정을 추가한 후, 결과를 확인하면 Hard Shadow 와 다른점이 없어 보입니다.\n\n이는 그림자를 생성하는 Light 의 **Blur 정도** 와 **번지는 영역의 Radius** 를 변경하면서 부드러움이 달라지는 것을 확인할 수 있습니다.\n\n```js title=\"DirectionalLight 의 Blur 와 Radius 설정\" showLineNumbers{79} {6-7}\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n    const light = new DirectionalLight(color);\n    light.position.set(2, 2, 2);\n    light.castShadow = true;\n    light.shadow.blurSamples = 30;\n    light.shadow.radius = 12;\n\n    const helper = new DirectionalLightHelper(light);\n\n    scene.add(light);\n    scene.add(helper);\n}\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-07-02/2024-01-07-02-02.png\" alt=\"Soft Shadow\" /\u003e\n\n\u003cbr /\u003e\n\nLight 의 shadow 설정 시, 주의할 사항은 다음과 같습니다.\n\n* `shadow.blurSamples`: 값이 커질수록 부드러운 그림자를 표현하지만, 필요 성능이 높아집니다.\n* `shadow.radius`: 값이 너무 작으면 화면이 깨지는 현상이 있으므로, **10 이상** 설정을 권장합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 추가: VSMShadowMap 에 대하여\n\nSoft Shadow 를 표현하기 위해 VSMShadowMaper 을 사용해 보았습니다.\n\nVSMShadowMap 은 곡선에 대한 그림자를 부드럽게 표현할 수 있는 특징을 가졌습니다.\n\n그래서 지금까지 실습했던 Shpere Mesh 의 그림자를 부드럽게 표현할 수 있었습니다.\n\n\u003cbr /\u003e\n\n만약 Sphere Mesh 가 아닌 Box Mesh 에 VSMShadowMap 을 적용한다면, 그림자가 드리우지 않아야 하는 영역까지 침범하는 현상을 볼 수 있습니다.\n\n이는 VSMShadowMap 의 Blur 처리가 되면서 번지는 그림자가 렌더링된 결과 입니다.\n\n\u003cbr /\u003e\n\n화면 구성에 Box Mesh 가 많다면, VSMShadowMap 을 사용했을 때 오히려 지저분한 그림자가 만들어질 수 있다는 점을 고려하여 선택해야 합니다.\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-07-02/2024-01-07-02-03.png\" alt=\"VSMShadow 단점\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\n그림자는 조명과 물제의 상호연산을 사용하기 때문에 연산량이 많이 필요하다고 합니다.\n\n그래서 그림자를 최소한으로 사용할 수 있도록 여러가지 설정을 분리시켜놓은 느낌이 들었습니다.\n\nThree.js 를 활용할 때, 그림자 설정이 성능 최적화 대상이라는 것을 알게 되었습니다.\n"])</script><script>self.__next_f.push([1,"25:T1a79,"])</script><script>self.__next_f.push([1,"---\nid: 4\ntitle: 평평한 바닥(땅) 만들기 (Plane Mesh)\ndescription: '바닥을 표현하기 위해 Plane Mesh 를 생성합니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    'javascript',\n    '3d',\n    'plane',\n]\n\ncreatedAt: '2024-01-07 23:20:00'\nmodifiedHistories: []\n---\n\n# 평평한 바닥(땅) 만들기 (Plane Mesh)\n\n이번 포스팅에서는 바닥(땅) 을 만들어 보겠습니다.\n\nThree.js 에서는 바닥(땅) 을 **Plane Mesh** 로 만들 수 있습니다.\n\n다음 포스팅에서 다룰 그림자를 표현하려면, 바닥(땅) 이 있어야 하므로 별도의 포스팅으로 분리하게 되었습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 예시 코드\n\n이번 포스팅에서 사용할 예시 코드는 다음과 같습니다.\n\n```js title=\"예시 코드\" showLineNumbers {96}\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n\n    Mesh,\n    MeshStandardMaterial,\n    SphereGeometry,\n\n    Color,\n    HemisphereLight,\n    HemisphereLightHelper,\n    DirectionalLight,\n    DirectionalLightHelper,\n} from 'three';\nimport {\n    OrbitControls,\n} from 'three/examples/jsm/controls/OrbitControls';\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { OrbitControls } */\nlet controls;\n\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n    $canvas.width = window.innerWidth;\n    $canvas.height = window.innerHeight;\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\nfunction initScene() {\n    scene = new Scene();\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n    camera.fov = 35;\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.position.set(0, 0, 12);\n\n    camera.updateProjectionMatrix();\n}\n\nfunction initControls($canvas) {\n    controls = new OrbitControls(camera, $canvas);\n    controls.enableDamping = true;\n}\n\nfunction initHemisphereLight() {\n    const skyColor = new Color('#fff');\n    const groundColor = new Color('#000');\n    const light = new HemisphereLight(\n        skyColor,\n        groundColor,\n        0.75\n    );\n\n    const helper = new HemisphereLightHelper(light);\n\n    scene.add(light);\n    scene.add(helper);\n}\n\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n    const light = new DirectionalLight(color);\n    light.position.set(2, 2, 2);\n\n    const helper = new DirectionalLightHelper(light);\n\n    scene.add(light);\n    scene.add(helper);\n}\n\nfunction initSphereMesh() {\n    const geometry = new SphereGeometry();\n    const material = new MeshStandardMaterial();\n    const sphere = new Mesh(geometry, material);\n\n    scene.add(sphere);\n}\n\n// 여기에 Plane Mesh(바닥) 을 생성하는 함수를 구현할 예정입니다.\n\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n}\n\nfunction render() {\n    window.requestAnimationFrame(render);\n\n    renderer.render(scene, camera);\n    controls.update();\n}\n\n(function init() {\n    const $canvas = initCanvas();\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n    initControls($canvas);\n\n    initHemisphereLight();\n    initDirectionalLight();\n\n    initSphereMesh();\n\n    render();\n}());\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## Plane Mesh 생성 함수 만들기\n\nPlane Mesh 는 **PlaneGeometry** class 를 사용하여 생성할 수 있습니다.\n\n```js title=\"PlaneGeometry class import 하기\" showLineNumbers {9}\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n\n    Mesh,\n    MeshStandardMaterial,\n    SphereGeometry,\n    PlaneGeometry,\n\n    Color,\n    HemisphereLight,\n    HemisphereLightHelper,\n    DirectionalLight,\n    DirectionalLightHelper,\n} from 'three';\n```\n\n```js title=\"initPlaneMesh() 함수 구현하기\" showLineNumbers{97}\nfunction initPlaneMesh() {\n    const geometry = new PlaneGeometry();\n    const material = new MeshStandardMaterial();\n    const plane = new Mesh(geometry, material);\n    plane.position.set(0, -1, 0);\n\n    scene.add(plane);\n}\n```\n\n```js title=\"initPlaneMesh 함수 호출하기\" showLineNumbers{120} {12}\n(function init() {\n    const $canvas = initCanvas();\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n    initControls($canvas);\n\n    initHemisphereLight();\n    initDirectionalLight();\n\n    initSphereMesh();\n    initPlaneMesh();\n\n    render();\n}());\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-07-01/2024-01-07-01-01.png\" alt=\"PlaneMesh\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## Plane Mesh 회전 및 크기 변경하기\n\n위 코드를 실행하면, Sphere 하부에 사각형 물체가 렌더링됩니다.\n\n**width**, **height**, **rotation** 을 변경하여 바닥(땅) 처럼 보이도록 설정해 보겠습니다.\n\n```js title=\"initPlaneMesh() 함수 구현하기\" showLineNumbers{97} {2, 6-10}\nfunction initPlaneMesh() {\n    const geometry = new PlaneGeometry(5, 5);\n    const material = new MeshStandardMaterial();\n    const plane = new Mesh(geometry, material);\n    plane.position.set(0, -1, 0);\n    plane.rotation.set(\n        Math.PI * -0.5, \n        0, \n        0\n    );\n\n    scene.add(plane);\n}\n```\n\n\u003cbr /\u003e\n\nPlaneGeometry class 는 생성자에 **width** 와 **height** 를 넘겨주어 크기를 설정할 수 있습니다.\n\n```js title=\"width, height 설정\" showLineNumbers{98}\nconst geometry = new PlaneGeometry(5, 5);\n```\n\n\u003cbr /\u003e\n\n그리고 Plane Mesh 인스턴스의 `rotation.set()` 메소드를 사용하여 회전시킬 수 있습니다.\n\n회전시킬 값은 **Radian** 으로 넘겨주어야 하므로, **Math.PI** 를 사용합니다.\n\n```js title=\"회전 시키기\" showLineNumbers{102} {2}\nplane.rotation.set(\n    Math.PI * -0.5, \n    0, \n    0\n);\n```\n\n위 코드에서 X축 회전으로 `Math.PI * -0.5` 를 주었는데, 이는 아래와 같은 Plane Mesh 의 특성으로 고려한 것입니다.\n\n* Plane Mesh 는 한쪽면만 렌더링되는 단면 물체 입니다.\n* 렌더링되지 않는 반대쪽 면에는 그림자가 드리우지 않습니다.\n\n\u003cbr /\u003e\n\n이렇게 실행한 결과는 다음과 같습니다.\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-07-01/2024-01-07-01-02.png\" alt=\"PlaneMesh 설정\" /\u003e\n\n\u003cbr /\u003e\n\n카메라를 회전시켜서 Plane Mesh 의 반대쪽 면을 보면, 렌더링되지 않은 결과를 볼 수 있습니다.\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-07-01/2024-01-07-01-03.png\" alt=\"PlaneMesh 반대면\" /\u003e\n\n\n\n## 마치며\n\nPlane Mesh 를 생성하여 바닥(땅) 을 만들 수 있게 되었습니다.\n\n다음 포스팅에서는 바닥(땅) 에 그림자를 표현하여, 조명과 물체의 자연스러운 연출 방법을 정리해 보겠습니다.\n"])</script><script>self.__next_f.push([1,"26:T2eef,"])</script><script>self.__next_f.push([1,"---\nid: 3\ntitle: 조명 종류와 설정\ndescription: '조명 종류와 설정 방법에 대해 정리합니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    'javascript',\n    '3d',\n    'light',\n]\n\ncreatedAt: '2024-01-06 23:00:00'\nmodifiedHistories: []\n---\n\n# 조명 종류와 설정\n\nThree.js 는 조명이 없으면 검은 화면만 보이게 됩니다.\n\n이번 포스팅에서는 조명의 종류와 특징, 설정 방법에 대해 정리하고자 합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 조명 종류\n\n조명의 종류는 다음과 같습니다.\n\n* DirectionalLight\n* PointLight\n* AmbientLight\n* HemisphereLight\n\n그리고 개발환경에서 조명의 광원 위치를 파악하기 쉽게 도와주는 **Helper class** 가 있습니다.\n\n자세한 사항은 각 조명과 함께 정리하겠습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 예시 코드\n\n이번 포스팅에서 사용할 예시 코드는 다음과 같습니다.\n\n```js title=\"예시 코드\" showLineNumbers {94}\nimport {\n    WebGLRenderer,\n    Scene,\n    PerspectiveCamera,\n\n    SphereGeometry,\n    MeshStandardMaterial,\n    Mesh,\n\n    Color,\n\n    DirectionalLight,\n    DirectionalLightHelper,\n} from 'three';\nimport './style.css';\nimport {\n    OrbitControls,\n} from 'three/examples/jsm/controls/OrbitControls';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { OrbitControls } */\nlet controls;\n\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n    $canvas.width = window.innerWidth;\n    $canvas.height = window.innerHeight;\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n}\n\nfunction initScene() {\n    scene = new Scene();\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n    camera.fov = 35;\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.position.set(0, 0, 10);\n\n    camera.updateProjectionMatrix();\n}\n\nfunction initControls($canvas) {\n    controls = new OrbitControls(camera, $canvas);\n    controls.enableDamping = true;\n}\n\nfunction createSphere() {\n    const geometry = new SphereGeometry();\n    const material = new MeshStandardMaterial();\n    const sphere = new Mesh(geometry, material);\n\n    return sphere;\n}\n\nfunction render() {\n    requestAnimationFrame(render);\n\n    renderer.render(scene, camera);\n    controls.update();\n}\n\nfunction init() {\n    const $canvas = initCanvas();\n\n    initRenderer($canvas);\n    initScene();\n    initCamera();\n    initControls($canvas);\n\n    const sphere = createSphere();\n    scene.add(sphere);\n\n    // 여기에서 `조명 설정` 함수를 호출하며 실습할 예정입니다.\n\n    render();\n}\n\ninit();\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## DirectionalLight\n\nDirectionalLight 는 **광원** 에서 **특정 지점(lookAt(좌표))** 로 비추는 **단방향 조명** 입니다.\n\n물체에 비추는 빛의 양은 광원과의 거리와 무관한 빛의 세기(intensity) 설정값이 적용됩니다.\n\n\u003cbr /\u003e\n\n```js title=\"DirectionalLight import 하기\" showLineNumbers\nimport {\n    DirectionalLight,\n} from 'three';\n```\n\n```js title=\"DirectionalLight\" showLineNumbers{83} {9, 14-18}\nfunction init() {\n    initRenderer(initCanvas());\n    initCamera();\n    initScene();\n\n    const sphere = createSphere();\n    scene.add(sphere);\n\n    initDirectionalLight();\n\n    render();\n}\n\nfunction initDirectionalLight() {\n    const light = new DirectionalLight();\n    light.position.set(1, 1, 1);\n    scene.add(light);\n}\n\ninit();\n```\n\n\u003cbr /\u003e\n\nDirectionalLight 생성자에 인자로 **Color 객체** 를 넘겨주어 빛의 색상을 변경할 수 있습니다.\n\n**Color** 는 Three.js 에서 제공하는 class 이며, Three.js 의 색상관련 설정은 **Color 인스턴스** 를 받습니다.\n\n```js title=\"Color import 하기\" showLineNumbers\nimport {\n    Color,\n} from 'three';\n```\n\n```js title=\"DirectionalLight 색상 설정하기\" showLineNumbers{83} {15}\nfunction init() {\n    initRenderer(initCanvas());\n    initCamera();\n    initScene();\n\n    const sphere = createSphere();\n    scene.add(sphere);\n\n    initDirectionalLight();\n\n    render();\n}\n\nfunction initDirectionalLight() {\n    const color = new Color('#f0f400');\n    const light = new DirectionalLight(color);\n    light.position.set(1, 1, 1);\n\n    scene.add(light);\n}\n\ninit();\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-06-01/2024-01-06-01-01.png\" alt=\"DirectionalLight\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n### DirectionalLightHelper\n\nDirectionalLight 의 광원을 표기해주는 기능을 사용해 보겠습니다.\n\nDirectionalLightHelper 인스턴스를 생성한 후, `scene.add()` 를 사용하여 등록해 줍니다.\n\n```js title=\"DirectionalLightHelper import 하기\" showLineNumbers {3}\nimport {\n    DirectionalLight,\n    DirectionalLightHelper,\n} from 'three';\n```\n\n```js title=\"DirectionalLight 색상 설정하기\" showLineNumbers{83} {20-21}\nfunction init() {\n    initRenderer(initCanvas());\n    initCamera();\n    initScene();\n\n    const sphere = createSphere();\n    scene.add(sphere);\n\n    initDirectionalLight();\n\n    render();\n}\n\nfunction initDirectionalLight() {\n    const color = new Color('#f0f400');\n    const light = new DirectionalLight(color);\n    light.position.set(1, 1, 1);\n    scene.add(light);\n\n    const helper = new DirectionalLightHelper(light);\n    scene.add(helper);\n}\n\ninit();\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-06-01/2024-01-06-01-02.png\" alt=\"DirectionalLightHelper\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 빛의 세기(intensity) 설정하기\n\n조명은 빛의 세기(intensity) 가 있습니다.\n\nThree.js 의 모든 조명에도 빛의 세기(intensity) 를 설정할 수 있습니다.\n\n빛의 세기 값은 **0 ~ 1** 값으로 설정합니다.\n\n아래 코드는 DirectionalLight 에 빛의 세기(intensity) 를 0.75 로 설정하고 있습니다.\n\n```js title=\"DirectionalLight 색상 설정하기\" showLineNumbers{83} {18}\nfunction init() {\n    initRenderer(initCanvas());\n    initCamera();\n    initScene();\n\n    const sphere = createSphere();\n    scene.add(sphere);\n\n    initDirectionalLight();\n\n    render();\n}\n\nfunction initDirectionalLight() {\n    const color = new Color('#f0f400');\n    const light = new DirectionalLight(\n        color, \n        0.75\n    );\n    light.position.set(1, 1, 1);\n    scene.add(light);\n\n    const helper = new DirectionalLightHelper(light);\n    scene.add(helper);\n}\n\ninit();\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## PointLight\n\n전등처럼 한 점에서 빛을 방사하는 조명 입니다.\n\n사용방법은 다음과 같습니다.\n\n```js title=\"PointLight import 하기\" showLineNumbers\nimport {\n    PointLight,\n    PointLightHelper,\n} from 'three';\n```\n\n```js title=\"PointLight 색상 설정하기\" showLineNumbers{83} {9, 14-25}\nfunction init() {\n    initRenderer(initCanvas());\n    initCamera();\n    initScene();\n\n    const sphere = createSphere();\n    scene.add(sphere);\n\n    initPointLight();\n\n    render();\n}\n\nfunction initPointLight() {\n    const color = new Color('#f0f400');\n    const light = new PointLight(\n        color,\n        0.75 // 빛의 세기(intensity)\n    );\n    light.position.set(1, 1, 1);\n    scene.add(light);\n\n    const helper = new PointLightHelper(light);\n    scene.add(helper);\n}\n\ninit();\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-06-01/2024-01-06-01-03.png\" alt=\"PointLight\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## AmbientLight\n\nAmbient 는 `주변` 이라는 뜻을 가지고 있습니다.\n\nAmbientLight 는 특정한 광원이 없고, 모든 영역에 동일하게 비추는 조명입니다.\n\n즉 `(x, y, z)` 에 관계없이 동일한 빛을 비춥니다.\n\n\u003cbr /\u003e\n\nAmbientLight 가 적용된 결과를 확인하기 위해, PointLight 와 함께 사용해 보겠습니다.\n\n```js title=\"PointLight import 하기\" showLineNumbers {5}\nimport {\n    PointLight,\n    PointLightHelper,\n\n    AmbientLight,\n} from 'three';\n```\n\n```js title=\"PointLight 색상 설정하기\" showLineNumbers{83} {10, 28-35}\nfunction init() {\n    initRenderer(initCanvas());\n    initCamera();\n    initScene();\n\n    const sphere = createSphere();\n    scene.add(sphere);\n\n    initPointLight();\n    initAmbientLight();\n\n    render();\n}\n\nfunction initPointLight() {\n    const color = new Color('#f0f400');\n    const light = new PointLight(\n        color,\n        0.75 // 빛의 세기(intensity)\n    );\n    light.position.set(1, 1, 1);\n    scene.add(light);\n\n    const helper = new PointLightHelper(light);\n    scene.add(helper);\n}\n\nfunction initAmbientLight() {\n    const color = new Color('#fff');\n    const light = new AmbientLight(\n        color,\n        0.25, // 빛의 세기(intensity)\n    );\n    scene.add(light);\n}\n\ninit();\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-06-01/2024-01-06-01-04.png\" alt=\"AmbientLight\" /\u003e\n\n\u003cbr /\u003e\n\n그리고 AmbientLight 는 모든 영역에 비추는 조명이므로, **Helper class 가 없다는 특징** 이 있습니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## HemisphereLight\n\nHemisphereLight 는 위쪽(skyColor) 와 아래쪽(groundColor) 를 인자로 받고, 그라데이션으로 비추는 조명입니다.\n\n일반적으로 기본 조명으로 사용하는데, 이는 Three.js 특성 때문입니다.\n\n* 조명이 없으면, 물체(Mesh) 는 보이지 않는 검은 화면만 렌더링 됩니다.\n* 다른 조명에 의해 생기는 그림자를 좀 더 자연스럽고 부드럽게 만들어줍니다.\n\n\u003cbr /\u003e\n\n아래 코드는 HemisphereLight 와 DirectionalLight 를 조합한 예시 입니다.\n\n```js title=\"PointLight import 하기\" showLineNumbers {5-6}\nimport {\n    DirectionalLight,\n    DirectionalLightHelper,\n\n    HemisphereLight,\n    HemisphereLightHelper,\n} from 'three';\n```\n\n```js title=\"PointLight 색상 설정하기\" showLineNumbers{83} {10, 28-40}\nfunction init() {\n    initRenderer(initCanvas());\n    initCamera();\n    initScene();\n\n    const sphere = createSphere();\n    scene.add(sphere);\n\n    initDirectionalLight();\n    initHemisphereLight();\n\n    render();\n}\n\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n    const light = new DirectionalLight(\n        color,\n        0.75 // 빛의 세기(intensity)\n    );\n    light.position.set(1, 1, 1);\n    scene.add(light);\n\n    const helper = new PointLightHelper(light);\n    scene.add(helper);\n}\n\nfunction initHemisphereLight() {\n    const skyColor = new Color('#fff');\n    const groundColor = new Color('#000');\n    const light = new HemisphereLight(\n        skyColor,\n        groundColor,\n        0.25, // 빛의 세기(intensity)\n    );\n    scene.add(light);\n\n    const helper = new HemisphereLightHelper(light);\n    scene.add(helper);\n}\n\ninit();\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-06-01/2024-01-06-01-05.png\" alt=\"Hemisphere\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\n일반적으로 DirectionalLight 와 HemisphereLight 를 조합하여 기본 조명을 구성합니다.\n\n각 설정은 다음과 같습니다.\n\n```js title=\"일반적인 조명 설정\" showLineNumbers\nfunction initDirectionalLight() {\n    const color = new Color('#fff');\n    const light = new DirectionalLight(\n        color,\n        0.75 // HemispherLight 보다 0.5 강하게 설정합니다.\n    );\n    scene.add(light);\n}\n\nfunction initHemisphereLight() {\n    const skyColor = new Color('#fff');\n    const groundColor = new Color('#000');\n    const light = new HemisphereLight(\n        skyColor,\n        groundColor,\n        0.25 // DirectionalLight 보다 0.5 약하게 설정합니다.\n    );\n    scene.add(light);\n}\n```\n\n\u003cbr /\u003e\n\nHemisphereLight 를 사용하므로써 그림자 부분이 검은색으로 보이지 않도록 해주며, 좀 더 자연스러운 조명을 연출할 수 있습니다.\n\n그리고 PointLight 는 특정 물체를 강조하거나 효과를 주기위해 주로 사용합니다.\n\n\u003cbr /\u003e\n\nThree.js 는 개발 능력뿐만 아니라 사물을 표현하는 예술 능력도 필요하겠다는 느낌이 듭니다. 😱\n"])</script><script>self.__next_f.push([1,"27:T3ac1,"])</script><script>self.__next_f.push([1,"---\nid: 2\ntitle: 카메라 설정 (PerspectiveCamera)\ndescription: 'Three.js 의 카메라인 PerspectiveCamera 설정에 대한 포스팅입니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    'javascript',\n    '3d',\n    'camera',\n]\n\ncreatedAt: '2024-01-01 23:50:00'\nmodifiedHistories: []\n---\n\n# 카메라 설정 (PerspectiveCamera)\n\nThree.js 가 `\u003ccanvas /\u003e` 에 실제로 렌더링하는 부분은 `카메라 (PerspectiveCamera)` 가 비추는 영역입니다.\n\n이번 포스팅에서는 카메라 설정과 효과, 사용자 인터렉션 적용 방법에 대해 정리해 보겠습니다.\n\n이번 포스팅에서는 아래의 코드를 시작점으로 사용하겠습니다.\n\n```js title=\"샘플 코드\" showLineNumbers\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    Scene,\n    DirectionalLight,\n\n    BoxGeometry,\n    MeshPhongMaterial,\n    Mesh,\n} from 'three';\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { Scene } */\nlet scene;\n\n(function init() {\n    const $canvas = initCanvas();\n\n    initRenderer($canvas);\n\n    const light = createLight();\n    const boxMesh = createBoxMesh();\n\n    initCamera();\n    initScene(light, boxMesh);\n\n    render();\n\n    console.log('시작');\n}());\n\nfunction render() {\n    renderer.render(scene, camera);\n\n    window.requestAnimationFrame(render);\n}\n\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\n/**\n * @param { HTMLCanvasElement } $canvas \n */\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.setSize(\n        window.innerWidth,\n        window.innerHeight\n    );\n}\n\nfunction createLight() {\n    const light = new DirectionalLight();\n    light.position.set(1, 2, 3);\n\n    return light;\n}\n\nfunction createBoxMesh() {\n    const boxGeometry = new BoxGeometry();\n    const boxMaterial = new MeshPhongMaterial();\n\n    return new Mesh(boxGeometry, boxMaterial);\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera(\n        45,\n        window.innerWidth / window.innerHeight\n    );\n\n    camera.position.set(0, 0, 5);\n}\n\nfunction initScene(...items) {\n    scene = new Scene();\n\n    items.forEach(item =\u003e {\n        scene.add(item);\n    });\n}\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## PerspectiveCamera 생성자 params\n\n카메라 생성자 params 를 사용하여 초기 설정을 할 수 있습니다.\n\n```ts title=\"PerspectiveCamera 생성자 함수\" showLineNumbers\nclass PerspectiveCamera {\n    constructor(\n        fov?: number,\n        aspect?: number,\n        near?: number,\n        far?: number\n    );\n}\n```\n\n* fov (Field of View): 시야각 (화각)\n    * fov 설정값이 클수록 먼 거리에서 보는 느낌이 납니다.\n    * fov 설정값이 커질수록 **투시에 따른 왜곡현상** 이 도드라지게 나타납니다.\n* aspect: 카메라 종횡비 (aspect radio)\n    * 카메라의 가로, 세로 비율값 입니다.\n* near: (Near clipping)\n    * 카메라를 기준으로 가까운 물체(Mesh) 에 대한 렌더링 잘라내기 설정값 입니다.\n* far: (Far clipping)\n    * 카메라를 기준으로 먼 물체(Mesh) 에 대한 렌더링 잘라내기 설정값 입니다.\n\n\u003cbr /\u003e\n\n위 설정들은 PerspectiveCamera 생성자를 통해서도 설정할 수 있고, 객체를 생성한 후 설정을 변경할 수도 있습니다.\n\n만약 객체를 생성한 후 설정을 변경한다면, 카메라 메소드인 **updateProjectionMatrix()** 함수를 호출하여야 실제 렌더링에 반영됩니다.\n\n아래 코드는 PerspectiveCamera 객체를 생성한 후, 카메라 설정을 변경하고 있습니다.\n\n```js title=\"카메라 객체 설정값 변경하기\" showLineNumbers {88, 89, 92}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    Scene,\n    DirectionalLight,\n\n    BoxGeometry,\n    MeshPhongMaterial,\n    Mesh,\n} from 'three';\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { Scene } */\nlet scene;\n\n(function init() {\n    const $canvas = initCanvas();\n\n    initRenderer($canvas);\n\n    const light = createLight();\n    const boxMesh = createBoxMesh();\n\n    initCamera();\n    initScene(light, boxMesh);\n\n    render();\n\n    console.log('시작');\n}());\n\nfunction render() {\n    renderer.render(scene, camera);\n\n    window.requestAnimationFrame(render);\n}\n\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\n/**\n * @param { HTMLCanvasElement } $canvas \n */\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.setSize(\n        window.innerWidth,\n        window.innerHeight\n    );\n}\n\nfunction createLight() {\n    const light = new DirectionalLight();\n    light.position.set(1, 2, 3);\n\n    return light;\n}\n\nfunction createBoxMesh() {\n    const boxGeometry = new BoxGeometry();\n    const boxMaterial = new MeshPhongMaterial();\n\n    return new Mesh(boxGeometry, boxMaterial);\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera(\n        // 45,\n        // window.innerWidth / window.innerHeight\n    );\n\n    camera.fov = 45;\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.position.set(0, 0, 3);\n\n    camera.updateProjectionMatrix();\n}\n\nfunction initScene(...items) {\n    scene = new Scene();\n\n    items.forEach(item =\u003e {\n        scene.add(item);\n    });\n}\n```\n\n\u003cbr /\u003e\n\n위 코드의 실행 결과로 BoxMesh 의 단면을 볼 수 있습니다.\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-01-01/2024-01-01-01-01.png\" alt=\"실행 결과\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 카메라의 주시 좌표값 변경하기\n\n현재는 BoxMesh 의 단면만을 비추고 있어서 마치 2D 인것 처럼 보입니다.\n\n카메라의 위치와 카메라의 주시 좌표값을 변경하면, 물체를 다각도에서 다양한 구도로 렌더링할 수 있습니다.\n\n\u003cbr /\u003e\n\n먼저 카메라의 위치를 (1, 1, 2) 로 변경해 보겠습니다.\n\n```js title=\"카메라 position 변경\" showLineNumbers{82} {6}\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n\n    camera.fov = 45;\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.position.set(1, 1, 2);\n\n    camera.updateProjectionMatrix();\n}\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-01-01/2024-01-01-01-02.png\" alt=\"실행 결과\" /\u003e\n\n\u003cbr /\u003e\n\n카메라의 position 만을 변경한 결과, BoxMesh 의 일부분만 렌더링되고 있습니다.\n\n이는 카메라의 주시 좌표값을 설정하지 않아서 카메라 위치에서 정면을 주시하고 있기 때문입니다.\n\n카메라 객체의 `lookAt()` 메소드를 사용하면, 카메라의 위치인 position 에서 특정 좌표를 주시하게 됩니다.\n\nBoxMesh 가 카메라의 중앙에 오도록 하기위해, BoxMesh 의 position 위치값인 (0, 0, 0) 으로 카메라 주시 좌표를 설정해 보겠습니다.\n\n```js title=\"카메라 position 변경\" showLineNumbers{82} {8}\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n\n    camera.fov = 45;\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.position.set(1, 1, 2);\n\n    camera.lookAt(0, 0, 0);\n\n    camera.updateProjectionMatrix();\n}\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-01-01/2024-01-01-01-03.png\" alt=\"실행 결과\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 카메라 fov 와 position 설정에 따른 왜곡 현상\n\nfov(Field of View) 값이 커질수록 멀리서 보는 느낌으로 렌더링됩니다.\n\n이는 물체가 더 작게 보이는 결과를 볼 수 있습니다.\n\n\u003cbr /\u003e\n\n만약 fov 를 큰 값으로 설정하여 물체가 작게 보이도록 한 후, 카메라의 위치를 물체와 가깝게 설정하면 어떻게 될까요?\n\n이는 카메라의 **왜곡 현상** 에 의해 좀 더 렌즈의 굴곡이 커지게 됩니다.\n\nfov 와 position 의 관계를 표현해 보면 다음과 같습니다.\n\n* fov 작게 설정, position 멀리 설정\n    * 왜곡 현상이 적어집니다.\n* fov 크게 설정, position 가깝게 설정\n    * 왜곡 현상이 커집니다.\n\n\u003cbr /\u003e\n\n실제 왜곡 현상의 차이를 확인하기 위해 두가지 설정을 비교해 보겠습니다.\n\n* 첫번째 설정: **fov 작게, position 멀리** 설정\n* 두번째 설정: **fov 크게, position 가깝게** 설정\n\n```js title=\"fov 작게, position 멀리 설정\" showLineNumbers{82} {5-6}\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.fov = 45;\n    camera.position.set(2, 2, 2);\n\n    camera.lookAt(0, 0, 0);\n\n    camera.updateProjectionMatrix();\n}\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-01-01/2024-01-01-01-04.png\" alt=\"실행 결과\" /\u003e\n\n\u003cbr /\u003e\u003cbr /\u003e\n\n```js title=\"fov 크게, position 가깝게 설정\" showLineNumbers{82} {5-6}\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.fov = 90;\n    camera.position.set(1, 1, 1);\n\n    camera.lookAt(0, 0, 0);\n\n    camera.updateProjectionMatrix();\n}\n```\n\n\u003cimg src=\"/markdownAssets/threejs/2024-01-01-01/2024-01-01-01-05.png\" alt=\"실행 결과\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 추가: 마우스를 사용하여 카메라 제어하기\n\nThree.js 는 여러가지 Addons 를 제공합니다.\n\n이 중 **OrbitControls** 객체를 사용하면, 마우스를 사용하여 카메라를 제어하는 기능을 제공할 수 있습니다.\n\n\u003cbr /\u003e\n\nOrbitControls 는 **PerspectiveCamera 의 Addon** 개념으로 사용하게 되며, 카메라의 제어를 담당하게 됩니다.\n\n주의할 점은 PerspectiveCamera 의 `lookAt()` 메소드를 함께 사용하게 되면, 카메라 제어에 충돌이 발생하는 현상입니다.\n\n그러므로 OrbitControls 를 사용하려면, `lookAt()` 메소드는 꼭 제거해 주는 것이 좋습니다.\n\n\u003cbr /\u003e\n\n먼저 OrbitControls 의 생성자를 살펴보면 다음과 같습니다.\n\n```ts\nclass OrbitControls {\n    constructor(\n        object: Camera, \n        domElement?: HTMLElement\n    );\n}\n```\n\n* object: 제어할 카메라 객체\n* domElement: 마우스 이벤트를 발생시킬 HTMLElement\n\n\u003cbr /\u003e\n\nPerspectiveCamera 에 OrbitControls 를 적용하는 `initControls()` 함수를 추가해 보겠습니다.\n\n```js title=\"OrbitControls 로 카메라 제어하기\" showLineNumbers {11-13, 25-26, 37, 45, 103-108}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    Scene,\n    DirectionalLight,\n\n    BoxGeometry,\n    MeshPhongMaterial,\n    Mesh,\n} from 'three';\nimport {\n    OrbitControls,\n} from 'three/examples/jsm/controls/OrbitControls'\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { Scene } */\nlet scene;\n\n/** @type { OrbitControls } */\nlet controls;\n\n(function init() {\n    const $canvas = initCanvas();\n\n    initRenderer($canvas);\n\n    const light = createLight();\n    const boxMesh = createBoxMesh();\n\n    initCamera();\n    initControls($canvas);\n    initScene(light, boxMesh);\n\n    render();\n}());\n\nfunction render() {\n    renderer.render(scene, camera);\n    controls.update();\n\n    window.requestAnimationFrame(render);\n}\n\nfunction initCanvas() {\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    return $canvas;\n}\n\n/**\n * @param { HTMLCanvasElement } $canvas \n */\nfunction initRenderer($canvas) {\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n\n    renderer.setSize(\n        window.innerWidth,\n        window.innerHeight\n    );\n}\n\nfunction createLight() {\n    const light = new DirectionalLight();\n    light.position.set(1, 2, 3);\n\n    return light;\n}\n\nfunction createBoxMesh() {\n    const boxGeometry = new BoxGeometry();\n    const boxMaterial = new MeshPhongMaterial();\n\n    return new Mesh(boxGeometry, boxMaterial);\n}\n\nfunction initCamera() {\n    camera = new PerspectiveCamera();\n\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.fov = 45;\n    camera.position.set(2, 2, 2);\n\n    camera.fov = 90;\n    camera.position.set(1, 1, 1);\n\n    camera.lookAt(0, 0, 0);\n\n    camera.updateProjectionMatrix();\n}\n\n/**\n * @param { HTMLElement } $targetElement \n */\nfunction initControls($targetElement) {\n    controls = new OrbitControls(camera, $targetElement);\n}\n\nfunction initScene(...items) {\n    scene = new Scene();\n\n    items.forEach(item =\u003e {\n        scene.add(item);\n    });\n}\n```\n\n\u003cbr /\u003e\n\nOrbitControls 를 카메라에 설치하게 되면 아래와 같은 마우스 인터렉션을 사용할 수 있습니다.\n\n* 마우스 좌클릭 - 드래그\n    * 카메라 주시 좌표를 회전 중심점으로 하여, **드래그 반대 방향으로 카메라를 회전** 시킵니다.\n    * 결과적으로 카메라가 고정된 상태에서 **바라보는 물체가 회전** 하게 됩니다.\n* 마우스 휠\n    * 확대, 축소 동작을 합니다.\n* 마우스 우클릭 - 드래그\n    * **드래그 반대 방향으로 카메라의 위치를 이동** 시킵니다.\n    * 결과적으로 카메라가 고정된 상태에서 **바라보는 물체가 이동** 하게 됩니다.\n\n\u003cbr /\u003e\n\nOrbitControls 객체의 설정을 사용하여, 특정 마우스 인터렉션의 사용 여부를 설정할 수 있습니다.\n\n이 설정 프로퍼티들은 `enable` 을 접두사로 사용하고 있습니다.\n\n* `enableRotate`: `false` 값을 대입하면, 회전기능을 막습니다.\n* `enableZoom`: `false` 값을 대입하면 확대, 축소 기능을 막습니다.\n* `enablePan`: `false` 값을 대입하면 이동 기능을 막습니다.\n\n\u003cbr /\u003e\n\n추가로 `enableDamping` 에 `true` 값을 대입하게 되면, 카메라의 모든 인터렉션에 감속도가 적용되어 **카메라의 부드러운 움직임이 연출** 됩니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 마치며\n\n일전에 HTML Canvas API 를 스터디하면서, 도형에 대한 인터렉션이나 애니메이션을 구현해본 적이 있습니다.\n\n물체의 튕김이나 가속도, 감속도를 구현해 보려는 시도를 했었지만, 제가 구현한 결과물은 너무나 어색했습니다.\n\nThree.js 의 인터렉션은 OrbitControls 하나를 접했을 뿐인데, 부드러운 3D 엔진에 그저 놀라울 뿐입니다.\n\n\u003cbr /\u003e\n\n하지만 실제 구현할 기획에 따라 엔진의 물리 효과를 커스터마이징을 할 수 있어야 자연스러운 결과물이 나올 것 같습니다.\n\nOrbitControls 가 제공하는 효과는 마치 물속의 부력이 작용하는 것처럼 느껴졌습니다.\n\nThree.js 의 기본 사용법과 원리를 이해한 후, 물리 엔진 커스터마이징에 대해서도 도전해 보고 싶어졌습니다.\n"])</script><script>self.__next_f.push([1,"28:T5077,"])</script><script>self.__next_f.push([1,"---\nid: 1\ntitle: Three.js 설치 및 실행\ndescription: 'Three.js 를 사용하기 위한 설치와 첫번째 화면을 그려봅니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'threejs',\n    'javascript',\n    '3d',\n]\n\ncreatedAt: '2023-12-31 22:47:00'\nmodifiedHistories: []\n---\n\n# Three.js 설치 및 실행\n\n일반적인 웹페이지는 2D 기반으로 구현합니다.\n\n이러한 웹페이지는 서비스를 제공하거나 정보 공유를 목적으로 충분합니다.\n\n만약 이렇게 보편적으로 사용하는 2D 웹페이지에 3D 환경을 더한다면, 서비스나 제품의 브렌딩에 차별점을 줄 수 있을 것 같습니다.\n\n\u003cbr /\u003e\n\nThree.js 를 스터디하며, 이 블로그의 Profile 페이지를 구현하는 것을 첫번째 목표로 하여 포스팅을 해보려 합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## Vite 프로젝트 생성하기\n\nThree.js 를 사용하기 위해, VanillaJS 환경의 프로젝트를 생성해 보겠습니다.\n\nWebpack 을 사용하여 프로젝트를 만들어도 되지만, 프로젝트 구성에 투자되는 리소스가 많아지므로, Vite 를 사용하여 프로젝트를 생성해보겠습니다.\n\n```bash title=\"Vite 프로젝트 생성\"\nyarn create vite --template vanilla my-threejs\n\ncd my-threejs\n\nyarn install\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## Three.js 설치하기\n\n프로젝트를 생성한 후, Three.js 를 설치합니다.\n\n```bash title=\"Three.js 설치\"\nyarn install three\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## Three.js 기본 구조 구성하기\n\nThree.js 는 **WebGL** 을 기반으로 동작합니다.\n\n이는 **HTML Canvas API** 를 사용하여 그리는 방식입니다.\n\nThree.js 로 화면을 그리기 위한 기본 과정을 살펴보면 다음과 같습니다.\n\n1. `\u003ccanvas /\u003e` 태그 생성\n2. **WebGLRenderer** 객체 생성\n3. 카메라 생성\n4. 조명 생성\n5. **Scene** 객체 생성\n6. 위에서 생성한 객체들을 조합하여 **WebGLRenderer** 에 적용\n7. `requestAnimationFrame()` 을 사용하여 `\u003ccanvas /\u003e` 렌더링\n\n\u003cbr /\u003e\n\n위 과정은 아래와 같이 함수를 생성하여 구현해 보겠습니다.\n\n1. `init()` 함수 만들기: 1번 ~ 6번 과정을 처리합니다.\n2. `render()` 함수 만들기: 7번 과정을 처리합니다.\n\n\n\n\u003cbr /\u003e\n\n\n\n## 1. `\u003ccanvas /\u003e` 태그 생성\n\n먼저 Three.js 를 렌더링할 `\u003ccanvas /\u003e` 태그를 생성하는 로직을 구현해 보겠습니다.\n\n```js title=\"main.js\" showLineNumber\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n}\n\ninit();\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 2. **WebGLRenderer** 객체 생성\n\n**WebGLRenderer** 객체는 Three.js 의 코어 역할을 합니다.\n\n위에서 생성한 `\u003ccanvas /\u003e` 를 인자로 넘겨주어 렌더링 대상을 지정해 줍니다.\n\n```js title=\"main.js\" showLineNumbers {2, 5-6, 15-18}\nimport {\n    WebGLRenderer,\n} from 'three';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    // 2. WebGLRenderer 객체 생성\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n    });\n}\n\ninit();\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 3. 카메라 생성\n\nThree.js 가 실제로 화면에 렌더링하는 것은 `Camera` 가 비추는 곳이 됩니다.\n\n따라서 Three.js 에 사용할 카메라 객체를 생성해 줍니다.\n\n```js title=\"main.js\" showLineNumbers {3, 9-10, 24-25}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n} from 'three';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    // 2. `WebGLRenderer` 객체 생성\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n    });\n\n    // 3. 카메라 생성\n    camera = new PerspectiveCamera();\n}\n\ninit();\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 4. 조명 생성\n\n이번에는 조명 객체인 **DirectionalLight** 객체를 생성해 보겠습니다.\n\n현실 세계에서도 빛이 있어야 물체를 볼 수 있듯이, Three.js 에서도 조명이 있어야 물체가 렌더링 됩니다.\n\n조명은 여러가지가 있는데, 이 중 햇빛처럼 직선의 일정한 양의 빛을 나타내는 **DirectionalLight** 객체를 사용해 보겠습니다.\n\n```js title=\"main.js\" showLineNumbers {4, 28-29}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    DirectionalLight,\n} from 'three';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    // 2. `WebGLRenderer` 객체 생성\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n    });\n\n    // 3. 카메라 생성\n    camera = new PerspectiveCamera();\n\n    // 4. 조명 생성\n    const light = new DirectionalLight();\n}\n\ninit();\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 5. **Scene** 객체 생성\n\n무대는 `Scene` 객체로 만들 수 있습니다.\n\n`Scene` 객체는 `add()` 메서드를 사용하여 위에서 만들었던 조명과 물체(Mesh)들을 적용할 수 있습니다.\n\n\u003cbr /\u003e\n\n`Scene` 객체를 생성하고 조명을 적용해 보겠습니다.\n\n```js title=\"main.js\" showLineNumbers {5, 14-15, 35-37}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    DirectionalLight,\n    Scene,\n} from 'three';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { Scene } */\nlet scene;\n\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    // 2. `WebGLRenderer` 객체 생성\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n    });\n\n    // 3. 카메라 생성\n    camera = new PerspectiveCamera();\n\n    // 4. 조명 생성\n    const light = new DirectionalLight();\n\n    // 5. `Scene` 객체 생성\n    scene = new Scene();\n    scene.add(light);\n}\n\ninit();\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용\n\n이제 Three.js 를 실행하여 화면을 그릴 준비가 되었습니다.\n\n**WebGLRenderer** 는 **Scene(무대)** 와 **카메라** 를 사용하여 화면을 그리는 역할을 하게 됩니다.\n\n```js title=\"main.js\" showLineNumbers {39-40}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    DirectionalLight,\n    Scene,\n} from 'three';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { Scene } */\nlet scene;\n\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    // 2. `WebGLRenderer` 객체 생성\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n    });\n\n    // 3. 카메라 생성\n    camera = new PerspectiveCamera();\n\n    // 4. 조명 생성\n    const light = new DirectionalLight();\n\n    // 5. `Scene` 객체 생성\n    scene = new Scene();\n    scene.add(light);\n\n    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용\n    renderer.render(scene, camera);\n}\n\ninit();\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 7. `requestAnimationFrame()` 을 사용하여 `\u003ccanvas /\u003e` 렌더링\n\n이번에는 `init()` 의 마지막에 호출할 `render()` 함수를 만들고, Three.js 를 실행하여 브라우저에서 결과를 확인해 보겠습니다.\n\n추가할 `render()` 함수는 `requestAnimationFrame()` 을 사용하여 `render()` 함수를 재귀 호출하도록 하는데, 이는 브라우저에서 **60fps 로 실행하며 화면을 업데이트** 하게 됩니다.\n\n```js title=\"main.js\" showLineNumbers {42-43, 46-50}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    DirectionalLight,\n    Scene,\n} from 'three';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { Scene } */\nlet scene;\n\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    // 2. `WebGLRenderer` 객체 생성\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n    });\n\n    // 3. 카메라 생성\n    camera = new PerspectiveCamera();\n\n    // 4. 조명 생성\n    const light = new DirectionalLight();\n\n    // 5. `Scene` 객체 생성\n    scene = new Scene();\n    scene.add(light);\n\n    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용\n    renderer.render(scene, camera);\n\n    // 7. requestAnimationFrame() 을 사용하여 \u003ccanvas /\u003e 렌더링\n    render();\n}\n\nfunction render() {\n    renderer.render(scene, camera);\n\n    requestAnimationFrame(render);\n}\n\ninit();\n```\n\n\n\n\u003cbr /\u003e\n\n\n\n## 추가: Scene 에 SphereMesh 추가하기\n\n지금까지 작성한 코드를 실행하면, 검은색 화면만 보이게 됩니다.\n\n이는 실제로 화면에 그릴 물체(Mesh) 가 없기 때문에 그릴 대상이 없는 현상입니다.\n\n\u003cbr /\u003e\n\n위에서 구성한 Three.js 가 잘 동작하는지 테스트를 위해 구형 물체(Sphere Mesh) 를 생성하고, 적용해 보겠습니다.\n\n```js title=\"main.js\" showLineNumbers {7-9, 48-49, 61-67}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    DirectionalLight,\n    Scene,\n\n    SphereGeometry,\n    MeshPhongMaterial,\n    Mesh,\n} from 'three';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { Scene } */\nlet scene;\n\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    // 2. `WebGLRenderer` 객체 생성\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n    });\n\n    // 3. 카메라 생성\n    camera = new PerspectiveCamera();\n    camera.position.set(0, 0, 10);\n\n    // 4. 조명 생성\n    const light = new DirectionalLight();\n    light.position.set(1, 1, 1);\n\n    // 5. `Scene` 객체 생성\n    scene = new Scene();\n    scene.add(light);\n\n    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용\n    renderer.render(scene, camera);\n\n    // 추가: Schene 에 SphereMesh 추가하기\n    createSphereMesh();\n\n    // 7. requestAnimationFrame() 을 사용하여 \u003ccanvas /\u003e 렌더링\n    render();\n}\n\nfunction render() {\n    renderer.render(scene, camera);\n\n    requestAnimationFrame(render);\n}\n\nfunction createSphereMesh() {\n    const sphere_geometry = new SphereGeometry();\n    const sphere_material = new MeshPhongMaterial();\n    const sphere_mesh = new Mesh(sphere_geometry, sphere_material);\n\n    scene.add(sphere_mesh);\n}\n\ninit();\n```\n\n\u003cbr /\u003e\n\n`createSphereMesh()` 함수에서 3가지 객체를 생성하고 있습니다.\n\n이는 컴퓨터 그래픽스에서 3D 물체를 표현하기 위한 요소들 입니다.\n\n* Geometry: 색이 없는 모델링 객체\n* Material: 모델링 객체의 색상 또는 질감\n* Mesh: Geometry 와 Material 을 합친 결과 모델링 객체\n\n`sphere_mesh` 객체의 `add()` 메소드를 사용하여 **Geometry** 와 **Material** 을 합쳐서 하나의 **Mesh** 를 만들 수 있게 됩니다.\n\n\u003cbr /\u003e\n\n지금까지 작성한 코드를 실행하면 다음과 같은 결과물을 볼 수 있습니다.\n\n\u003cimg src=\"/markdownAssets/threejs/2023-12-31-01/2023-12-31-01-01.png\" alt=\"Threejs 실행 결과\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 추가: `\u003ccanvas /\u003e` 를 전체화면으로 설정하기\n\n위 결과물을 확인하면, `\u003ccanvas /\u003e` 요소가 inline 으로 렌더링되고 있습니다.\n\n이는 **WebGLRenderer** 객체의 **size** 를 조정하여 전체화면으로 설정할 수 있습니다.\n\n그리고 `\u003ccanvas /\u003e` 의 기본 스타일인 `display: inline` 을 `display: block` 으로 변경합니다.\n\n```css title=\"style.css\" showLineNumbers\n* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\ncanvas {\n    display: block;\n}\n```\n\n```js title=\"main.js\" showLineNumbers {11, 33-36}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    DirectionalLight,\n    Scene,\n\n    SphereGeometry,\n    MeshPhongMaterial,\n    Mesh,\n} from 'three';\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { Scene } */\nlet scene;\n\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    // 2. `WebGLRenderer` 객체 생성\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n    });\n    renderer.setSize(\n        window.innerWidth,\n        window.innerHeight\n    );\n\n    // 3. 카메라 생성\n    camera = new PerspectiveCamera();\n    camera.position.set(0, 0, 10);\n\n    // 4. 조명 생성\n    const light = new DirectionalLight();\n    light.position.set(1, 1, 1);\n\n    // 5. `Scene` 객체 생성\n    scene = new Scene();\n    scene.add(light);\n\n    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용\n    renderer.render(scene, camera);\n\n    // 추가: Schene 에 SphereMesh 추가하기\n    createSphereMesh();\n\n    // 7. requestAnimationFrame() 을 사용하여 \u003ccanvas /\u003e 렌더링\n    render();\n}\n\nfunction render() {\n    renderer.render(scene, camera);\n\n    requestAnimationFrame(render);\n}\n\nfunction createSphereMesh() {\n    const sphere_geometry = new SphereGeometry();\n    const sphere_material = new MeshPhongMaterial();\n    const sphere_mesh = new Mesh(sphere_geometry, sphere_material);\n\n    scene.add(sphere_mesh);\n}\n\ninit();\n```\n\n\u003cbr /\u003e\n\n이렇게 적용한 결과는 다음과 같습니다.\n\n\u003cimg src=\"/markdownAssets/threejs/2023-12-31-01/2023-12-31-01-02.png\" alt=\"전체화면 적용\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 추가: 찌그러진 화면 보정하기\n\nScene 에 추가한 모델링은 구(Sphere) 입니다.\n\n하지만 결과 화면에서 보여지는 구는 타원형으로 보여집니다.\n\n원인은 아래와 같습니다. \n\n* **카메라의 종횡비(aspect radio)** 설정을 하지 않았으므로, 기본값인 **1** 로 설정됨\n* 브라우저의 종횡비가 1:1 이 아닌 상태에서 `\u003ccanvas /\u003e` 를 전체화면으로 늘리면서 발생하는 화면 늘어짐\n\n\u003cbr /\u003e\n\n이를 해결하기 위해 **카메라의 종횡비(aspect radio)** 를 설정해줍니다.\n\n```js title=\"main.js\" showLineNumbers {39-42}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    DirectionalLight,\n    Scene,\n\n    SphereGeometry,\n    MeshPhongMaterial,\n    Mesh,\n} from 'three';\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { Scene } */\nlet scene;\n\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    // 2. `WebGLRenderer` 객체 생성\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n    });\n    renderer.setSize(\n        window.innerWidth,\n        window.innerHeight\n    );\n\n    // 3. 카메라 생성\n    camera = new PerspectiveCamera(\n        45,\n        window.innerWidth / window.innerHeight\n    );\n    camera.position.set(0, 0, 10);\n\n    // 4. 조명 생성\n    const light = new DirectionalLight();\n    light.position.set(1, 1, 1);\n\n    // 5. `Scene` 객체 생성\n    scene = new Scene();\n    scene.add(light);\n\n    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용\n    renderer.render(scene, camera);\n\n    // 추가: Schene 에 SphereMesh 추가하기\n    createSphereMesh();\n\n    // 7. requestAnimationFrame() 을 사용하여 \u003ccanvas /\u003e 렌더링\n    render();\n}\n\nfunction render() {\n    renderer.render(scene, camera);\n\n    requestAnimationFrame(render);\n}\n\nfunction createSphereMesh() {\n    const sphere_geometry = new SphereGeometry();\n    const sphere_material = new MeshPhongMaterial();\n    const sphere_mesh = new Mesh(sphere_geometry, sphere_material);\n\n    scene.add(sphere_mesh);\n}\n\ninit();\n```\n\n\u003cbr /\u003e\n\n`PerspectiveCamera` 생성자에 인자로 2가지를 넘겨주었습니다.\n\n인자 타입은 다음과 같습니다.\n\n```ts title=\"Perspective 생성자의 인자\"\nclass PerspectiveCamera {\n    constructor(\n        fov: number,\n        aspect: number\n    ) {\n        // ...\n    }\n}\n```\n\n**fov (Field of View)** 는 **카메라의 왜곡 정도값**을 말합니다.\n\n이는 **렌즈 배율** 과 **Sensor-size** 에 대한 연산값이며, **화각을 수치화** 한 것입니다.\n\n값이 클수록 멀리서 보는 느낌의 효과가 발생합니다.\n\n\u003cbr /\u003e\n\n두번째 인자인 **aspect** 는 **카메라 종횡비(aspect ratio)** 에 대한 설정입니다.\n\n화면의 **가로 / 세로** 비율을 나타내므로, `window.innerWidth / window.innerHeight` 로 값을 도출할 수 있습니다.\n\n\u003cbr /\u003e\n\n이렇게 설정한 결과물은 아래와 같습니다.\n\n\u003cimg src=\"/markdownAssets/threejs/2023-12-31-01/2023-12-31-01-03.png\" alt=\"전체화면 적용\" /\u003e\n\n\n\n\u003cbr /\u003e\n\n\n\n## 추가: **계단 효과** 보정하기\n\n모니터는 Pixel 에 RGB 를 발사하여 화면을 그립니다.\n\n이 Pixel 은 정사각형 모양이기 때문에 곡선을 렌더링하게 되면 마치 계단처럼 각진 곡선으로 표현됩니다.\n\n**WebGLRenderer** 객체를 생성하며 options 를 통해 계단 효과를 보정할 수 있습니다.\n\n\u003cbr /\u003e\n\n컴퓨터 그래픽스에서 계단 효과를 해소하는 기법을 간단하게 설명하면, 곡선이 아닌 부분을 흐림(blur) 처리하여 마치 자연스러운 곡선처럼 표현해 줍니다.\n\n이러한 기법을 **Anti-Aliasing** 이라고 합니다.\n\n```js title=\"main.js\" showLineNumbers {32}\nimport {\n    WebGLRenderer,\n    PerspectiveCamera,\n    DirectionalLight,\n    Scene,\n\n    SphereGeometry,\n    MeshPhongMaterial,\n    Mesh,\n} from 'three';\nimport './style.css';\n\n/** @type { WebGLRenderer } */\nlet renderer;\n\n/** @type { PerspectiveCamera } */\nlet camera;\n\n/** @type { Scene } */\nlet scene;\n\nfunction init() {\n    // 1. `\u003ccanvas /\u003e` 태그 생성\n    const $canvas = document.createElement('canvas');\n\n    const $app = document.querySelector('#app');\n    $app.appendChild($canvas);\n\n    // 2. `WebGLRenderer` 객체 생성\n    renderer = new WebGLRenderer({\n        canvas: $canvas,\n        antialias: true,\n    });\n    renderer.setSize(\n        window.innerWidth,\n        window.innerHeight\n    );\n\n    // 3. 카메라 생성\n    camera = new PerspectiveCamera(\n        45,\n        window.innerWidth / window.innerHeight\n    );\n    camera.position.set(0, 0, 10);\n\n    // 4. 조명 생성\n    const light = new DirectionalLight();\n    light.position.set(1, 1, 1);\n\n    // 5. `Scene` 객체 생성\n    scene = new Scene();\n    scene.add(light);\n\n    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용\n    renderer.render(scene, camera);\n\n    // 추가: Schene 에 SphereMesh 추가하기\n    createSphereMesh();\n\n    // 7. requestAnimationFrame() 을 사용하여 \u003ccanvas /\u003e 렌더링\n    render();\n}\n\nfunction render() {\n    renderer.render(scene, camera);\n\n    requestAnimationFrame(render);\n}\n\nfunction createSphereMesh() {\n    const sphere_geometry = new SphereGeometry();\n    const sphere_material = new MeshPhongMaterial();\n    const sphere_mesh = new Mesh(sphere_geometry, sphere_material);\n\n    scene.add(sphere_mesh);\n}\n\ninit();\n```\n\n\n\n## 마치며\n\nThree.js 를 실행하기 위한 최소 구성요소를 구현해 보았습니다.\n\n뭔가 복잡해 보이지만 현실 세계의 무대를 만드는 것과 유사한 개념으로 만들고 있습니다.\n\n* `WebGLRenderer`: 무대를 구성할 건물\n* `Scene`: 무대\n* `PerspectiveCamera`: 카메라\n* `DirectionalLight`: 조명\n* `Mesh`: 배경, 배우, 소품\n\n\u003cbr /\u003e\n\nThree.js 를 처음 시작하며 제가 느낀 어려움으로는 컴퓨터 그래픽스 개념과 카메라에 대한 이해였습니다.\n\n단순히 Three.js 사용법을 익히는 것만으로 원하는 결과물을 얻기는 어려워 보입니다.\n\n지금까지의 코딩에 비해 학습 난이도는 높지만, 새로운 성취감과 즐거움이 기대됩니다.\n"])</script><script>self.__next_f.push([1,"d:[\"$\",\"$Le\",null,{\"featuredMarkdownFileDataList\":[{\"category\":\"jest\",\"slug\":\"2023-12-17-01\",\"href\":\"/blog/jest/2023-12-17-01\",\"frontmatter\":{\"id\":1,\"title\":\"\\\"node:fs\\\" 테스트 하기\",\"description\":\"node 모듈중 File System 기능, \\\"fs\\\" 를 테스트하는 방법에 대해 정리합니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":true,\"tags\":[\"mock-fs\",\"fs\",\"node:fs\",\"jest\",\"@testing-library\",\"유닛 테스트\"],\"createdAt\":\"$D2023-12-17T15:33:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$f\"},{\"category\":\"threejs\",\"slug\":\"2024-01-28-01\",\"href\":\"/blog/threejs/2024-01-28-01\",\"frontmatter\":{\"id\":10,\"title\":\"Gamma, GammFactor, sRGB 정리\",\"description\":\"디지털 환경에서 색상을 표현하는데 사용되는 일부 개념들을 정리합니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":true,\"tags\":[\"threejs\",\"gamma\",\"gamma factor\",\"sRGB\"],\"createdAt\":\"$D2024-01-28T18:00:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$10\"}],\"commonMarkdownFileDataList\":[{\"category\":\"javascript\",\"slug\":\"2023-12-21-01\",\"href\":\"/blog/javascript/2023-12-21-01\",\"frontmatter\":{\"id\":1,\"title\":\"구조 분해 할당의 기본값 지정, null 은 사용 불가!\",\"description\":\"구조 분해 할당의 기본값 설정은 Nullish(undefined 와 null) 가 아닌, 오직 undefined 일 때만 적용됩니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"javascript\"],\"createdAt\":\"$D2023-12-21T20:20:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$11\"},{\"category\":\"javascript\",\"slug\":\"2023-12-30-01\",\"href\":\"/blog/javascript/2023-12-30-01\",\"frontmatter\":{\"id\":2,\"title\":\"AWS S3 를 사용한 PDF 뷰어 구현시, Metadata 설정\",\"description\":\"AWS S3 에 업로드한 PDF 파일이 렌더링되지 않고 다운로드 되는 이슈에 대한 정리 입니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"javascript\",\"PDF\",\"PDF Metadata\",\"AWS\",\"S3\"],\"createdAt\":\"$D2023-12-30T16:00:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$12\"},{\"category\":\"jest\",\"slug\":\"2024-01-06-01\",\"href\":\"/blog/jest/2024-01-06-01\",\"frontmatter\":{\"id\":4,\"title\":\"Nextjs 의 useRouter mock 정의하기\",\"description\":\"Nextjs 의 useRouter 를 사용하는 컴포넌트를 테스트하기 위한 방법을 정리합니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"jest\",\"@testing-library\",\"useRouter\",\"next-router-mock\",\"유닛 테스트\"],\"createdAt\":\"$D2024-01-06T17:30:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$13\"},{\"category\":\"jest\",\"slug\":\"2023-12-26-01\",\"href\":\"/blog/jest/2023-12-26-01\",\"frontmatter\":{\"id\":3,\"title\":\"\\\"styled-components\\\" 로 구현한 컴포넌트 테스트하기\",\"description\":\"\\\"styled-components\\\" 를 사용한 컴포넌트를 테스트하기 위한 환경설정에 대해 알아봅니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"jest\",\"styled-components\",\"@testing-library\",\"유닛 테스트\"],\"createdAt\":\"$D2023-12-26T23:50:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$14\"},{\"category\":\"jest\",\"slug\":\"2023-12-23-01\",\"href\":\"/blog/jest/2023-12-23-01\",\"frontmatter\":{\"id\":2,\"title\":\"\\\"jest.fn()\\\" 으로 함수 테스트하기\",\"description\":\"컴포넌트 props 로 넘겨주는 함수를 테스트하는 방법으로 \\\"jest.fn()\\\" 사용방법에 대한 정리 입니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"jest.fn\",\"jest\",\"@testing-library\",\"유닛 테스트\"],\"createdAt\":\"$D2023-12-23T14:45:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$15\"},{\"category\":\"llmops\",\"slug\":\"2023-12-16-01\",\"href\":\"/blog/llmops/2023-12-16-01\",\"frontmatter\":{\"id\":1,\"title\":\"LLMOps 와 친해지기 1 - 용어 정리\",\"description\":\"AI 학습 모델인 Large Language Model 에 대한 정리입니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[],\"createdAt\":\"$D2023-12-16T15:00:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$16\"},{\"category\":\"nextjs\",\"slug\":\"2024-01-01-01\",\"href\":\"/blog/nextjs/2024-01-01-01\",\"frontmatter\":{\"id\":2,\"title\":\".DS_Store not found 에러\",\"description\":\"Nextjs 빌드 시, .DS_Store 파일을 찾을 수 없다는 에러를 마주하게 되었습니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"nextjs\",\".DS_Store\"],\"createdAt\":\"$D2024-01-01T15:20:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"---\\nid: 2\\ntitle: .DS_Store not found 에러\\ndescription: 'Nextjs 빌드 시, .DS_Store 파일을 찾을 수 없다는 에러를 마주하게 되었습니다.'\\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\\n\\nfeatured: false\\ntags: [\\n    'nextjs',\\n    '.DS_Store',\\n]\\n\\ncreatedAt: '2024-01-01 15:20:00'\\nmodifiedHistories: []\\n---\\n\\n# .DS_Store not found 에러\\n\\nNextjs 프로젝트에 이미지 파일을 추가하고 삭제한 후, 빌드 에러가 발생하였습니다.\\n\\n\u003e Error: ENOENT: no such file or directory, open '/.../.DS_Store\\n\\n\\n\\n\u003cbr /\u003e\\n\\n\\n\\n## 에러 원인 파악\\n\\n.DS_Store 는 맥북의 폴더 관련 메타데이터 파일이며, Finder 로 폴더에 접근하게 되면 자동으로 생성됩니다.\\n\\n문제는 Nextjs 프로젝트를 개발 환경으로 실행하거나 빌드할 때, .DS_Store 파일이 추가되면, 빌드 에러가 발생합니다.\\n\\n\\n\\n\\n\u003cbr /\u003e\\n\\n\\n\\n## 해결 방법\\n\\n* 참고: [Stack Overflow](https://github.com/vercel/next.js/discussions/15573#discussioncomment-2415012)\\n\\n\u003cbr /\u003e\\n\\nNextjs 프로젝트 하위에 존재하는 .DS_Store 파일을 모두 삭제하는 것으로 해결할 수 있었습니다.\\n\\n모든 폴더를 직접 열어보면서 지우는 방법도 있겠지만, 터미널을 사용하여 삭제 명령으로 처리할 수 있습니다.\\n\\n```bash title=\\\"프로젝트 내의 모든 .DS_Store 파일 삭제\\\"\\nrm **/.DS_Store\\n```\\n\\n\u003cbr /\u003e\\n\\n삭제 명령이 실행 완료되면, Nextjs 프로젝트가 정상적으로 빌드되는 것을 확인할 수 있습니다.\\n\"},{\"category\":\"nextjs\",\"slug\":\"2023-12-16-01\",\"href\":\"/blog/nextjs/2023-12-16-01\",\"frontmatter\":{\"id\":1,\"title\":\"Nextjs 프로젝트의 유닛 테스트\",\"description\":\"유닛 테스트를 위해 Jest 와 @testing-library 설치 및 설정에 대한 정리 입니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"nextjs\",\"jest\",\"@testing-library\",\"react\",\"유닛 테스트\"],\"createdAt\":\"$D2023-12-16T22:13:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$17\"},{\"category\":\"react\",\"slug\":\"2023-12-19-01\",\"href\":\"/blog/react/2023-12-19-01\",\"frontmatter\":{\"id\":1,\"title\":\"Custom Hook 으로 분리하며 발생한 실수\",\"description\":\"Custom Hook 으로 분리한 useEffect 가 여러번 호출 케이스 중 한가지를 정리합니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"react\",\"custom hook\"],\"createdAt\":\"$D2023-12-19T22:50:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$18\"},{\"category\":\"threejs\",\"slug\":\"2024-02-29-01\",\"href\":\"/blog/threejs/2024-02-29-01\",\"frontmatter\":{\"id\":16,\"title\":\"Particle 로 반딧불이 표현하기\",\"description\":\"3D 환경에서 반딧불이나 별을 표현할 때 Particle 을 활용합니다. 매우 많은 입자들로 표현하는 Particle 을 어떻게 구현하는지 정리하고자 합니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"3D\",\"Particle\",\"BufferGeometry\",\"PointsMaterial\",\"Points\"],\"createdAt\":\"$D2024-02-29T20:00:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$19\"},{\"category\":\"threejs\",\"slug\":\"2024-02-12-01\",\"href\":\"/blog/threejs/2024-02-12-01\",\"frontmatter\":{\"id\":15,\"title\":\"Material 의 map, bumpMap, normalMap\",\"description\":\"Material 의 표현 방식과 울퉁불퉁한 재질을 처리하는 방식을 정리합니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"3D\",\"Material\",\"Texture\",\"map\",\"bumpMap\",\"normalMap\"],\"createdAt\":\"$D2024-02-12T15:17:30.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$1a\"},{\"category\":\"threejs\",\"slug\":\"2024-02-06-01\",\"href\":\"/blog/threejs/2024-02-06-01\",\"frontmatter\":{\"id\":14,\"title\":\"click 이벤트에 animation 연동하기\",\"description\":\"특정 버튼을 click 했을 때 animation 을 실행하는 방법을 정리합니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"3D\",\"mouse event\",\"click interaction\",\"animation\",\"AnimationMixer\",\"AnimationClip\",\"AnimationAction\"],\"createdAt\":\"$D2024-02-06T15:00:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$1b\"},{\"category\":\"threejs\",\"slug\":\"2024-02-03-02\",\"href\":\"/blog/threejs/2024-02-03-02\",\"frontmatter\":{\"id\":13,\"title\":\"Model 에 Click Event 적용하기 (추가: ToneMapping, light.shadow.camera)\",\"description\":\"Canvas 에 렌더링된 Model 에 Click 인터렉션을 적용 해봅니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"3D\",\"mouse event\",\"click interaction\"],\"createdAt\":\"$D2024-02-03T16:00:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$1c\"},{\"category\":\"threejs\",\"slug\":\"2024-02-03-01\",\"href\":\"/blog/threejs/2024-02-03-01\",\"frontmatter\":{\"id\":13,\"title\":\"(Issue) 조명이 어둡게 보이는 현상\",\"description\":\"강좌의 결과물에 비해 실습 결과물의 밝기가 어둡게 렌더링되는 현상이 발생하였습니다. 현상 원인과 해결 방법에 대해 정리하고자 합니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"3D\",\"DirectionalLgith\",\"HemisphereLight\",\"intensity\"],\"createdAt\":\"$D2024-02-03T14:00:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$1d\"},{\"category\":\"threejs\",\"slug\":\"2024-01-30-01\",\"href\":\"/blog/threejs/2024-01-30-01\",\"frontmatter\":{\"id\":12,\"title\":\"키보드를 사용하여 카메라 이동 인터렉션 만들기\",\"description\":\"키보드 입력에 대한 event listener 를 사용하여 카메라를 이동할 수 있는 인터렉션을 구현해 봅니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"3D\",\"keyboard event\",\"camera\",\"interaction\"],\"createdAt\":\"$D2024-01-30T18:00:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$1e\"},{\"category\":\"threejs\",\"slug\":\"2024-01-28-02\",\"href\":\"/blog/threejs/2024-01-28-02\",\"frontmatter\":{\"id\":11,\"title\":\"canvas 크기 설정 및 material 렌더링 side 설정\",\"description\":\"사용자 모니터 대응을 위한 WebGLRenderer 설정과 material 의 렌더링 side 설정에 대해 정리합니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"setSize()\",\"setPixelRatio()\",\"material\",\"FrontSide\",\"BackSide\",\"DoubleSide\"],\"createdAt\":\"$D2024-01-28T23:00:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$1f\"},{\"category\":\"threejs\",\"slug\":\"2024-01-26-01\",\"href\":\"/blog/threejs/2024-01-26-01\",\"frontmatter\":{\"id\":9,\"title\":\"Model 에 Animation 효과 적용하기\",\"description\":\"Model 파일인 .gltf, .glb 에 Animation 을 적용하는 방법에 대해 정리합니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"javascript\",\"3d\",\".gltf\",\".glb\",\"model\",\"animation\"],\"createdAt\":\"$D2024-01-26T20:00:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$20\"},{\"category\":\"threejs\",\"slug\":\"2024-01-21-01\",\"href\":\"/blog/threejs/2024-01-21-01\",\"frontmatter\":{\"id\":8,\"title\":\"Model (.gltf, .glb) 객체 구조파악 및 그림자 적용\",\"description\":\"Three.js 환경에 불러온 Model 객체의 주요 구성요소를 파악하고, 속성값을 변경하여 그림자를 만들어 봅니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"javascript\",\"3d\",\".gltf\",\".glb\",\"model\",\"traverse\",\"shadow\"],\"createdAt\":\"$D2024-01-21T16:00:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$21\"},{\"category\":\"threejs\",\"slug\":\"2024-01-10-01\",\"href\":\"/blog/threejs/2024-01-10-01\",\"frontmatter\":{\"id\":7,\"title\":\"모델 파일을 Three.js 에 렌더링하기\",\"description\":\".gltf 또는 .glb 확장자인 모델 파일을 Three.js 에 불러오고 렌더링하는 방법을 정리합니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"javascript\",\"3d\",\"hdr\",\".gltf\",\".glb\",\"model\"],\"createdAt\":\"$D2024-01-10T23:50:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$22\"},{\"category\":\"threejs\",\"slug\":\"2024-01-08-01\",\"href\":\"/blog/threejs/2024-01-08-01\",\"frontmatter\":{\"id\":6,\"title\":\"배경화면 및 환경조명 설정하기\",\"description\":\"360도 이미지 확장자인 .hdr 파일을 사용하여 배경화면을 설정하고, 배경화면에 의한 환경조명 설정에 대한 정리입니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"javascript\",\"3d\",\"hdr\",\"background\",\"3D 배경화면\",\"환경조명\"],\"createdAt\":\"$D2024-01-08T23:50:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$23\"},{\"category\":\"threejs\",\"slug\":\"2024-01-07-02\",\"href\":\"/blog/threejs/2024-01-07-02\",\"frontmatter\":{\"id\":5,\"title\":\"그림자 표현하기\",\"description\":\"그림자 설정방법과 특징에 대해 정리합니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"javascript\",\"3d\",\"shadow\"],\"createdAt\":\"$D2024-01-07T23:50:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$24\"},{\"category\":\"threejs\",\"slug\":\"2024-01-07-01\",\"href\":\"/blog/threejs/2024-01-07-01\",\"frontmatter\":{\"id\":4,\"title\":\"평평한 바닥(땅) 만들기 (Plane Mesh)\",\"description\":\"바닥을 표현하기 위해 Plane Mesh 를 생성합니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"javascript\",\"3d\",\"plane\"],\"createdAt\":\"$D2024-01-07T23:20:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$25\"},{\"category\":\"threejs\",\"slug\":\"2024-01-06-01\",\"href\":\"/blog/threejs/2024-01-06-01\",\"frontmatter\":{\"id\":3,\"title\":\"조명 종류와 설정\",\"description\":\"조명 종류와 설정 방법에 대해 정리합니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"javascript\",\"3d\",\"light\"],\"createdAt\":\"$D2024-01-06T23:00:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$26\"},{\"category\":\"threejs\",\"slug\":\"2024-01-01-01\",\"href\":\"/blog/threejs/2024-01-01-01\",\"frontmatter\":{\"id\":2,\"title\":\"카메라 설정 (PerspectiveCamera)\",\"description\":\"Three.js 의 카메라인 PerspectiveCamera 설정에 대한 포스팅입니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"javascript\",\"3d\",\"camera\"],\"createdAt\":\"$D2024-01-01T23:50:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$27\"},{\"category\":\"threejs\",\"slug\":\"2023-12-31-01\",\"href\":\"/blog/threejs/2023-12-31-01\",\"frontmatter\":{\"id\":1,\"title\":\"Three.js 설치 및 실행\",\"description\":\"Three.js 를 사용하기 위한 설치와 첫번째 화면을 그려봅니다.\",\"thumbnail\":\"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\",\"featured\":false,\"tags\":[\"threejs\",\"javascript\",\"3d\"],\"createdAt\":\"$D2023-12-31T22:47:00.000Z\",\"modifiedHistories\":[]},\"markdownFile\":\"$28\"}]}]\n"])</script><script>self.__next_f.push([1,""])</script></body></html><style data-styled="" data-styled-version="6.1.0"></style>