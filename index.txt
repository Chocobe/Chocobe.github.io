1:HL["/_next/static/media/0c7e3e2387401c47-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
2:HL["/_next/static/css/6566b64e7f0e478f.css","style",{"crossOrigin":""}]
0:["6rRi4gyJWW1lEIwhXfR43",[[["",{"children":["__PAGE__",{}]},"$undefined","$undefined",true],"$L3",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/6566b64e7f0e478f.css","precedence":"next","crossOrigin":""}]],"$L4"]]]]
5:I[9248,["576","static/chunks/576-dc377cf448834f03.js","251","static/chunks/251-ef7560cc4f7a9f6d.js","185","static/chunks/app/layout-5bdea2f994faa404.js"],""]
6:I[179,["576","static/chunks/576-dc377cf448834f03.js","251","static/chunks/251-ef7560cc4f7a9f6d.js","185","static/chunks/app/layout-5bdea2f994faa404.js"],""]
7:I[6962,["576","static/chunks/576-dc377cf448834f03.js","251","static/chunks/251-ef7560cc4f7a9f6d.js","185","static/chunks/app/layout-5bdea2f994faa404.js"],""]
8:I[6954,[],""]
9:I[7264,[],""]
3:[null,["$","html",null,{"lang":"ko","children":["$","body",null,{"className":"__className_7bb6ba","children":["$","div",null,{"className":"w-full\n            h-full\n            overflow-y-scroll\n            overflow-x-auto","children":["$","$L5",null,{"children":[["$","$L6",null,{}],["$","$L7",null,{"style":{"minHeight":"calc(100% - 72px)"},"children":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L9",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"childProp":{"current":["$La","$Lb",null],"segment":"__PAGE__"},"styles":null}]}]]}]}]}]}],null]
4:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"Chocobe Blog v2"}],["$","meta","3",{"name":"description","content":"Frontend 기술 블로그 입니다."}],["$","link","4",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}],["$","meta","5",{"name":"next-size-adjust"}]]
a:null
c:I[463,["281","static/chunks/08ffe114-a8e3ed06beefbf38.js","465","static/chunks/48507feb-6de01ca04009bb96.js","306","static/chunks/39209d7c-a33d4549f726b4ab.js","576","static/chunks/576-dc377cf448834f03.js","251","static/chunks/251-ef7560cc4f7a9f6d.js","128","static/chunks/128-a9a4b8134fdbdc1d.js","931","static/chunks/app/page-2a9b84f80b166504.js"],""]
d:T162a,---
id: 1
title: '"node:fs" 테스트 하기'
description: 'node 모듈중 File System 기능, "fs" 를 테스트하는 방법에 대해 정리합니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: true
tags: [
    'mock-fs',
    'fs',
    'node:fs',
    'jest',
    '@testing-library',
    '유닛 테스트',
]

createdAt: '2023-12-17 15:33:00'
modifiedHistories: []
---


# "node:fs" 테스트 하기

Nextjs 를 사용하게 되면서 SSG(static site generators) 와 SSR(server side rendering) 을 사용하게 되었습니다.

덕분에 CSR(client side rendering) 의 단점인 SEO 를 해소할 수 있게 되었습니다.

SSG(static site generators) 와 SSR(server side rendering) 을 사용하게 되면, **node** 모듈들을 사용할 수 있습니다.

이번 포스팅은 **node:fs** 를 사용하는 코드의 유닛 테스트 방법에 대해 정리합니다.



<br />



## Jest 에서 안내하는 built-in modules 테스트

* 참고: [[Jest 공식문서] Mocking Node modules](https://jestjs.io/docs/manual-mocks#mocking-node-modules)

<br />

Jest 공식문서에 의하면, built-in modules 를 테스트하기 위해 몇가지 사전준비가 필요합니다.

1. **node_modules** 와 인접한 경로에 **__mocks__** 폴더 만들기
2. 테스트할 built-in module 과 동일한 이름의 파일(**fs.js**) 을 **__mocks__** 하위에 만들기
3. **fs.js** 파일 구현하기
    1. `jest.createMockFromModule('fs')` 를 호출하여 mock 적용하기
    2. `fs` 의 메시드 중, 테스트 대상이 사용하는 모든 메서드에 mock 구현
4. 유닛 테스트 파일에서 `jest.mock('fs')` 로 mock 적용하기

<br />

위 과정을 모두 구현할 수도 있지만, 좀 더 편리한 방법을 찾아본 결과 **mock-fs** 라는 라이브러리를 찾게 되었습니다.

**mock-fs** 는 Jest 에서 안내하는 "node:fs" 테스트 준비 과정을 제공합니다.



<br />



## **mock-fs** 설치하기

만약 **Typescript** 를 사용한다면, **@types/mock-fs** 모듈도 함께 설치합니다.

```bash title="Javascript 사용 시" 
yarn add -D mock-fs
```

```bash title="Typescript 사용 시"
yarn add -D mock-fs @types/mock-fs
```



<br />



## **node:fs** 테스크 코드 작성하기

* 참고: [mock-fs 공식 문서](https://github.com/tschaub/mock-fs?tab=readme-ov-file#mock-fs)
* 참고: [[지나가던 개발자]jest와 mock-fs로 fs 유닛 테스트하기](https://znagadeon.dev/post/test-fs/index.html)

<br />

**mock-fs** 를 사용하게 되면 아래의 2가지 작업이 필요합니다.

* `jest.beforeEach()`: **mock-fs** 를 사용한 file system mockup
* `jest.afterEach()`: **mock-fs** 해제

<br />

먼저 테스트 준비를 위한 mockup 을 구현하면 다음과 같습니다.

```typescript showLineNumbers
import mock from 'mock-fs';

describe('mock-fs 를 사용한 "node:fs" 테스트', () => {
    beforeEach(() => {
        mock({
            '경로1': {
                '하위_경로1': {
                    '파일_1.mdx': '파일 내용 mockup',
                    '파일_2.mdx': '파일 내용 mockup',
                },
            },
            '경로2/경로3': {
                '하위_경로2': {
                    // 빈 폴더
                },
            },
        });
    });
});
```

<br />

이제 **node:fs** 는 mockup 에서 정의한 mock file system 을 사용하게 됩니다.

```typescript {22} showLineNumbers
import fs from 'node:fs/promises';
import mock from 'mock-fs';

describe('mock-fs 를 사용한 "node:fs" 테스트', () => {
    beforeEach(() => {
        mock({
            '경로1': {
                '하위_경로1': {
                    '파일_1.mdx': '파일 내용 mockup',
                    '파일_2.mdx': '파일 내용 mockup',
                },
            },
            '경로2/경로3': {
                '하위_경로2': {
                    // 빈 폴더
                },
            },
        });
    });

    it('"node:fs" 를 사용하여 파일을 가져올 수 있다.', async () => {
        const fileNameList = await fs.readdir('경로1/하위_경로1');

        expect(fileNameList).toEqual([
            '파일_1.mdx',
            '파일_2.mdx',
        ]);
    });
});
```

<br />

마지막으로 **mock-fs** 를 해제할 수 있도록 `jest.afterEach()` 를 작성하면 "node:fs" 유닛 테스트는 작성완료 됩니다.

```typescript {21} showLineNumbers
import fs from 'node:fs/promises';
import mock from 'mock-fs';

describe('mock-fs 를 사용한 "node:fs" 테스트', () => {
    beforeEach(() => {
        mock({
            '경로1': {
                '하위_경로1': {
                    '파일_1.mdx': '파일 내용 mockup',
                    '파일_2.mdx': '파일 내용 mockup',
                },
            },
            '경로2/경로3': {
                '하위_경로2': {
                    // 빈 폴더
                },
            },
        });
    });

    afterEach(mock.restore);

    it('"node:fs" 를 사용하여 파일을 가져올 수 있다.', async () => {
        const fileNameList = await fs.readdir('경로1/하위_경로1');

        expect(fileNameList).toEqual([
            '파일_1.mdx',
            '파일_2.mdx',
        ]);
    });
});
```



<br />



## 마치며

이번 포스팅에서는 built-in modules 중 "fs" 를 테스트하는 방법에 대해 정리해 보았습니다.

"fs" 가 아닌 다른 module 에 대한 테스트를 한다면, 결국은 Jest 공식문서에서 안내하는 mockup 방법도 사용해 보아야 할 것 같습니다.
e:T5076,---
id: 1
title: Three.js 설치 및 실행
description: 'Three.js 를 사용하기 위한 설치와 첫번째 화면을 그려봅니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: true
tags: [
    'threejs',
    'javascript',
    '3d',
]

createdAt: '2023-12-31 22:47:00'
modifiedHistories: []
---

# Three.js 설치 및 실행

일반적인 웹페이지는 2D 기반으로 구현합니다.

이러한 웹페이지는 서비스를 제공하거나 정보 공유를 목적으로 충분합니다.

만약 이렇게 보편적으로 사용하는 2D 웹페이지에 3D 환경을 더한다면, 서비스나 제품의 브렌딩에 차별점을 줄 수 있을 것 같습니다.

<br />

Three.js 를 스터디하며, 이 블로그의 Profile 페이지를 구현하는 것을 첫번째 목표로 하여 포스팅을 해보려 합니다.



<br />



## Vite 프로젝트 생성하기

Three.js 를 사용하기 위해, VanillaJS 환경의 프로젝트를 생성해 보겠습니다.

Webpack 을 사용하여 프로젝트를 만들어도 되지만, 프로젝트 구성에 투자되는 리소스가 많아지므로, Vite 를 사용하여 프로젝트를 생성해보겠습니다.

```bash title="Vite 프로젝트 생성"
yarn create vite --template vanilla my-threejs

cd my-threejs

yarn install
```



<br />



## Three.js 설치하기

프로젝트를 생성한 후, Three.js 를 설치합니다.

```bash title="Three.js 설치"
yarn install three
```



<br />



## Three.js 기본 구조 구성하기

Three.js 는 **WebGL** 을 기반으로 동작합니다.

이는 **HTML Canvas API** 를 사용하여 그리는 방식입니다.

Three.js 로 화면을 그리기 위한 기본 과정을 살펴보면 다음과 같습니다.

1. `<canvas />` 태그 생성
2. **WebGLRenderer** 객체 생성
3. 카메라 생성
4. 조명 생성
5. **Scene** 객체 생성
6. 위에서 생성한 객체들을 조합하여 **WebGLRenderer** 에 적용
7. `requestAnimationFrame()` 을 사용하여 `<canvas />` 렌더링

<br />

위 과정은 아래와 같이 함수를 생성하여 구현해 보겠습니다.

1. `init()` 함수 만들기: 1번 ~ 6번 과정을 처리합니다.
2. `render()` 함수 만들기: 7번 과정을 처리합니다.



<br />



## 1. `<canvas />` 태그 생성

먼저 Three.js 를 렌더링할 `<canvas />` 태그를 생성하는 로직을 구현해 보겠습니다.

```js title="main.js" showLineNumber
function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);
}

init();
```



<br />



## 2. **WebGLRenderer** 객체 생성

**WebGLRenderer** 객체는 Three.js 의 코어 역할을 합니다.

위에서 생성한 `<canvas />` 를 인자로 넘겨주어 렌더링 대상을 지정해 줍니다.

```js title="main.js" showLineNumbers {2, 5-6, 15-18}
import {
    WebGLRenderer,
} from 'three';

/** @type { WebGLRenderer } */
let renderer;

function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    // 2. WebGLRenderer 객체 생성
    renderer = new WebGLRenderer({
        canvas: $canvas,
    });
}

init();
```



<br />



## 3. 카메라 생성

Three.js 가 실제로 화면에 렌더링하는 것은 `Camera` 가 비추는 곳이 됩니다.

따라서 Three.js 에 사용할 카메라 객체를 생성해 줍니다.

```js title="main.js" showLineNumbers {3, 9-10, 24-25}
import {
    WebGLRenderer,
    PerspectiveCamera,
} from 'three';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    // 2. `WebGLRenderer` 객체 생성
    renderer = new WebGLRenderer({
        canvas: $canvas,
    });

    // 3. 카메라 생성
    camera = new PerspectiveCamera();
}

init();
```



<br />



## 4. 조명 생성

이번에는 조명 객체인 **DirectionalLight** 객체를 생성해 보겠습니다.

현실 세계에서도 빛이 있어야 물체를 볼 수 있듯이, Three.js 에서도 조명이 있어야 물체가 렌더링 됩니다.

조명은 여러가지가 있는데, 이 중 햇빛처럼 직선의 일정한 양의 빛을 나타내는 **DirectionalLight** 객체를 사용해 보겠습니다.

```js title="main.js" showLineNumbers {4, 28-29}
import {
    WebGLRenderer,
    PerspectiveCamera,
    DirectionalLight,
} from 'three';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    // 2. `WebGLRenderer` 객체 생성
    renderer = new WebGLRenderer({
        canvas: $canvas,
    });

    // 3. 카메라 생성
    camera = new PerspectiveCamera();

    // 4. 조명 생성
    const light = new DirectionalLight();
}

init();
```



<br />



## 5. **Scene** 객체 생성

무대는 `Scene` 객체로 만들 수 있습니다.

`Scene` 객체는 `add()` 메서드를 사용하여 위에서 만들었던 조명과 물체(Mesh)들을 적용할 수 있습니다.

<br />

`Scene` 객체를 생성하고 조명을 적용해 보겠습니다.

```js title="main.js" showLineNumbers {5, 14-15, 35-37}
import {
    WebGLRenderer,
    PerspectiveCamera,
    DirectionalLight,
    Scene,
} from 'three';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

/** @type { Scene } */
let scene;

function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    // 2. `WebGLRenderer` 객체 생성
    renderer = new WebGLRenderer({
        canvas: $canvas,
    });

    // 3. 카메라 생성
    camera = new PerspectiveCamera();

    // 4. 조명 생성
    const light = new DirectionalLight();

    // 5. `Scene` 객체 생성
    scene = new Scene();
    scene.add(light);
}

init();
```



<br />



## 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용

이제 Three.js 를 실행하여 화면을 그릴 준비가 되었습니다.

**WebGLRenderer** 는 **Scene(무대)** 와 **카메라** 를 사용하여 화면을 그리는 역할을 하게 됩니다.

```js title="main.js" showLineNumbers {39-40}
import {
    WebGLRenderer,
    PerspectiveCamera,
    DirectionalLight,
    Scene,
} from 'three';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

/** @type { Scene } */
let scene;

function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    // 2. `WebGLRenderer` 객체 생성
    renderer = new WebGLRenderer({
        canvas: $canvas,
    });

    // 3. 카메라 생성
    camera = new PerspectiveCamera();

    // 4. 조명 생성
    const light = new DirectionalLight();

    // 5. `Scene` 객체 생성
    scene = new Scene();
    scene.add(light);

    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용
    renderer.render(scene, camera);
}

init();
```



<br />



## 7. `requestAnimationFrame()` 을 사용하여 `<canvas />` 렌더링

이번에는 `init()` 의 마지막에 호출할 `render()` 함수를 만들고, Three.js 를 실행하여 브라우저에서 결과를 확인해 보겠습니다.

추가할 `render()` 함수는 `requestAnimationFrame()` 을 사용하여 `render()` 함수를 재귀 호출하도록 하는데, 이는 브라우저에서 **60fps 로 실행하며 화면을 업데이트** 하게 됩니다.

```js title="main.js" showLineNumbers {42-43, 46-50}
import {
    WebGLRenderer,
    PerspectiveCamera,
    DirectionalLight,
    Scene,
} from 'three';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

/** @type { Scene } */
let scene;

function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    // 2. `WebGLRenderer` 객체 생성
    renderer = new WebGLRenderer({
        canvas: $canvas,
    });

    // 3. 카메라 생성
    camera = new PerspectiveCamera();

    // 4. 조명 생성
    const light = new DirectionalLight();

    // 5. `Scene` 객체 생성
    scene = new Scene();
    scene.add(light);

    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용
    renderer.render(scene, camera);

    // 7. requestAnimationFrame() 을 사용하여 <canvas /> 렌더링
    render();
}

function render() {
    renderer.render(scene, camera);

    requestAnimationFrame(render);
}

init();
```



<br />



## 추가: Scene 에 SphereMesh 추가하기

지금까지 작성한 코드를 실행하면, 검은색 화면만 보이게 됩니다.

이는 실제로 화면에 그릴 물체(Mesh) 가 없기 때문에 그릴 대상이 없는 현상입니다.

<br />

위에서 구성한 Three.js 가 잘 동작하는지 테스트를 위해 구형 물체(Sphere Mesh) 를 생성하고, 적용해 보겠습니다.

```js title="main.js" showLineNumbers {7-9, 48-49, 61-67}
import {
    WebGLRenderer,
    PerspectiveCamera,
    DirectionalLight,
    Scene,

    SphereGeometry,
    MeshPhongMaterial,
    Mesh,
} from 'three';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

/** @type { Scene } */
let scene;

function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    // 2. `WebGLRenderer` 객체 생성
    renderer = new WebGLRenderer({
        canvas: $canvas,
    });

    // 3. 카메라 생성
    camera = new PerspectiveCamera();
    camera.position.set(0, 0, 10);

    // 4. 조명 생성
    const light = new DirectionalLight();
    light.position.set(1, 1, 1);

    // 5. `Scene` 객체 생성
    scene = new Scene();
    scene.add(light);

    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용
    renderer.render(scene, camera);

    // 추가: Schene 에 SphereMesh 추가하기
    createSphereMesh();

    // 7. requestAnimationFrame() 을 사용하여 <canvas /> 렌더링
    render();
}

function render() {
    renderer.render(scene, camera);

    requestAnimationFrame(render);
}

function createSphereMesh() {
    const sphere_geometry = new SphereGeometry();
    const sphere_material = new MeshPhongMaterial();
    const sphere_mesh = new Mesh(sphere_geometry, sphere_material);

    scene.add(sphere_mesh);
}

init();
```

<br />

`createSphereMesh()` 함수에서 3가지 객체를 생성하고 있습니다.

이는 컴퓨터 그래픽스에서 3D 물체를 표현하기 위한 요소들 입니다.

* Geometry: 색이 없는 모델링 객체
* Material: 모델링 객체의 색상 또는 질감
* Mesh: Geometry 와 Material 을 합친 결과 모델링 객체

`sphere_mesh` 객체의 `add()` 메소드를 사용하여 **Geometry** 와 **Material** 을 합쳐서 하나의 **Mesh** 를 만들 수 있게 됩니다.

<br />

지금까지 작성한 코드를 실행하면 다음과 같은 결과물을 볼 수 있습니다.

<img src="/markdownAssets/threejs/2023-12-31-01/2023-12-31-01-01.png" alt="Threejs 실행 결과" />



<br />



## 추가: `<canvas />` 를 전체화면으로 설정하기

위 결과물을 확인하면, `<canvas />` 요소가 inline 으로 렌더링되고 있습니다.

이는 **WebGLRenderer** 객체의 **size** 를 조정하여 전체화면으로 설정할 수 있습니다.

그리고 `<canvas />` 의 기본 스타일인 `display: inline` 을 `display: block` 으로 변경합니다.

```css title="style.css" showLineNumbers
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

canvas {
    display: block;
}
```

```js title="main.js" showLineNumbers {11, 33-36}
import {
    WebGLRenderer,
    PerspectiveCamera,
    DirectionalLight,
    Scene,

    SphereGeometry,
    MeshPhongMaterial,
    Mesh,
} from 'three';
import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

/** @type { Scene } */
let scene;

function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    // 2. `WebGLRenderer` 객체 생성
    renderer = new WebGLRenderer({
        canvas: $canvas,
    });
    renderer.setSize(
        window.innerWidth,
        window.innerHeight
    );

    // 3. 카메라 생성
    camera = new PerspectiveCamera();
    camera.position.set(0, 0, 10);

    // 4. 조명 생성
    const light = new DirectionalLight();
    light.position.set(1, 1, 1);

    // 5. `Scene` 객체 생성
    scene = new Scene();
    scene.add(light);

    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용
    renderer.render(scene, camera);

    // 추가: Schene 에 SphereMesh 추가하기
    createSphereMesh();

    // 7. requestAnimationFrame() 을 사용하여 <canvas /> 렌더링
    render();
}

function render() {
    renderer.render(scene, camera);

    requestAnimationFrame(render);
}

function createSphereMesh() {
    const sphere_geometry = new SphereGeometry();
    const sphere_material = new MeshPhongMaterial();
    const sphere_mesh = new Mesh(sphere_geometry, sphere_material);

    scene.add(sphere_mesh);
}

init();
```

<br />

이렇게 적용한 결과는 다음과 같습니다.

<img src="/markdownAssets/threejs/2023-12-31-01/2023-12-31-01-02.png" alt="전체화면 적용" />



<br />



## 추가: 찌그러진 화면 보정하기

Scene 에 추가한 모델링은 구(Sphere) 입니다.

하지만 결과 화면에서 보여지는 구는 타원형으로 보여집니다.

원인은 아래와 같습니다. 

* **카메라의 종횡비(aspect radio)** 설정을 하지 않았으므로, 기본값인 **1** 로 설정됨
* 브라우저의 종횡비가 1:1 이 아닌 상태에서 `<canvas />` 를 전체화면으로 늘리면서 발생하는 화면 늘어짐

<br />

이를 해결하기 위해 **카메라의 종횡비(aspect radio)** 를 설정해줍니다.

```js title="main.js" showLineNumbers {39-42}
import {
    WebGLRenderer,
    PerspectiveCamera,
    DirectionalLight,
    Scene,

    SphereGeometry,
    MeshPhongMaterial,
    Mesh,
} from 'three';
import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

/** @type { Scene } */
let scene;

function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    // 2. `WebGLRenderer` 객체 생성
    renderer = new WebGLRenderer({
        canvas: $canvas,
    });
    renderer.setSize(
        window.innerWidth,
        window.innerHeight
    );

    // 3. 카메라 생성
    camera = new PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight
    );
    camera.position.set(0, 0, 10);

    // 4. 조명 생성
    const light = new DirectionalLight();
    light.position.set(1, 1, 1);

    // 5. `Scene` 객체 생성
    scene = new Scene();
    scene.add(light);

    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용
    renderer.render(scene, camera);

    // 추가: Schene 에 SphereMesh 추가하기
    createSphereMesh();

    // 7. requestAnimationFrame() 을 사용하여 <canvas /> 렌더링
    render();
}

function render() {
    renderer.render(scene, camera);

    requestAnimationFrame(render);
}

function createSphereMesh() {
    const sphere_geometry = new SphereGeometry();
    const sphere_material = new MeshPhongMaterial();
    const sphere_mesh = new Mesh(sphere_geometry, sphere_material);

    scene.add(sphere_mesh);
}

init();
```

<br />

`PerspectiveCamera` 생성자에 인자로 2가지를 넘겨주었습니다.

인자 타입은 다음과 같습니다.

```ts title="Perspective 생성자의 인자"
class PerspectiveCamera {
    constructor(
        fov: number,
        aspect: number
    ) {
        // ...
    }
}
```

**fov (Field of View)** 는 **카메라의 왜곡 정도값**을 말합니다.

이는 **렌즈 배율** 과 **Sensor-size** 에 대한 연산값이며, **화각을 수치화** 한 것입니다.

값이 클수록 멀리서 보는 느낌의 효과가 발생합니다.

<br />

두번째 인자인 **aspect** 는 **카메라 종횡비(aspect ratio)** 에 대한 설정입니다.

화면의 **가로 / 세로** 비율을 나타내므로, `window.innerWidth / window.innerHeight` 로 값을 도출할 수 있습니다.

<br />

이렇게 설정한 결과물은 아래와 같습니다.

<img src="/markdownAssets/threejs/2023-12-31-01/2023-12-31-01-03.png" alt="전체화면 적용" />



<br />



## 추가: **계단 효과** 보정하기

모니터는 Pixel 에 RGB 를 발사하여 화면을 그립니다.

이 Pixel 은 정사각형 모양이기 때문에 곡선을 렌더링하게 되면 마치 계단처럼 각진 곡선으로 표현됩니다.

**WebGLRenderer** 객체를 생성하며 options 를 통해 계단 효과를 보정할 수 있습니다.

<br />

컴퓨터 그래픽스에서 계단 효과를 해소하는 기법을 간단하게 설명하면, 곡선이 아닌 부분을 흐림(blur) 처리하여 마치 자연스러운 곡선처럼 표현해 줍니다.

이러한 기법을 **Anti-Aliasing** 이라고 합니다.

```js title="main.js" showLineNumbers {32}
import {
    WebGLRenderer,
    PerspectiveCamera,
    DirectionalLight,
    Scene,

    SphereGeometry,
    MeshPhongMaterial,
    Mesh,
} from 'three';
import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

/** @type { Scene } */
let scene;

function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    // 2. `WebGLRenderer` 객체 생성
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });
    renderer.setSize(
        window.innerWidth,
        window.innerHeight
    );

    // 3. 카메라 생성
    camera = new PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight
    );
    camera.position.set(0, 0, 10);

    // 4. 조명 생성
    const light = new DirectionalLight();
    light.position.set(1, 1, 1);

    // 5. `Scene` 객체 생성
    scene = new Scene();
    scene.add(light);

    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용
    renderer.render(scene, camera);

    // 추가: Schene 에 SphereMesh 추가하기
    createSphereMesh();

    // 7. requestAnimationFrame() 을 사용하여 <canvas /> 렌더링
    render();
}

function render() {
    renderer.render(scene, camera);

    requestAnimationFrame(render);
}

function createSphereMesh() {
    const sphere_geometry = new SphereGeometry();
    const sphere_material = new MeshPhongMaterial();
    const sphere_mesh = new Mesh(sphere_geometry, sphere_material);

    scene.add(sphere_mesh);
}

init();
```



## 마치며

Three.js 를 실행하기 위한 최소 구성요소를 구현해 보았습니다.

뭔가 복잡해 보이지만 현실 세계의 무대를 만드는 것과 유사한 개념으로 만들고 있습니다.

* `WebGLRenderer`: 무대를 구성할 건물
* `Scene`: 무대
* `PerspectiveCamera`: 카메라
* `DirectionalLight`: 조명
* `Mesh`: 배경, 배우, 소품

<br />

Three.js 를 처음 시작하며 제가 느낀 어려움으로는 컴퓨터 그래픽스 개념과 카메라에 대한 이해였습니다.

단순히 Three.js 사용법을 익히는 것만으로 원하는 결과물을 얻기는 어려워 보입니다.

지금까지의 코딩에 비해 학습 난이도는 높지만, 새로운 성취감과 즐거움이 기대됩니다.
f:T1171,---
id: 1
title: 구조 분해 할당의 기본값 지정, null 은 사용 불가!
description: '구조 분해 할당의 기본값 설정은 Nullish(undefined 와 null) 가 아닌, 오직 undefined 일 때만 적용됩니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'javascript',
]

createdAt: '2023-12-21 20:20:00'
modifiedHistories: []
---

# 구조 분해 할당의 기본값 지정, Null 은 사용 불가!

plain object 를 사용하여, 데이터를 의미단위로 묶어서 사용합니다.

의미를 가지는 key 와 쌍을 이루는 value 로 구성되며, Javascript built-in object 에도 많은 기능을 제공합니다.

이번 포스팅에서는 이러한 plain object 의 기능들 중, **구조 분해 할당의 기본값 설정** 에 대해 정리합니다.



<br />



## 구조 분해 할당의 기본값

구조 분해 할당은 plain object 의 하위 프로퍼티에 좀 더 효율적으로 참조하는 기능입니다.

```javascript title="구조 분해 할당 예시" showLineNumbers {8-14}
const obj = {
    keyA: 'value a',
    keyB: 'value b',
    keyC: undefined,
    keyD: null,
};

// 구조 분해 할당
const {
    keyA,
    keyB,
    keyC,
    keyD,
} = obj;
```

<br />

위 예시처럼 value 가 `undefined` 인 경우도 있고, `null` 인 경우가 있었습니다.

이러한 경우 **기본값을 지정하여 유효한 value 를 보장** 하도록 의도하였습니다.

```javascript title="구조 분해 할당의 기본값 예시" showLineNumbers {8-14}
const obj = {
    keyA: 'value a',
    keyB: 'value b',
    keyC: undefined,
    keyD: null,
};

// 구조 분해 할당 기본값 지정
const {
    keyA,
    keyB,
    keyC =. '빈 값',
    keyD = '빈 값',
};
```

<br />

여기서 제가 실수한 부분이 있습니다.

~~`value` 가 `Nullish (undefined 또는 null)` 일 경우, 기본값을 설정할 수 있다고 생각했습니다.~~

하지만 `null` 에는 기본값 설정이 불가능 하고, **`value` 가 `undefined` 일 경우에만 기본값을 설정** 할 수 있었습니다.

* [MDN - 구조 분해 할당](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%EA%B8%B0%EB%B3%B8%EA%B0%92)

<br />

제가 실수한 부분이 일으킨 이슈는 아래의 코드와 같습니다.

```javascript title="구조 분해 할당의 기본값 이슈" showLineNumbers {11-12, 15-17}
const obj = {
    keyA: 'value a',
    keyB: 'value b',
    keyC: undefined,
    keyD: null,
};

const {
    keyA,
    keyB,
    keyC = '값 없음',
    keyD = '값 없음',
} = obj;

// 에러 발생
// Error: Cannot read properties of null (reading 'toUpperCase')
console.log('keyD.toUpperCase(): ', keyD.toUpperCase());
```

<br />

`keyD` 에 기본값을 `string` 으로 지정하였지만, `null` 이므로 기본값 지정이 적용되지 않습니다.

그러므로 `keyD.toUpperCase()` 를 호출할 경우, `null` 에 대한 메소드 호출이 되며 에러가 발생하게 됩니다.



<br />



## null 은 명시적으로 표현한 값이 없음!

값이 없을을 나타내는 `undefined` 와 `null` 은 타입도 다르지만, 더 **중요한 것은 의미** 인 것 같습니다.

변수나 프로퍼티에 할당한 값이 없는 경우 `undefined` 를 가지고, `null` 은 개발자가 의도를 가지고 값을 비운다는 의미입니다.

즉, 의도를 가지고 비워둔 값에는 구조 분해 할당의 기본값이 적용되지 않는 것 입니다.

<br />

만약 `Nullish` 에 대한 기본값을 지정하고 싶을 경우는 **Nullish 병합 연산자** 를 사용합니다.

```javascript title="Nullish 병합 연산자" showLineNumbers {11-12, 15-16}
const obj = {
    keyA: 'value a',
    keyB: 'value b',
    keyC: undefined,
    keyD: null
};

const {
    keyA,
    keyB,
    keyC: _keyC,
    keyD: _keyD,
};

const keyC = _keyC ?? '값 없음';
const keyD = _keyD ?? '값 없음';
```



<br />



## 유감스러운 구조 분해 할당의 기본값

`undefined` 뿐만 아니라, `Nullish` 에 대한 기본값을 설정하고 싶다면, 위 예시코드와 같이 코드 1줄씩 추가로 작성하게 됩니다.

이 기능의 의미는 이해하지만, 작성할 코드가 늘어난다는 점에서는 아쉽습니다.

<br />

다른분들은 저와 같은 실수가 없기를 바라며, 이번 포스팅을 마무리 합니다.
10:T1174,---
id: 2
title: AWS S3 를 사용한 PDF 뷰어 구현시, Metadata 설정
description: 'AWS S3 에 업로드한 PDF 파일이 렌더링되지 않고 다운로드 되는 이슈에 대한 정리 입니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'javascript',
    'PDF',
    'PDF Metadata',
    'AWS',
    'S3',
]

createdAt: '2023-12-30 16:00:00'
modifiedHistories: []
---

# 웹에서 PDF 뷰어를 제공하는 방법

PDF 파일은 범용적으로 사용되는 문서 파일 입니다.

PDF 뷰어를 제공하는 방법에는 여러가지가 있습니다.

* `<iframe />`, `<object />`, `<embed />` 태그
* PDF 뷰어 관련 라이드러리들



<br />



## `<object />` 를 사용한 PDF 뷰어 구현하기

PDF 파일은 브라우저 내장 뷰어에서 다양한 기능을 제공합니다.

구현 초기에는 `<iframe />` 이나 `<object />` 의 보안문제를 피하기 위해, PDF 라이브러리를 사용하고자 하였습니다.

하지만 브라우저의 내장 PDF 뷰어의 강력한 기능들을 포기하거나 직접 구현해야 하는 문제가 있습니다.

<br />

이러한 이유로 `<object />` 태그를 사용하여 PDF 뷰어를 사용하기로 하였습니다.

또한 `<iframe />` 보다는 `<object />` 태그가 PDF 에는 적합하다는 MDN 공식문서에 따르게 되었습니다.

* 참고: [MDN 공식 문서](https://developer.mozilla.org/ko/docs/Learn/HTML/Multimedia_and_embedding/Other_embedding_technologies#embed_%EC%99%80_object_%EC%9A%94%EC%86%8C)



<br />



## `<object />` 를 사용하여 간단한 PDF 뷰어 만들기

아래와 같이 `<object />` 태그를 사용하여 간단하게 PDF 뷰어 기능을 사용할 수 있습니다.

```tsx title="PDF 뷰어 예시 코드" showLineNumbers
type TMyPdfViewerProps = {
    url: string;
}

function MyPdfViewer(props: TMyPdfViewerProps) {
    const {
        url,
    } = props;

    const data = `${url}#view=FitH`;

    return (<>
        <object 
            data={data}
            type='application/pdf' 
            width='100%' 
            height='100%' />
    </>);
}

export default MyPdfViewer;
```



<br />



## AWS S3 에 업로드한 PDF 파일이 다운로드되는 이슈

AWS S3 는 널리 사용되는 클라우드 스토리지 입니다.

PDF 파일을 S3 에 업로드한 후, `<MyPdfViewer />` 컴포넌트로 보여주고자 합니다.

만약 단순히 S3 에 PDF 파일을 업로드 했다면, `<object />` 에 연동한 **PDF 파일이 렌더링 되지 않고 다운로드되는 현상**을 마주하게 됩니다.



<br />



## PDF 파일이 다운로드만 되는 이유

AWS S3 에 파일을 업로드할 경우, 별도의 설정을 하지 않는다면 아래와 같은 **Metadata** 기본값으로 설정됩니다.

* `Content-Type: binary/octet-stream`
* `Content-Disposition: attachment`

<br />

위와 같은 파일을 브라우저에서 요청할 경우, 해당 파일은 첨부파일로 인식하고 다운로드하는 동작을 하게 됩니다.

AWS S3 에 업로드한 파일이 **단순 첨부파일 응답 으로 처리되기 때문에** `<object />` 태그에 렌더링되는 것이 아닌 다운로드가 됩니다.

<br />

이를 PDF 뷰어로 동작하도록 하려면, **AWS S3 에 업로드한 PDF 파일의 Metadata 를 아래와 같이 수정** 해서 해결할 수 있습니다.

* `Content-Type: application/pdf`
* `Content-Disposition: inline`

<br />

위와 같이 Metadata 를 변경했다면, `<object />` 태그에서 요청한 PDF 파일은 다운로드되지 않고 브라우저 내장 PDF 뷰어로 렌더링됩니다.



<br />



## 마치며

이번 이슈를 해결하기 위해, 최초 시도했던 방법은 AWS S3 에 PDF 파일을 별도로 요청한 후, 응답 결과인 PDF 파일 데이터를 `Blob` 으로 wrapping 하는 방식을 구현했습니다.

하지만 이렇게 wrapping 한 Blob 은 파일내용에 따라 렌더링이 되지 않는 이슈가 발생하였습니다.

Blob 으로 변환한 PDF 파일을 다운로드하여 확인하면 정상적으로 열리지만 `<object />` 태그에 렌더링되지 않는 경우가 있다보니, AWS S3 에 업로드한 파일의 Metadata 를 수정하는 방법을 사용하게 되었습니다.

이번 이슈를 통해, 파일을 다루는 경우에는 Metadata 에 대한 확인 및 설정이 필요하다는 것을 배우게 되었습니다.
11:T1598,---
id: 4
title: 'Nextjs 의 useRouter mock 정의하기'
description: 'Nextjs 의 useRouter 를 사용하는 컴포넌트를 테스트하기 위한 방법을 정리합니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'jest',
    '@testing-library',
    'useRouter',
    'next-router-mock',
    '유닛 테스트',
]

createdAt: '2024-01-06 17:30:00'
modifiedHistories: []
---

# Nextjs 의 useRouter mock 정의하기

페이지 이동을 위한 컴포넌트는 웹페이지에서 빠질 수 없는 컴포넌트 입니다.

Nextjs 프로젝트에서 페이지 이동은 Nextjs 의 `useRouter` hook 을 사용하여 구현합니다.

이러한 컴포넌트는 내부에서 `useRouter` 를 사용하고 있기 때문에, Jest 의 `render()` 를 사용한 렌더링 시, 에러가 발생하게 됩니다.

이번 포스팅에서는 `useRouter` 를 mocking 하여 테스트 하는 방법에 대해 정리하고자 합니다.



<br />



## 컴포넌트 렌더링 실패

`useRouter` 를 사용하는 컴포넌트를 아무런 설정없이 Jest 의 `render()` 를 실행시키면, 렌더링 에러가 발생합니다.

이는 테스트 환경에서 `useRouter()` 가 렌더링 되지 않으면서 발생하게 됩니다.

이를 해결하기 위해, `next-router-mock` 라이브러리를 활용할 수 있습니다.

```bash
yarn add -D next-router-mock
```



<br />



## `useRouter` 를 사용하는 테스트용 컴포넌트

이번 포스트에서 테스트할 컴포넌트는 아래와 같습니다.

`onClick()` 내부에서 `router.push()` 를 사용하여 페이지를 이동 시키는 동작을 합니다.

```tsx title="MyAnchor.tsx" showLineNumbers
import {
    useCallback,
    PropsWithChildren,
} from 'react';
import {
    useRouter,
} from 'next/navigation';

type TMyAnchorProps = PropsWithChildren<{
    className?: string;
    href: string;
}>;

function MyAnchor(props: TMyAnchorProps) {
    const {
        className,
        href,
        children,
    } = props;

    const router = useRouter();

    const onClick = useCallback(() => {
        router.push(href);
    }, [href]);

    return (
        <a 
            className={className}
            href={href}>
            {children}
        </a>
    );
}

export default MyAnchor;
```



<br />



## `jest.mock()` 을 사용하여 `useRouter()` mocking 하기

`jest.mock()` 을 사용하면, 특정 모듈을 mocking 할 수 있습니다.

이를 활용하여, `next/navigation` 모듈을 mocking 하여 `useRouter` 가 테스트 환경에서 렌더링될 수 있도록 합니다.

```ts title="jest.mock() 으로 useRouter mocking 하기"
jest.mock('next/navigation', () => jest.requireActual('next-router-mock'));
```

* `jest.mock()`: 특정 모듈을 mocking 합니다.
    * 첫번째 인자: mocking 할 모듈명
    * 두번째 인자: mocking 반환 함수
* `jest.requireActual()`: 실제 모듈을 가져옵니다. (`import`, `require`)

<br />

위 코드를 사용하여 `useRouter` 를 mocking 하게 되면, 정상적으로 렌더링됨을 확인할 수 있습니다.

아래는 테스트 예시 코드 입니다.

```tsx title="MyAnchor 테스트" showLineNumbers {7, 9, 12-15, 48-50}
import MyAnchor from './MyAnchor';
import {
    render,
    screen,
} from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import mockRouter from 'next-router-mock';

jest.mock('next/navigation', () => jest.requireActual('next-router-mock'));

describe('<MyAnchor /> 테스트', () => {
    beforeEach(() => {
        // mockRouter 의 pathname 을 '/' 으로 초기화 합니다.
        mockRouter.push('/');
    });

    it('DOM 에 렌더링 된다.', () => {
        render(
            <div data-testid="test-MyAnchor">
                <MyAnchor href="/test-url">
                    Test Page
                </MyAnchor>
            </div>
        );

        const $anchor = screen.getByTestId('test-MyAnchor');

        expect($anchor).toBeInTheDocument();
    });

    it('click 시, href 경로로 페이지 이동한다.', async () => {
        render(
            <div data-testid="test-MyAnchor">
                <MyAnchor 
                    className="test-className"
                    href="test-url">
                    Test Page
                </MyAnchor>
            </div>
        );

        const $anchor = screen
            .getByTestId('test-MyAnchor')
            .querySelector('.test-className');

        await userEvent.click($anchor);

        expect(mockRouter).toMatchObject({
            pathname: '/test-url',
        });
    });
});
```

<br />

그리고 `router` 가 클릭된 후, 페이지 이동이 되었는지 테스트하기 위해, `mockRouter` 를 활용할 수 있습니다.

`mockRouter` 의 `pathname` 에 이동할 페이지의 url 이 반영되었다면, 실제로는 페이지 이동이 된 것으로 볼 수 있습니다.



<br />



## 마치며

프레임워크는 개발에 필요한 다양한 기능을 제공합니다.

이를 테스트하기 위해서는 프레임워크와 동일한 환경을 만들어주어야 함을 알게 되었습니다.

단순 컴포넌트나 함수를 테스트할 때는 신경쓰지 않았던 **모듈 mocking** 이 필요하고, `jest.mock()` 을 사용하여 mocking 할 수 있었습니다.

`next-router-mock` 라이브러리 처럼 오픈 소스 문화가 있기에 저도 웹 개발을 할 수 있음을 새삼 느끼게 됩니다. 🫠
12:T14bb,---
id: 3
title: '"styled-components" 로 구현한 컴포넌트 테스트하기'
description: '"styled-components" 를 사용한 컴포넌트를 테스트하기 위한 환경설정에 대해 알아봅니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'jest',
    'styled-components',
    '@testing-library',
    '유닛 테스트',
]

createdAt: '2023-12-26 23:50:00'
modifiedHistories: []
---

# styled-components 로 구현한 컴포넌트 테스트하기

컴포넌트의 style 작성에는 여러가지 선택지가 있습니다.

그 중 저는 **styled-components** 를 가장 선호합니다.

이번 포스팅에서는 **styled-components** 를 사용한 컴포넌트를 테스트하기 위한 jest 환경을 설정해보겠습니다.



<br />



## 설정없이 jest 를 실행하면? throw Error!

**styled-components** 는 `<ThemeProvider />` 하위에서 사용할 수 있습니다.

만약 추가 설정없이 jest 를 실행하게 되면, `render()` 호출에서 에러가 발생합니다.

```tsx title="에러 발생 예시" showLineNumbers {10-12}
import MyComponent from './MyComponent';
import {
    render,
} from '@testing-library/react';

describe('MyComponent 테스트', () => {
    it('DOM 에 렌더링 된다.', () => {
        // render() 호출 시, Error 발생
        render(
            <div data-testid="my-component">
                <MyComponent />
            </div>
        );

        const $myComponent = screen.getByTestId('my-component');

        expect($myComponent).toBeInTheDocument();
    });
});
```

```bash title="에러 메시지"
TypeError: Cannot read properties of undefined (reading 'MarkdownAnchor')
```

<br />

아래와 같이 `render()` 호출부에 `<ThemeProvider />` 를 함께 넘겨주면 테스트가 정상적으로 실행되는 것을 확인할 수 있습니다.

```tsx title="테스트 정상 동작" showLineNumbers {11, 13}
import MyComponent from './MyComponent';
import {
    render,
} from '@testing-library/react';

describe('MyComponent 테스트', () => {
    it('DOM 에 렌더링 된다.', () => {
        // render() 성공
        render(
            <div data-testid="my-component">
                <ThemeProvier theme={theme}>
                    <MyComponent />
                </ThemeProvier>
            </div>
        );

        const $myComponent = screen.getByTestId('my-component');

        // 테스트 통과
        expect($myComponent).toBeInTheDocument();
    });
});
```



<br />



## util 또는 hook 으로 `<ThemeProvider />` 제공하기

테스트 코드를 작성할 때, 각 테스트 케이스별로 중복되는 코드들이 생기게 됩니다.

이러한 부분들을 공통 함수로 묶어내거나 추상화하지 않는 이유는, 테스트 코드를 읽어나가는 것으로 어떤 테스트를 수행하는지 파악할 수 있는 것이 더 테스트 코드의 가치를 높이기 때문입니다.

<br />

하지만 `<ThemeProvider />` 를 감싸는 코드는 **styled-components** 설정을 테스트하는 것이 아닌 이상, 특정 컴포넌트를 테스트하는데 의미를 두기 어렵습니다.

그러므로 이 부분은 별도의 **util 함수** 또는 **custom hook** 으로 분리하여 사용해도 무방해 보입니다.

<br />

저는 **@testing-library** 에서 제공하는 `render()` 함수 처럼 `util 함수` 로 만드는 것이 좀 더 일관되는 패턴으로 생각하여 아래와 같이 작성해 보았습니다.

```tsx title="@/utils/testing-library/renderTestComponent.tsx" showLineNumbers
// react
import { 
    ReactElement,
} from 'react';
// jest
import { 
    render,
} from '@testing-library/react';
// styled-components
import { 
    ThemeProvider,
} from 'styled-components';
import theme from '@/styles/theme';

const renderTestComponent = (element: ReactElement) => {
    const { rerender } = render(
        <ThemeProvider theme={theme('light')}>
            {element}
        </ThemeProvider>
    );

    return {
        rerender,
    };
};

export default renderTestComponent;
```

<br />

이를 테스트 코드에 적용하면 다음과 같습니다.

```tsx title="util 함수를 적용한 테스트 코드" showLineNumbers {5, 10}
import MyComponent from './MyComponent';
// import {
//     render,
// } from '@testing-library/react';
import renderTestComponent from '@/utils/testing-library/renderTestComponent';

describe('MyComponent 테스트', () => {
    it('DOM 에 렌더링 된다.', () => {
        // render() 성공
        renderTestComponent(
            <div data-testid="my-component">
                <MyComponent />
            </div>
        );

        const $myComponent = screen.getByTestId('my-component');

        // 테스트 통과
        expect($myComponent).toBeInTheDocument();
    });
});
```



<br />



## 마치며

유닛 테스트를 하나씩 추가하며, coverage 가 높아져 가는 것이 하나의 재미요소가 되었습니다.

`renderTestComponent()` 처럼 테스트 환경을 위한 기능을 만드는 과정은 성취감과 연결되었습니다.

이 블로그 프로젝트는 개발 초기 시점인 만큼, 모든 컴포넌트를 테스트할 수 있도록 목표를 잡아야겠습니다!
13:T15fe,---
id: 2
title: '"jest.fn()" 으로 함수 테스트하기'
description: '컴포넌트 props 로 넘겨주는 함수를 테스트하는 방법으로 "jest.fn()" 사용방법에 대한 정리 입니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'jest.fn',
    'jest',
    '@testing-library',
    '유닛 테스트',
]

createdAt: '2023-12-23 14:45:00'
modifiedHistories: []
---

# "jest.fn()" 으로 함수 테스트하기

컴포넌트에는 props 를 사용하여 데이터와 함수를 넘겨주도록 만들 수 있습니다.

이번 포스팅에서는 `jest.fn()` 을 사용하여 컴포넌트에 넘겨준 함수가 정상동작하는지 테스트하는 방법에 대해 정리합니다.



<br />



## 컴포넌트 props 에 넘겨주는 함수

컴포넌트 props 에는 함수를 넘겨줄 수 있습니다.

사용자 인터렉션을 처리하기 위한 함수가 될 수도 있고, 특정 동작에 대한 callback 으로 활용되도록 구현할 수 있습니다.

이렇게 넘겨준 함수가 의도한 시점, 상황에 호출이 되는지 테스트하고자 합니다.



<br />



## 테스트 예시 컴포넌트

이번 포스팅에서 테스트에 사용할 input 컴포넌트를 만들어보겠습니다.

```typescript title="./ChocobeInput.tsx" showLineNumbers
import {
    useCallback,
    memo,
    ChangeEvent,
} from 'react';

type TChocobeButtonProps = {
    value: string;
    onChange: (value: string) => void;
};

function ChocobeInput(props: TChocobeInputProps) {
    const {
        value,
        onChange,
    } = props;

    //
    // callback
    //
    const onChangeInput = useCallback((e: ChangeEvent<HTMLInputElement>) => {
        const value = e.target.value;
        onChange(value);
    }, [onChange]);

    return (
        <input
            value={value}
            onChange={onChangeInput} />
    );
}

export default memo(ChocobeInput);
```



<br />



## `jest.fn()` 으로 onChange mockup function 만들기

* 참고: [[Jest 공식 문서] Using a mock function](https://jestjs.io/docs/mock-functions#using-a-mock-function)

`Jest` 는 `fn()` 이라는 **함수 mockup 메소드** 를 제공하고 있습니다.

위 예시 컴포넌트를 테스트한다면, `props.onChange()` 를 테스트하기 위해 `jest.fn()` 을 사용하게 됩니다.

```typescript title="jest.fn() 으로 mockup function 생성하기" showLineNumbers {11, 16}
// UI Components
import ChocobeInput from './ChocobeInput';
// jest
import {
    render,
    screen,
} from '@testing-library/react';

describe('ChocobeInput 컴포넌트 테스트', () => {
    it('ChocobeInput 에 값을 입력하면 onChange() 가 호출된다.', async () => {
        const fn_onChange = jest.fn();

        render(
            <ChocobeInput
                value=""
                onChange={fn_onChange} />
        );
    });
});
```



<br />

## input 요소에 KeyboardEvent 발생시키기

`fn_onChange()` 함수는 `<ChocobeInput />` 컴포넌트에 `KeyboardEvent` 가 발생하면 호출되는 구조 입니다.

`userEvent` 를 사용하여 `KeyboardEvent` 나 `click` 이벤트 등을 발생시킬 수 있으며, `<ChocobeInput />` 컴포넌트의 경우에는 `KeyboardEvent` 가 발생하면 `onChange()` 가 호출됩니다.

컴포넌트에 `KeyboardEvent` 를 발생시키려면 `userEvent.type()` 메소드를 활용하게 됩니다.

```typescript title="userEvent.type() 으로 KeyboardEvent 발생시키기" showLineNumbers {24}
// UI Components
import ChocobeInput from './ChocobeInput';
// jest
import {
    render,
    screen,
} from '@testing-library/react';
import {
    userEvent,
} from '@testing-library/user-event';

describe('ChocobeInput 컴포넌트 테스트', () => {
    it('ChocobeInput 에 값을 입력하면 onChange() 가 호출된다.', async () => {
        const fn_onChange = jest.fn();

        render(
            <ChocobeInput
                value=""
                onChange={fn_onChange} />
        );

        const $chocobeInput = screen.getByRole('textbox');

        await userEvent.type($chocobeInput, 'Hello');
    });
});
```



<br />



## KeyboardEvent 에 의해 fn_onClick() 호출 여부 테스트하기

위 예시 코드를 통해 `<ChocobeInput />` 컴포넌트에 `KeyboardEvent` 가 발생한 상태 입니다.

`userEvent.type(요소, 입력값)` 으로 넘겨준 `입력값` 은 문자 1개당 1번의 KeyboardEvent 가 발생하게 되므로, 총 5번의 KeyboardEvent 가 발생한 상태 입니다.

이를 테스트하면 다음과 같습니다.

```typescript title="발생한 이벤트 테스트" showLineNumbers
// UI Components
import ChocobeInput from './ChocobeInput';
// jest
import {
    render,
    screen,
} from '@testing-library/react';
import {
    userEvent,
} from '@testing-library/user-event';

describe('ChocobeInput 컴포넌트 테스트', () => {
    it('ChocobeInput 에 값을 입력하면 onChange() 가 호출된다.', async () => {
        const fn_onChange = jest.fn();

        render(
            <ChocobeInput
                value=""
                onChange={fn_onChange} />
        );

        const $chocobeInput = screen.getByRole('textbox');

        await userEvent.type($chocobeInput, 'Hello');

        expect(fn_onChange).toHaveBeenCalledTimes(5);
    });
});
```



<br />



## 마치며

함수 테스트는 `jest.fn()` 뿐만 아니라 `jest.spyOn()` 으로도 가능합니다.

다음 포스팅에서는 `jest.spyOn()` 으로 테스트하는 방법과 `jest.fn()` 과 차이점에 대해 정리하겠습니다.
14:T1e27,---
id: 1
title: LLMOps 와 친해지기 1 - 용어 정리
description: 'AI 학습 모델인 Large Language Model 에 대한 정리입니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: []

createdAt: '2023-12-16 15:00:00'
modifiedHistories: []
---

# LLMOps 와 친해지기 1 - 용어 정리

**LLMOps** 란, Large Language Model 의 약자이며 대규모 언어 모델 입니다.

사내 신규 프로젝트로 **LLMOps** 를 사용하기 위한 UI 툴 서비스를 개발하게 되었습니다.

개발할 서비스에 대한 도메인 지식이 필요함을 느끼게 되었기에, 관련 용어와 개념을 정리하고자 합니다.

일반인의 시야에서 조사한 내용을 정리하는 목적을 가지고 LLM 에 초점을 가지므로, 좀 더 정확한 내용은 첨부한 **참고 링크** 를 확인해주세요.



<br />



## 용어 정리

### 머신러닝

> 참고: [Machine learning (ML) –  머신러닝 이란?](https://www.ibm.com/kr-ko/topics/machine-learning)

<br />

기계학습 방법을 말합니다.

**딥러닝** 이 아닌 **머신러닝** 은 정형화된 데이터를 학습하며 사람의 개입이 많이 필요합니다.

정형화된 데이터란 데이터 각각에 대하여 **labeling** 이나 **tagging** 작업을 한 학습 데이터를 말합니다.

데이터가 많을수록 좋은 결과를 기대할 수 있기 때문에, 정형화된 데이터를 만드는 과정부터 많은 시간과 노력이 필요하게 됩니다.



<br />



### 딥러닝

> 참고: [Machine learning (ML) –  머신러닝 이란?](https://www.ibm.com/kr-ko/topics/machine-learning)

<br />

머신러닝의 하위 분야이며, 머신러닝 처럼 정형화된 데이터로 학습할 수 있으며, 추가로 비정형 데이터를 학습할 수도 있습니다.

비정형 데이터 학습을 위해 사용되는 개념으로 **신경망** 이 있습니다.



<br />



### 신경망

> 참고: [AWS - 신경망이란 무엇인가요?](https://aws.amazon.com/ko/what-is/neural-network/)
>
> 참고: [Machine learning (ML) –  머신러닝 이란?](https://www.ibm.com/kr-ko/topics/machine-learning)

<br />

신경망은 머신러닝의 하위 분야이며 딥러닝의 기계 학습 알고리즘 중 하나입니다.

신경망은 구조화 되지 않은 데이터와 명시적이지 않은 훈련 방식을 사용하며, 이렇게 학습한 데이터를 **일반화** 하고 **추론** 할 수 있습니다.

예를 들면 다음과 같습니다.

```bash
질문1: "결제 방법을 알려줘"

질문2: "비용 송금 방법을 알려줘"
```

위 질문은 문장은 다르지만, 컴퓨터는 신경망을 통해 "결제 방법 안내" 라는 동일한 문맥임을 이해합니다.

<br />

신경망은 **노드** 로 구성되며, 노드에는 **입력 노드**, **출력 노드** 등, 무수히 많은 노드로 구성됩니다.

각 노드는 **관련성에 대한 임계치** 가 있으며, 임계치에 다다르면 활성화 되는데, 이러한 방식으로 관련된 노드들의 활성화를 통해 **일반화** 와 **추론** 을 할 수 있게 됩니다.



<br />



### MLOps

> 참고: [MLOps란?](https://www.ibm.com/kr-ko/topics/machine-learning)

<br />

**MLOps** 는 **Machine Learning** 과 **Operations** 의 합성어로, 효율적인 머신러닝 **모델 개발**, **배포**, **운용** 을 위한 개발 방법론이며, **새로운 모델 개발이 목적** 입니다.

**MLOps** 를 구성하는 요소는 다음과 같습니다.

* 지속적 통합 (**CI**: Continuous Integration)
* 지속적 배포 (**CD**: Continuous Deployment)
* 지속적 학습 (**CT**: Continuous Training)



<br />



### FMOps

> 참고: [카카오엔터프라이즈 기술블로그 Tech&(테크앤):티스토리](https://tech.kakaoenterprise.com/196)

**FM(Foundation Model)** 을 한국어로 **기반 모델** 이라고 합니다.

**FMOps(Foundation Model Operations)** 는 **기반 모델 개발**, **배포**, **운용** 을 위한 개발 방법론 입니다.

**FMOps(Foundation Model Operations)** 에는 자연어 뿐만 아니라, 이미지나 음성을 기반으로 하는 모델(예시: **DALL-E**) 을 모두 포함합니다.



<br />



### LLMOps

> 참고: [카카오엔터프라이즈 기술블로그 Tech&(테크앤):티스토리](https://tech.kakaoenterprise.com/196)

<br />

**FMOps** 에 포함되는 개념이며, **자연어 처리** 를 위한 개념으로 **LLM(Large Language Model)** 이 있습니다.

**LLMOps(Large Langague Model Operations)** 는 **LLM 개발**, **배포**, **운용** 을 위한 개발 방법론입니다.



<br />



### MLOps 와 FMOps 비교

> 참고: [카카오엔터프라이즈 기술블로그 Tech&(테크앤):티스토리](https://tech.kakaoenterprise.com/196)

<br />

* 목적
    * MLOps: **새로운 모델을 개발** 합니다.
    * FMOps: 이미 학습이 완료된 모델과 자신의 데이터를 사용하여, **자신만의 AI 앱을 개발** 합니다.
* 다루는 모델 유형
    * MLOps: 기업이 직접 모델과 파이프라인 모두 개발하게 됩니다.
    * FMOps: **API 를 통해서 원하는 모델을 사용** 합니다.
* 산출물
    * MLOps: **Model** 과 이를 사용할 수 있는 **API** 를 만들게 됩니다.
    * FMOps: LLM 과 사용자의 커스텀 데이터를 사용한 **AI 어플리케이션** 을 만들게 됩니다.



<br />



### 프롬프트

> [프롬프트 (Prompt) 란 무엇인가? - 정의, 원리, fine tuning](https://www.thedatahunt.com/trend-insight/what-is-prompt)

<br />

개발 환경에서는 다양한 설정과 실행방법이 있습니다.

이를 UI 로 모두 제공하는 것은 어렵기도 하고, 사용성도 복잡해집니다.

그래서 CLI 를 사용하는 경우가 많습니다.

프롬프트란, 컴퓨터에게 실행할 태스크를 전달하는 메시지, **명령어** 라는 의미를 가집니다.

AI 가 발전함에 따라 현재는 명령어뿐만 아니라, 자연어까지 컴퓨터가 이해할 수 있게 되어서, 프롬프트의 의미는 **컴퓨터에게 어떤 태스크를 수행할지 전달하는 자연어 메시지** 라는 의미로 확장되었습니다.



<br />



### 프롬프트 체이닝

> 참고: [카카오엔터프라이즈 기술블로그 Tech&(테크앤):티스토리](https://tech.kakaoenterprise.com/196)

<br />

프롬프트를 잘 작성할수록 AI 는 더 정확한 응답을 할 수 있습니다.

LLM 에 하나의 프롬프트를 연결하여 AI 앱을 만들수도 있지만, 더 정확한 기능을 구현하기 위해 LLM 에 외부의 프롬프트를 포함하여 복수의 프롬프트를 연결하여 개발하게 되는데, 이를 **프롬프트 체이닝(Prompt Chaing)** 이라고 합니다.



<br />



### LangChain

> 참고: [카카오엔터프라이즈 기술블로그 Tech&(테크앤):티스토리](https://tech.kakaoenterprise.com/196)

<br />

**LangChain** 은 **프롬프트 체이닝** 을 지원하는 프레임워크 입니다.

LLM 과 외부의 프롬프트들을 자유롭게 연결할 수 있는 기능을 제공합니다.



<br />



### LLM 앱 개발 플렛폼

LLM 과 LangChain 을 사용하여 AI 앱을 만들 수 있는 플렛폼이 있습니다. (프롬프트 체이닝 서비스 플렛폼)

대표적으로 **LangFlow** 와 **FlowiseAI** 가 있습니다.

<br />

* LangFlow:
    * [LangFlow Github](https://github.com/logspace-ai/langflow)
    * 서버: `Python`
    * 프론트: `React(Typescript)`
* FlowiseAI
    * [FlowiseAI Github](https://github.com/FlowiseAI/Flowise)
    * 서버: `Express(Typescript)`
    * 프론트: `React(Javascript)`
15:T1d77,---
id: 1
title: Nextjs 프로젝트의 유닛 테스트
description: '유닛 테스트를 위해 Jest 와 @testing-library 설치 및 설정에 대한 정리 입니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'nextjs',
    'jest',
    '@testing-library',
    'react',
    '유닛 테스트',
]

createdAt: '2023-12-16 22:13:00'
modifiedHistories: []
---

# Nextjs 프로젝트의 유닛 테스트

* 참고: [Next.js with React Testing Library, Jest, and TypeScript](https://medium.com/readytowork-org/next-js-with-react-testing-library-jest-and-typescript-a6aa11b85434)
* 참고: [Nextjs 공식문서](https://nextjs.org/docs/pages/building-your-application/testing/jest)



<br />



<details>
<summary>유닛 테스트를 멀리한 핑계와 결심</summary>

<br />

스타트업에 재직하며 다양한 프로젝트를 개발하고 있습니다.

진행했던 프로젝트를 되돌아보면, 한결같이 시간이 부족하였고, 이를 핑계삼아 유닛 테스트 없이 기능 구현만을 하였습니다.

<br />

### 🤪 유닛 테스트 없이도 개발 가능한데?

테스트에 관한 블로그 글이나 **클린코드** 와 같은 책에서 언급한 **코드에 대한 신뢰도** 는 사실 체감을 하지 못하였습니다.

오히려 유닛 테스트 작성 때문에 기능 구현할 시간을 뺏긴다는 느낌이 컸고, 유닛 테스트 없이도 기능 개발은 충분히 가능했습니다.

<br />

### 😰 `console.log` 와 수작업 테스트 노가다...

기능 개발을 완료한 후, 기억이 흐릿해질 정도로 시간이 지나서 기능 추가/수정 작업이 생겼습니다.

기억을 상기하기 위해 여기 저기에 `console.log()` 를 작성하였고, 기능 추가 후에는 남아있는 `console.log()` 를 제거하는 귀찮은 작업들이 남게 되었습니다.

사실 함수명, 메소드명, 변수명 등이 모두 명확하고, 모든 코드가 서로 의존성 없이 독립적인 기능을 한다면 `console.log()` 로 확인하는 작업이 필요 없을 수 있습니다.

하지만 기능이 언제나 단순 명료하게 구현될 수 없고, 더더욱 이 코드를 작성한 저의 코드 품질에 부족함이 많기 때문에 `console.log()` 노가다와 함께할 가능성이 보였습니다.

**그리고 가장 큰 문제는, 변경된 기능이 다른 부분에 영향을 미치는지, 버그를 찾기위한 반복된 수작업 테스트를 하게 되었습니다.**

기능을 추가하는 코드 베이스가 클 수록, 수작업 테스트는 상당한 시간을 소비하게 하였습니다.

<br />

### 🤓 유닛 테스트를 사용한 테스트 자동화가 필요해!

만약 유닛 테스트를 작성해 두었다면, 아래와 같은 보상이 있었다고 생각됩니다.

* 현재 코드가 테스트에 통과하고 있으므로, 적어도 작성된 **Test Case** 내에서는 신뢰할 수 있는 코드다.
* 테스트 대상이 지원하는 모든 기능과 `porps` 에 대하여, 독립적인 **Use Case** 를 확인할 수 있다.
* **수정한 코드가 의도한 부분에만 적용됨을 보장 받을 수 있다.**

<br />

위와 같은 기대값을 가지며, **유닛 테스트에 대한 결심** 을 하게 되었습니다.

</details>



<br />



## 유닛 테스트 라이브러리 설치

유닛 테스트를 위해, `jest` 와 `@testing-library` 를 사용하고자 합니다.

```bash title="jest 관련 패키지"
yarn add -D jest ts-jest ts-node jest-environment-jsdom @types/jest
```

```bash title="@testing-library 관련 패키지"
yarn add -D @testing-library/jest-dom @testing-library/react @testing-library/user-event
```


<br />



## jest 실행을 위한 명령어 추가하기

`package.json` 의 `scripts` 를 통해 프로젝트에 대한 명령어를 추가할 수 있습니다.

단발성 테스트를 위한 명령어와 코드 변경마다 테스트를 실행하는 명령어를 추가합니다.

```json title="package.json" {5-7}
{
    // ...
    "scripts": {
        // ...
        "test": "jest",
        "test:watch": "jest --watch",
        "test:watchAll": "jest --watchAll"
    },
    // ...
}
```



<br />



## jest 설정하기

[Nextjs 공식 문서](https://nextjs.org/docs/pages/building-your-application/testing/jest#manual-setup) 에서도 **jest** 와 **@testing-library** 를 사용하는 방법에 대해 안내하고 있습니다.

<br />

**jest.config.ts** 파일을 사용하여 설정할 수 있습니다.

직접 파일을 생성하지 않고, CLI 를 통해 설정 템플릿을 생성하여 수정하는 방향으로 설정하겠습니다.

터미널에서 아래의 명령을 실행합니다.

```bash title="npm 으로 jest.config.ts 생성하기"
npm init jest@latest
```

```bash title="yarn 으로 jest.config.ts 생성하기"
yarn create jest@latest
```

<br />

명령을 실행하면, 몇가지 질문(Y/N)으로 기본 설정값이 반영된 **jest.config.ts** 파일이 생성됩니다.

생성된 **jest.config.ts** 를 아래와 같이 수정합니다.

```typescript showLineNumbers
import {
    Config,
} from 'jest';
import nextJest from 'next/jest.js';

const createJestConfig = nextJest({
    dir: './',
});

/**
 * For a detailed explanation regarding each configuration property, visit:
 * https://jestjs.io/docs/configuration
 */

const config: Config = {
    // The directory where Jest should output its coverage files
    coverageDirectory: "coverage",

    // Indicates which provider should be used to instrument code for coverage
    coverageProvider: "babel",

    // A preset that is used as a base for Jest's configuration
    preset: "ts-jest",

    // A list of paths to modules that run some code to configure or set up the testing framework before each test
    setupFilesAfterEnv: ["<rootDir>/jest.setup.ts"],

    // The test environment that will be used for testing
    testEnvironment: "jest-environment-jsdom",
};

export default createJestConfig(config);
```

<br />

`jest.config.ts` 파일의 **26번줄** 에서 설정한 **jest.setup.ts** 파일을 생성하고 아래의 코드를 작성합니다.

```typescript title="jest.setup.ts"
import '@testing-library/jest-dom';
```

**jest.setup.ts** 에서 `import` 하는 모듈은 **@testing-library** 에서 제공하는 **확장 matcher** 를 사용할 수 있게 해줍니다.

이로써 Nextjs 의 유닛 테스트 설정을 완료 하였습니다.



<br />



## 첫번째 컴포넌트 테스트 만들기

먼저 테스트를 할 React 컴포넌트를 만들겠습니다.

```tsx title="Hello.tsx"
function Hello() {
    return (
        <h1>
            Hello World
        </h1>
    );
}

export default Hello;
```

<br />

*Hello.tsx* 와 동일한 경로에 **Hello.spec.tsx** 파일을 생성하고, 유닛 테스트를 작성합니다.

```typescript title="Hello.spec.tsx"
import Hello from './Hello';
import {
    render,
    screen,
} from '@testing-library/react';

describe('<Hello /> 컴포넌트 유닛 테스트', () => {
    it('Dom 에 렌더링 됨', () => {
        render(<Hello />);

        const $hello = screen.getByRole('heading', {
            level: 1,
        });

        expect($hello).toBeInTheDocument();
    });
});
```

<br />

유닛 테스트를 작성한 후, 터미널에 아래의 명령어로 테스트를 실행할 수 있으며, 모든 테스트가 통과됨을 확인할 수 있습니다.

```bash title="jest 실행하기"
yarn test
```
16:T2361,---
id: 1
title: Custom Hook 으로 분리하며 발생한 실수
description: 'Custom Hook 으로 분리한 useEffect 가 여러번 호출 케이스 중 한가지를 정리합니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'react',
    'custom hook',
]

createdAt: '2023-12-19 22:50:00'
modifiedHistories: []
---

# Custom Hook 으로 분리하며 발생한 실수

## 실수가 발생한 상황

페이지가 mount 되면 API 를 호출하는 흐름은 빈번히 사용됩니다.

그리고 API 응답을 받으면, 후처리를 하는 `useEffect` 를 사용할 수 있습니다.

<br />

이번 이슈에서는 Custom Hook 으로 나누기 전까지는 의도한 대로 API 응답과 Effect 가 1:1 로 실행되었습니다.

```tsx title="MyPage.tsx" showLineNumbers {28-30, 32-34}
import {
    useCallback,
    useEffect,
} from 'react';
import {
    useAppSelector,
} from '@/redux/hooks';

function MyPage() {
    const triggerState = useAppSelector(({ triggerState }) => triggerState);

    const responseOfApi_1 = useAppSelector(({ api_1 }) => api_1);
    const responseOfApi_2 = useAppSelector(({ api_2 }) => api_2);

    const callApi_1 = useCallback(() => {
        // API 호출 1
    }, []);

    const callApi_2 = useCallback(() => {
        // API 호출 2
    }, []);

    useEffect(function handleTriggerState() {
        callApi_1();
        callApi_2();
    }, [triggerState]);

    useEffect(function onSuccessApi_1() {
        // API 1 응답 후처리
    }, [responseOfApi_1]);

    useEffect(function onSuccessApi_2() {
        // API 2 응답 후처리
    }, [responseOfApi_2]);

    return (
        // ...
    );
}

export default MyPage;
```

<br />

이런 방식으로 **호출하는 API 가 늘어나자, 컴포넌트가 점점 복잡해졌습니다.**

**또한 사용자 인터렉션에 의해 다시 호출해야 하는 API 도 있어서** Custom Hook 으로 분리하여 재사용하는 방향으로 생각하게 되었습니다.

<br />

리펙토링 결과, API 후처리를 담당하는 `useEffect` 가 번복 실행되는 현상이 나타났습니다.

```tsx title="./hooks/useApi_1.ts" showLineNumbers {16-18}
import {
    useCallback,
    useEffect,
} from 'react';
import {
    useAppSelector
} from '@/redux/hooks';

const useApi_1 = () => {
    const responseOfApi_1 = useAppSelector(({ api_1 }) => api_1);

    const callApi_1 = useCallback(() => {
        // API 호출 1
    }, []);

    useEffect(function onSuccessApi_1() {
        // (번복 실행됨) API 1 응답 후처리
    }, [responseOfApi_1]);

    return {
        callApi_1,
    };
};

export default useApi_1;
```

```tsx title="./hooks/useApi_2.ts" showLineNumbers {16-18}
import {
    useCallback,
    useEffect,
} from 'react';
import {
    useAppSelector
} from '@/redux/hooks';

const useApi_2 = () => {
    const responseOfApi_2 = useAppSelector(({ api_2 }) => api_2);

    const callApi_2 = useCallback(() => {
        // API 호출 2
    }, []);

    useEffect(function onSuccessApi_2() {
        // (번복 실행됨) API 2 응답 후처리
    }, [responseOfApi_2]);

    return {
        callApi_2,
    };
};

export default useApi_2;
```

```tsx title="MyPage.tsx" showLineNumbers {10-11, 13-16}
import {
    useEffect,
} from 'react';
import useApi_1 from './hooks/useApi_1';
import useApi_2 from './hooks/useApi_2';

function MyPage() {
    const triggerState = useAppSelector(({ triggerState }) => triggerState);

    const { callApi_1 } = useApi_1();
    const { callApi_2 } = useApi_2();

    useEffect(function onSuccessApi_2() {
        callApi_1();
        callApi_2();
    }, [triggerState]);

    return (
        // ...
    );
};

export default MyPage;
```



<br />



## useEffect 의 dependencies 는 무죄

`useEffect` 의 `dependencies` 는 redux 에서 가져온 state 였습니다.

(위의 예시 코드에서는 `triggerState` 로 표현하였습니다.)

**`triggerState` 에 의도치 않은 mutate 가 발생하는 것인가** 라고 생각했지만, 이는 아니였습니다.



<br />



## Custom Hook 을 재사용한 만큼 번복되는 useEffect

Custom Hook 으로 분리하는 단위를 **특정 API 호출 함수** 와 **해당 API 응답 후처리 Effect** 로 묶어서 구성하였습니다.

그리고 필요한 곳에서 재사용을 하였습니다.

<br />

결과적으로 재사용한 횟수만큼 `useEffect` 가 번복 실행된 것입니다.

Custom Hook 은 사용하는 곳에 scope 를 만드는 것이므로, 당연한 결과임에도 알아차리지 못하였습니다.



<br />



## API 호출함수와 Effect 를 분리한 Custom Hook 으로 이슈 해결

원인을 찾은 후, API 의 후처리를 담당하는 `useEffect` 를 Custom Hook 에서 빼고, 기존의 `MyPage` 에 위치시켰습니다.

그러자 번복되는 `useEffect` 이슈는 해결 되었습니다.


```tsx title="./hooks/useApi_1.ts" showLineNumbers {15-17}
import {
    useCallback,
} from 'react';
import {
    useAppSelector
} from '@/redux/hooks';

const useApi_1 = () => {
    const responseOfApi_1 = useAppSelector(({ api_1 }) => api_1);

    const callApi_1 = useCallback(() => {
        // API 호출 1
    }, []);

    // useEffect(function onSuccessApi_1() {
    //     // API 1 응답 후처리
    // }, [responseOfApi_1]);

    return {
        callApi_1,
    };
};

export default useApi_1;
```

```tsx title="./hooks/useApi_2.ts" showLineNumbers {15-17}
import {
    useCallback,
} from 'react';
import {
    useAppSelector
} from '@/redux/hooks';

const useApi_2 = () => {
    const responseOfApi_2 = useAppSelector(({ api_2 }) => api_2);

    const callApi_2 = useCallback(() => {
        // API 호출 2
    }, []);

    // useEffect(function onSuccessApi_2() {
    //     // API 2 응답 후처리
    // }, [responseOfApi_2]);

    return {
        callApi_2,
    };
};

export default useApi_2;
```

```tsx title="MyPage.tsx" showLineNumbers {20-22, 24-26}
import {
    useEffect,
} from 'react';
import useApi_1 from './hooks/useApi_1';
import useApi_2 from './hooks/useApi_2';

function MyPage() {
    const triggerState = useAppSelector(({ triggerState }) => triggerState);

    const { callApi_1 } = useApi_1();
    const { callApi_2 } = useApi_2();

    useEffect(function onSuccessApi_2() {
        callApi_1();
        callApi_2();

        // eslint-disable-next-line
    }, [triggerState]);

    useEffect(function onSuccessApi_1() {
        // API 1 응답 후처리
    }, [responseOfApi_1]);

    useEffect(function onSuccessApi_2() {
        // API 2 응답 후처리
    }, [responseOfApi_2]);

    return (
        // ...
    );
};

export default MyPage;
```



<br />



## MyPage 에서 API 후처리를 담당하는 useEffect 분리

위 코드처럼 리펙토링한 이후, 의도한 동작은 되었습니다.

하지만, **MyPage.tsx 파일을 열어보기 전까지는 API 후처리를 어디서 하는지 파악하기가 어렵다고 느껴졌습니다.**

<br />

그래서 MyPage.tsx 의 **API 후처리 Effect 들을 Custom Hook 으로** 나눠보기로 하였습니다.

```ts title="./hooks/useMyPageApiEffects.ts" showLineNumbers {9-11, 13-15}
import {
    useEffect,
} from 'react';

const useMyPageApiEffects = () => {
    const responseOfApi_1 = useAppSelector(({ api_1 }) => api_1);
    const responseOfApi_2 = useAppSelector(({ api_2 }) => api_2);

    useEffect(function onSuccessApi_1() {
        // API 1 응답 후처리
    }, [responseOfApi_1]);

    useEffect(function onSuccessApi_2() {
        // API 2 응답 후처리
    }, [responseOfApi_2]);
}

export default useMyPageApiEffects;
```

```tsx title="MyPage.tsx" showLineNumbers {13}
import {
    useEffect,
} from 'react';
import useApi_1 from './hooks/useApi_1';
import useApi_2 from './hooks/useApi_2';
import useMyPageApiEffects from './hooks/useMyPageApiEffects';

function MyPage() {
    const triggerState = useAppSelector(({ triggerState }) => triggerState);

    const { callApi_1 } = useApi_1();
    const { callApi_2 } = useApi_2();
    useMyPagteApiEffects();

    useEffect(function onSuccessApi_2() {
        callApi_1();
        callApi_2();
    }, [triggerState]);

    return (
        // ...
    );
};

export default MyPage;
```



<br />



## 마치며

여기까지 수정한 결과, MyPage.tsx 에서 API 에 대한 후처리 Effect 가 있다는 것을 파일 목록을 통해서도 파악할 수 있게 되었습니다.

개인적으로는 위와 같은 구조의 Custom Hook 이 마음에 들었습니다.

이렇게 분리한 Custom Hook 은 아래와 같은 파일 구조가 되었습니다.

```bash
└── MyPage
    ├── MyPage.tsx
    └── hooks
        ├── useApi_1.ts
        ├── useApi_2.ts
        └── useMyPageApiEffects.ts
``` 

<br />

사소한 실수에 의한 이슈라서 자책 포인트가 되었지만, Custom Hook 으로 분리하는 구조를 생각할 수 있는 계기가 되어서 성취감이 느껴졌습니다.
17:T1f1c,---
id: 7
title: 모델 파일을 Three.js 에 렌더링하기
description: '.gltf 또는 .glb 확장자인 모델 파일을 Three.js 에 불러오고 렌더링하는 방법을 정리합니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'threejs',
    'javascript',
    '3d',
    'hdr',
    '.gltf',
    '.glb',
    'model',
]

createdAt: '2024-01-10 23:50:00'
modifiedHistories: []
---

# 모델 파일을 Three.js 에 렌더링하기

3D 모델 파일의 확장자는 아래와 같습니다.

* .gltf
    * 3D 모델 파일이며 JSON 형식의 데이터입니다.
* .glb
    * 3D 모델 파일이며 Binary 데이터입니다.
    * **3D 모델을 렌더링하여 사용할 목적이라면, .glb 파일의 용량이 더 적으므로 적합합니다.**

<br />

이번 포스팅에서는 3D 모델 파일을 Three.js 에 렌더링하는 방법과 불러온 모델 객체를 수정하는 방법에 대해 정리하고자 합니다.



<br />



## 용어 정리

### Luminance

Luminance 는 **휘도** 라는 뜻을 가집니다.

Three.js 에서는 **emissive** 가 **빛을 방출하는 정도에 대한 속성** 이지만, 3D Tool 중 Cinema4D 에서는 **Luminance** 로 표기되어 있습니다.



<br />



## 예시 코드

이번 포스팅에서 사용할 예시 코드는 다음과 같습니다.

```js title="예시 코드" showLineNumbers
import {
    WebGLRenderer,
    Scene,
    PerspectiveCamera,

    Color,
    DirectionalLight,
    HemisphereLight,

    SphereGeometry,
    MeshStandardMaterial,
    Mesh,
} from 'three';
import {
    OrbitControls,
} from 'three/examples/jsm/controls/OrbitControls';
import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { Scene } */
let scene;

/** @type { PerspectiveCamera } */
let camera;

/** @type { OrbitControls } */
let controls;

//
// core
//
function initCanvas() {
    const $canvas = document.createElement('canvas');
    $canvas.width = window.innerWidth;
    $canvas.height = window.innerHeight;

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    return $canvas;
}

function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });

    renderer.shadowMap.enabled = true;
}

function initScene() {
    scene = new Scene();
}

function initCamera() {
    camera = new PerspectiveCamera();
    camera.fov = 35;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.position.set(0, 0, 2);

    camera.updateProjectionMatrix();
}

function initControls($emitter) {
    controls = new OrbitControls(camera, $emitter);
    controls.enableDamping = true;
}

//
// light
//
function initDirectionalLight() {
    const color = new Color('#fff');

    const light = new DirectionalLight(color);
    light.position.set(1, 1, 1);
    light.castShadow = true;

    scene.add(light);
}

function initHemisphereLight() {
    const skyColor = new Color('#fff');
    const groundColor = new Color('#000');

    const light = new HemisphereLight(
        skyColor,
        groundColor,
        0.25
    );

    scene.add(light);
}

//
// mesh
//
function initSphereMesh() {
    const geometry = new SphereGeometry();
    const material = new MeshStandardMaterial();
    const sphere = new Mesh(geometry, material);

    scene.add(sphere);
}

//
// executor
//
function render() {
    window.requestAnimationFrame(render);

    renderer.render(scene, camera);
    controls.update();
}

function init() {
    const $canvas = initCanvas();

    initRenderer($canvas);
    initScene();
    initCamera();
    initControls($canvas);

    initDirectionalLight();
    initHemisphereLight();

    initSphereMesh();

    render();
}

init();
```



<br />



## GLTFLoader 를 사용하여 3D 모델 파일 불러오기

.glb 또는 .gltf 파일을 불러오기 위해서는 Loader 가 필요합니다.

이 때 사용하는 Loader 는 GLTFLoader 인스턴스 입니다.

아래는 .gltf 파일을 불러온 후, 불러온 모델 객체를 `console.log()` 로 출력하고 있습니다.

```js title="GLTFLoader import 하기" showLineNumbers{17}
import {
    GLTFLoader,
} from 'three/examples/jsm/loaders/GLTFLoader';
```

```js title="GLTFLoader 로 .gltf 파일 불러오기" showLineNumbers{112}
function initRubberDuck() {
    const loader = new GLTFLoader();
    loader.load('/gltf/rubberDuck/rubber_duck_toy_4k.gltf', gltf => {
        console.group('onLoad()');
        console.log('gltf: ', gltf);
        console.groupEnd();
    });
}
```

```js title="iniRubberDuct 함수 호출" showLineNumbers{131} {13}
function init() {
    const $canvas = initCanvas();

    initRenderer($canvas);
    initScene();
    initCamera();
    initControls($canvas);

    initDirectionalLight();
    initHemisphereLight();

    initSphereMesh();
    initRubberDuck();

    render();
}
```

<br />

부라우저 콘솔에서 확인하면, GLTFLoader 가 불러온 3D 모델 객체를 확인할 수 있습니다.



## 불러온 3D 모델 객체 렌더링하기

불러온 3D 모델 객체에는 **scene 속성** 이 있습니다.

**scene 속성** 을 Mesh 와 동일하게 취급할 수 있습니다.

따라서 기존의 sphere Mesh 를 `scene.add()` 메서드로 추가했던 것과 동일한 방법으로 `scene` 에 추가할 수 있습니다.

```js title="3D 모델 객체 렌더링" showLineNumbers{112} {8-9}
function initRubberDuck() {
    const loader = new GLTFLoader();
    loader.load('/gltf/rubberDuck/rubber_duck_toy_4k.gltf', gltf => {
        console.group('onLoad()');
        console.log('gltf: ', gltf);
        console.groupEnd();

        gltf.scene.position.set(0, -0.15, 0);
        scene.add(gltf.scene);
    });
}
```

<img src="/markdownAssets/threejs/2024-01-10-01/2024-01-10-01-01.png" alt="3D 모델 렌더링" />



<br />



## 추가: 불렁론 3D 모델이 깨지는 현상

3D 모델을 Three.js 에 렌더링했을 때, 깨지는 현상이 발생할 수 있습니다.

이는 3D Tool(예: Cinema4D, Blender) 를 사용하여, 모델의 **Material** 을 수정하여 해결할 수 있습니다.

가장 유력한 케이스는 **Material** 설정 중, **Alpha** 설정이 활성화된 경우 입니다.

만약 **Alpha** 설정이 활성화되어 있었다면, 해제 후 export 한 파일을 사용해봅니다.

<br />

Three.js 는 브라우저 환경에서 동작하기 때문에 3D Tool 의 무거운 기능들은 지원하지 않습니다.

이러한 현상이 나타난다면, **Material** 을 좀 더 가볍게 하면 해소할 수 있습니다.



<br />



## 3D 모델 객체 구조 살펴보기

Three.js 에 불러온 3D 모델을 그대로 렌더링했을 때, 원하는 결과를 얻지 못할 가능성이 큽니다.

특히 그림자 설정은 3D 모델을 개발할 때 설정하는 것이 아닌, Three.js 에 렌더링할 객체의 설정이 필요한 경우입니다.

이러한 이유로 Three.js 에 불러온 3D 모델 객체의 주요 속성들을 수정하기 위해, 먼저 속성들을 살펴보겠습니다.

<br />

GLTFLoader 로 불러운 3D 모델을 gltf 로 칭하겠습니다.

gltf 객체는 크게 다음과 같은 속성이 있습니다.

* scene
    * Mesh 처럼 다룰 수 있으며, 렌더링할 때도 사용합니다.
* animations
    * 애니메이션 객체 입니다.
* children
    * 3D Tool 로 개발할 때 만든 부모-자식 계층 입니다.
* material
    * 현재 Mesh 의 Material 설정입니다.

<br />

gltf 객체의 scene 과 children 의 중첩구조를 살펴보면 크게 2가지 타입으로 이루어져 있습니다.

* Mesh
    * 실제 Mesh 객체입니다.
* Object3D
    * Mesh 가 아닌 기타 타입입니다.
    * 3D Tool 의 Symmetry(대칭복사), Subdivision(곡선생성) 등의 기능으로 만든 부분 (엄밀히 Mesh 는 아니기 때문)



<br />



## 3D 모델 객체 수정하기
18:T3408,---
id: 6
title: 배경화면 및 환경조명 설정하기
description: '360도 이미지 확장자인 .hdr 파일을 사용하여 배경화면을 설정하고, 배경화면에 의한 환경조명 설정에 대한 정리입니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'threejs',
    'javascript',
    '3d',
    'hdr',
    'background',
    '3D 배경화면',
    '환경조명',
]

createdAt: '2024-01-08 23:50:00'
modifiedHistories: []
---

# 배경화면 및 환경조명 설정하기

지금까지는 배경이 없는 환경에서 물체를 렌더링하였습니다.

3D 환경에서 배경화면을 설정하기 위해 360도 이미지 파일인 **.hdr (Hign Dynamic Range)** 파일을 설정해 보고자 합니다.

<br />

추가로 배경화면이 물체에 반사되는 환경조명까지 설정해 보겠습니다.

환경조명을 설정하게 되면, 배경이 스틸에 반사되는 효과를 연출할 수 있습니다.

이를 위해 **Material** 설정 방법에 대해서도 정리합니다.



<br />



## 예시 코드

이번 포스팅에서 사용할 예시 코드는 다음과 같습니다.

```js title="예시 코드" showLineNumbers
import {
    WebGLRenderer,
    Scene,
    PerspectiveCamera,

    Color,

    DirectionalLight,
    DirectionalLightHelper,
    HemisphereLight,
    HemisphereLightHelper,

    Mesh,
    MeshStandardMaterial,

    SphereGeometry,
    PlaneGeometry,

    VSMShadowMap,
} from 'three';
import {
    OrbitControls,
} from 'three/examples/jsm/controls/OrbitControls';

import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { Scene } */
let scene;

/** @type { PerspectiveCamera } */
let camera;

/** @type { OrbitControls } */
let controls;

//
// core
//
function initCanvas() {
    const $canvas = document.createElement('canvas');
    $canvas.width = window.innerWidth;
    $canvas.height = window.innerHeight;

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    return $canvas;
}

function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });

    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = VSMShadowMap;
}

function initScene() {
    scene = new Scene();
}

function initCamera() {
    camera = new PerspectiveCamera();
    camera.fov = 75;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.position.set(-3, 3, 5);

    camera.updateProjectionMatrix();
}

function initControls($canvas) {
    controls = new OrbitControls(camera, $canvas);
    controls.enableDamping = true;
}

//
// light
//
function initDirectionalLight() {
    const color = new Color('#fff');

    const light = new DirectionalLight(
        color,
        0.75
    );
    light.position.set(1, 1, 1);
    light.castShadow = true;
    light.shadow.blurSamples = 30;
    light.shadow.radius = 12;

    const helper = new DirectionalLightHelper(light);

    scene.add(light);
    scene.add(helper);
}

function initHemisphereLight() {
    const skyColor = new Color('#fff');
    const groundColor = new Color('#000');

    const light = new HemisphereLight(
        skyColor,
        groundColor,
        0.25
    );

    const helper = new HemisphereLightHelper(light);

    scene.add(light);
    scene.add(helper);
}

//
// mesh
//
function initSphereMesh() {
    const geometry = new SphereGeometry();
    const material = new MeshStandardMaterial();
    const sphere = new Mesh(geometry, material);
    sphere.castShadow = true;

    scene.add(sphere);
}

function initPlaneMesh() {
    const geometry = new PlaneGeometry(10, 10);
    const material = new MeshStandardMaterial();
    const plane = new Mesh(geometry, material);
    plane.position.set(0, -1, 0);
    plane.rotation.set(Math.PI / -2, 0, 0);
    plane.receiveShadow = true;

    scene.add(plane);
}

//
// executor
//
function render() {
    window.requestAnimationFrame(render);

    controls.update();
    renderer.render(scene, camera);
}

(function init() {
    const $canvas = initCanvas();
    initRenderer($canvas);
    initScene();
    initCamera();
    initControls($canvas);

    initDirectionalLight();
    initHemisphereLight();

    initSphereMesh();
    initPlaneMesh();

    render();

    console.log('init()');
}());
```



<br />



## **.hdr** 파일이란?

Three.js 는 3D 환경입니다.

배경화면을 설정하려면 일반적인 2D 이미지를 사용해서는 연출할 수 없습니다.

**.hdr (High Dynamic Range)** 확장자를 가진 파일은 360도 이미지 파일이며, 이 파일을 사용하여 3D 환경에 배경화면을 설정할 수 있습니다.

<br />

360도 배경화면은 아래의 플렛폼에서 오픈소스로 다운로드할 수 있습니다.

* [polyhaven.com](https://polyhaven.com/hdris)



<br />



## 용어 정리

이번 포스팅에서 사용하게될 컴퓨터 그래픽스 용어에 대해 간단하게 정리하고 가겠습니다.

### Vertex

3D 공간에서 가장 작은 단위인 **점** 을 말합니다.

### Edge

2개의 Vertex 를 연결하여 생성된 **선** 을 말합니다.

### Polygon

복수의 Edge 를 연결하여 만들어진 **면** 을 말합니다.

가장 작은 Polygon 은 3개의 Edge 로 만들 수 있는 삼각형 입니다.

### Mesh

복수의 Polygon 으로 만들 수 있는 다각형으로, 지금까지 사용해보았던 Sphere, Box, Plane 등을 말합니다.

### Texture

[참고: 나무위키](https://namu.wiki/w/%ED%85%8D%EC%8A%A4%EC%B2%98)

3D 물체의 표면에 2D 이미지를 입혀서 렌더링 하는 방식을 말합니다.

Mesh 를 구성하는 Polygon 이 많을수록 성능을 많이 사용하게 되는데, 이를 해소하기 위해 Mesh 의 표면에 2D 이미지를 입히는 방식의 렌더링 요소 입니다.

### emissive

emission 은 **(빛)방사** 라는 뜻을 가집니다.

컴퓨터 그래픽스에서 **emissive** 라는 용어를 사용하는데, 이는 Mesh 가 광원이 되여 빛을 방출한다는 것을 말합니다.

### (영단어) equirectangular

정사각형

### (영단어) reflection

반사

### (영단어) refraction

굴절



<br />



## RGBELoader 를 사용하여 .hdr 파일을 Texture 로 만들기

3D 공간 자체를 하나의 Mesh 라고 가정해 보겠습니다.

Three.js 에서는 `Scene` 객체가 배경의 역할을 하고 있습니다.

배경화면을 설정하기 위해서는 `Scene` 의 `background` 에 `Texture` 를 입혀서 표현할 수 있습니다.

<br />

Three.js 는 다양한 **DataTextureLoader** 를 제공하는데, Loader 를 사용하면 360도 이미지인 `.hdr` 파일을 읽어서 `Texture` 객체로 만들 수 있습니다.

생성한 `Texture` 를 `Scene` 의 `background` 로 입혀주는 것으로 배경화면을 설정할 수 있습니다.

[Three.js 공식문서 - DataTextureLoader](https://threejs.org/docs/#api/en/loaders/DataTextureLoader)

<br />

```js title="import 하기" showLineNumbers {21, 27}
import {
    WebGLRenderer,
    Scene,
    PerspectiveCamera,

    Color,

    DirectionalLight,
    DirectionalLightHelper,
    HemisphereLight,
    HemisphereLightHelper,

    Mesh,
    MeshStandardMaterial,

    SphereGeometry,
    PlaneGeometry,

    VSMShadowMap,

    EquirectangularReflectionMapping,
} from 'three';
import {
    OrbitControls,
} from 'three/examples/jsm/controls/OrbitControls';
import {
    RGBELoader,
} from 'three/examples/jsm/loaders/RGBELoader';
```

```js title="Scene 에 배경화면 설정하기" showLineNumbers{68} {4-9}
function initScene() {
    scene = new Scene();

    const loader = new RGBELoader();
    loader.load('/hrd/background.hdr', texture => {
        texture.mapping = EquirectangularReflectionMapping;

        scene.background = texture;
    });
}
```

<br />

먼저 import 부분을 살펴보겠습니다.

**EquirectangularReflectionMapping** 은 Texture 의 mapping 방식을 제공하는 **객체** 입니다.

Texture 객체의 `mapping` 속성에 **EquirectangularReflectionMapping** 객체를 대입하는 것으로 mapping 방식을 설정하게 됩니다.

<br />

Three.js 에서 제공하는 Texture mapping 방식은 여러가지가 있습니다.

[Three.js 공식문서 - Texture Constants](https://threejs.org/docs/index.html?q=texture#api/en/constants/Textures)

* UVMapping (default)
* CubeReflectionMapping 
* CubeRefractionMapping
* EquirectangularReflectionMapping
* EquirectangularRefractionMapping 
* CubeUVReflectionMapping

<br />

위에서 사용한 **EquirectangularReflectionMapping** 은 **environment map** 에 사용하는 Texture mapping 방식 입니다.

이 mapping 방식을 사용하게 되면 `.hdr` 이미지가 마치 배경처럼 렌더링됩니다.

<br />

Texture 의 mapping 방식을 설정해준 뒤, **Scene** 의 `background` 속성에 Texture 를 대입하면 배경화면이 렌더링된 것을 볼 수 있습니다.

<img src="/markdownAssets/threejs/2024-01-08-01/2024-01-08-01-01.png" alt="배경화면 설정" />



<br />



## 환경조명 설정

빛이 있어야 물체가 렌더링 됩니다.

지금까지는 DirectionalLight 나 HemisphereLight 처럼 조명 객체를 생성하여 빛을 만들었습니다.

이번에는 조명을 모두 제거하고, 환경조명으로 렌더링하고자 합니다.

<br />

**Scene** 의 `environment` 속성에 환경조명으로 사용할 Texture 를 대입하여 설정할 수 있습니다.

`background` 로 사용했던 Texture 를 환경조명으로도 사용하도록 해보겠습니다.

```js title="환경조명 설정하기" showLineNumbers{68} {9}
function initScene() {
    scene = new Scene();

    const loader = new RGBELoader();
    loader.load('/hdr/background.hdr', texture => {
        texture.mapping = EquirectangularReflectionMapping;

        scene.background = texture;
        scene.environment = texture;
    });
}
```

<img src="/markdownAssets/threejs/2024-01-08-01/2024-01-08-01-02.png" alt="환경조명 설정하기" />

<br />

환경조명으로 설정한 Texture 의 밝은 부분과 어두운 부분이 조명의 세기로 적용되어 배경화면과 자연스러운 연출이 됩니다.



<br />



## 배경화면을 반사하는 Mesh 만들기

Sphere 와 Plane Mesh 를 렌더링하고 있습니다.

현재는 각 Mesh 에 설정한 **MeshStandardMaterial** 색상 그대로 렌더링되는 상태입니다.

이번에는 Mesh 의 Material 에 설정을 추가하여, 배경화면이 Mesh 에 비추어지는 효과를 연출해 보겠습니다.

<br />

Mesh 의 외관은 Material 에 의해 렌더링 결과가 달라집니다.

Material 은 Mesh 의 색상이나 질감을 표현하는 객체입니다.

배경화면을 반사하는 Mesh 를 만들기 위해서는 Material 설정을 사용하여 구현할 수 있습니다.

```js title="배경화면을 반사하는 Mesh 설정하기" showLineNumbers{134} {3-8}
function initSphereMesh() {
    const geometry = new SphereGeometry();
    const material = new MeshStandardMaterial({
        color: new Color('#fff'),
        roughness: 0,
        metalness: 1,
        // emissive: Color('#000'),
    });
    const sphere = new Mesh(geometry, material);
    sphere.castShadow = true;

    scene.add(sphere);
}
```

<img src="/markdownAssets/threejs/2024-01-08-01/2024-01-08-01-03.png" alt="Material 설정" />

<br />

**MeshStandardMaterial** 생성자 params 를 사용하여 Material 를 설정하고 있습니다.

params 의 각 속성은 다음고 같은 설정을 가집니다.

* `color`: 
    * Material 자체의 색상입니다. (Mesh 의 색상이 됩니다.)
* `roughness`: 
    * 배경화면을 반사하는 Mesh 의 질감을 얼만큼 거칠게 표현할지에 대한 설정입니다.
    * `0` 설정 시, 배경화면이 깔끔하게 반사됩니다.
    * `1` 설정 시, 반사되는 배경화면이 분간하기 어려울 정도로 어글어져서 렌더링됩니다.
* `metalness`:
    * 매탈 재질처럼 보이는 정도를 설정합니다.
    * `0` 설정 시, 메탈 느낌 보다는 플라스틱 느낌이 강하며, 함께 설정한 `color` 의 비중이 더 크게 렌더링됩니다.
    * `1` 설정 시, 함께 설정한 `color` 는 거의 보이지 않고, 메탈 느낌으로 렌더링됩니다.
* `emissive`:
    * Mesh(Material) 이 방출하는 빛의 색상을 설정합니다.
    * `밝은색` 설정 시, 광원처럼 밝은 빛을 내며, 자신의 그림자가 거의 생기지 않습니다.
    * `어두운색` 설정 시, 발광하는 빛이 거의 없으며, 자신의 그림자가 비교적 선명하게 생깁니다.
    * 일반적으로 활용도가 떨어지는 설정이라서, 잘 사용하지 않습니다.



<br />



## 마치며

Material 설정을 통해 배경화면을 반사하는 효과를 연출해 보았습니다.

이번에 사용한 반사효과는 배경화면만을 반사하고, Mesh 간의 반사는 렌더링되지 않습니다.

**Post Processing** 기능을 사용하면, 거울처럼 다른 Mesh 와 상호작용하며 반사하는 연출이 가능해집니다.

이 부분은 차후 정리할 예정입니다.

[Three.js 공식문서 - 거울효과 예시](https://threejs.org/examples/?q=mirror#webgl_mirror)
19:T2c06,---
id: 5
title: 그림자 표현하기
description: '그림자 설정방법과 특징에 대해 정리합니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'threejs',
    'javascript',
    '3d',
    'shadow',
]

createdAt: '2024-01-07 23:50:00'
modifiedHistories: []
---

# 그림자 표현하기

그림자를 표현하기 위해서는 물체와 조명의 각도, 그림자의 크기, 형태 등의 상호작용 연산이 필요합니다.

그래서 Three.js 의 그림자 설정의 기본값은 모두 미사용으로 설정되어 있습니다.

이 덕분에 개발자가 원하는 조명과 원하는 물체의 그림자를 직접 지정하여 표현할 수 있습니다.



<br />



## 예시 코드

이전 포스팅에서 바닥(땅) 을 만들었던 코드에 그림자 설정을 추가해 보겠습니다.

```js title="예시 코드" showLineNumbers
import {
    WebGLRenderer,
    Scene,
    PerspectiveCamera,

    Mesh,
    MeshStandardMaterial,
    SphereGeometry,
    PlaneGeometry,

    Color,
    HemisphereLight,
    HemisphereLightHelper,
    DirectionalLight,
    DirectionalLightHelper,
} from 'three';
import {
    OrbitControls,
} from 'three/examples/jsm/controls/OrbitControls';
import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { Scene } */
let scene;

/** @type { PerspectiveCamera } */
let camera;

/** @type { OrbitControls } */
let controls;

function initCanvas() {
    const $canvas = document.createElement('canvas');
    $canvas.width = window.innerWidth;
    $canvas.height = window.innerHeight;

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    return $canvas;
}

function initScene() {
    scene = new Scene();
}

function initCamera() {
    camera = new PerspectiveCamera();
    camera.fov = 35;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.position.set(0, 0, 12);

    camera.updateProjectionMatrix();
}

function initControls($canvas) {
    controls = new OrbitControls(camera, $canvas);
    controls.enableDamping = true;
}

function initHemisphereLight() {
    const skyColor = new Color('#fff');
    const groundColor = new Color('#000');
    const light = new HemisphereLight(
        skyColor,
        groundColor,
        0.75
    );

    const helper = new HemisphereLightHelper(light);

    scene.add(light);
    scene.add(helper);
}

function initDirectionalLight() {
    const color = new Color('#fff');
    const light = new DirectionalLight(color);
    light.position.set(2, 2, 2);

    const helper = new DirectionalLightHelper(light);

    scene.add(light);
    scene.add(helper);
}

function initSphereMesh() {
    const geometry = new SphereGeometry();
    const material = new MeshStandardMaterial();
    const sphere = new Mesh(geometry, material);

    scene.add(sphere);
}

function initPlaneMesh() {
    const geometry = new PlaneGeometry(10, 10);
    const material = new MeshStandardMaterial();
    const plane = new Mesh(geometry, material);
    plane.position.set(0, -1, 0);
    plane.rotation.set(
        Math.PI * -0.5,
        0,
        0
    );

    scene.add(plane);
}

function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });
}

function render() {
    window.requestAnimationFrame(render);

    renderer.render(scene, camera);
    controls.update();
}

(function init() {
    const $canvas = initCanvas();
    initRenderer($canvas);
    initScene();
    initCamera();
    initControls($canvas);

    initHemisphereLight();
    initDirectionalLight();

    initSphereMesh();
    initPlaneMesh();

    render();
}());
```



<br />



## 그림자 종류

Three.js 에서 제공하는 그림자는 크게 2가지로 볼 수 있습니다.

* Hard Shadow: 선명하며 거친 그림자를 표현합니다.
* Soft Shadow: 부드러운 그림자를 표현합니다.

<br />

Soft Shadow 는 그림자에 Blur 를 적용하여 부드럽게 표현합니다.

주의할 점은 Blur 값을 크게 설정할수록 부드럽게 표현하지만, 사용자 PC 의 연산량이 커진다는 것 입니다.

<br />

Three.js 의 그림자 설정은 다음과 같은 과정으로 만들 수 있습니다.

1. Hard Shadow 설정하기
2. Soft Shadow 설정 추가하기



<br />



## 그림자 설정이 필요한 인스턴스들

그림자를 표현하려면 몇가지 설정을 함께 해주어야 합니다.

아래는 그림자 설정이 필요한 인스턴스들 입니다.

* WebGLRenderer 인스턴스
* Light 인스턴스
* Mesh 인스턴스



<br />



## WebGLRenderer 에 shadow 설정하기

WebGLRenderer 는 **ShadowMap** 이라는 메커니즘을 제공합니다.

지금은 컴퓨터 그래픽스에서 그림자를 표현하는 여러 알고리즘 중 한가지 라는 것 정도로 정리하고자 합니다.

* WebGLRenderer shadowMap 은 그림자를 이미지로 생성한 후, 그림자를 씌우는 방식으로 동작합니다.

<br />

아래 코드는 WebGLRenderer 가 그림자를 표현하도록 설정합니다.

```js title="WebGLRenderer 그림자 사용 설정" showLineNumbers{111} {7}
function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });

    renderer.shadowMap.enabled = true;
}
```



<br />



## Light 와 Mesh 의 그림자 설정 (Hard Shadow)

Light 와 Mesh 의 그림자 설정 속성은 동일한 인터페이스를 가집니다.

그림자 설정 속성은 크게 두가지가 있습니다.

* 그림자를 만들어내는 설정: `castShadow`
* 다른 Mesh 의 그림자를 받는 설정: `receiveShadow`

<br />

Light 가 비추는 빛은 다른 Mesh 에 의해 그림자를 생성하게 됩니다.

그러므로 Light 의 **castShadow** 를 `true` 로 설정해줍니다.

```js title="DirectionalLight shadow 설정" showLineNumbers{78} {5}
function initDirectionalLight() {
    const color = new Color('#fff');
    const light = new DirectionalLight(color);
    light.position.set(2, 2, 2);
    light.castShadow = true;

    const helper = new DirectionalLightHelper(light);

    scene.add(light);
    scene.add(helper);
}
```

<br />

빛에 의해 그림자를 만들어내는 Mesh 역시 그림자를 생성하므로, **caseShadow** 를 `true` 로 설정해줍니다.

```js title="Sphere Mesh shadow 설정" showLineNumbers{90} {5}
function initSphereMesh() {
    const geometry = new SphereGeometry();
    const material = new MeshStandardMaterial();
    const sphere = new Mesh(geometry, material);
    sphere.castShadow = true;

    scene.add(sphere);
}
```

<br />

바닥(땅) 을 표현한 Plane Mesh 는 다른 Mesh 의 그림자를 받게 되므로, **receiveShadow** 를 `true` 로 설정해줍니다.

```js title="Plane Mesh shadow 설정" showLineNumbers{99} {12}
function initPlaneMesh() {
    const geometry = new PlaneGeometry(10, 10);
    const material = new MeshStandardMaterial();
    const plane = new Mesh(geometry, material);
    plane.position.set(0, -1, 0);
    plane.rotation.set(
        Math.PI * -0.5,
        0,
        0
    );

    plane.receiveShadow = true;

    scene.add(plane);
}
```

<br />

<img src="/markdownAssets/threejs/2024-01-07-02/2024-01-07-02-01.png" alt="Hard Shadow" />

<br />

지금까지 설정하여 만들어낸 그림자는 **Hard Shadow** 입니다.

Blur 처리를 하지 않기 때문에 선명한 그림자가 그려지고, 곡선에서 픽셀이 보이는 특징이 있습니다.



<br />



## Soft Shadow 설정 추가하기

Hard Shadow 설정을 한 후, WebGLRenderer 의 `shadowMap.type` 을 `VSMShadowMap` 으로 설정하므로써 Soft Shadow 로 표현됩니다.

```js title="VSMShadowMap import 하기" showLineNumbers {16}
import {
    WebGLRenderer,
    Scene,
    PerspectiveCamera,

    Mesh,
    MeshStandardMaterial,
    SphereGeometry,
    PlaneGeometry,

    Color,
    HemisphereLight,
    HemisphereLightHelper,
    DirectionalLight,
    DirectionalLightHelper,
    VSMShadowMap,
} from 'three';
```

```js title="Soft Shadow" showLineNumbers{116} {8}
function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });

    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = VSMShadowMap;
}
```

<br />

위 코드에서 사용한 `VSMShadowMap` 이외에도 다른 종류의 shadowMap 을 사용할 수도 있습니다. (이번 포스팅에서는 `VSMShadowMap` 을 사용합니다.)

[Three.js 공식 문서 - WebGLRenderer.shadowMap](https://threejs.org/docs/index.html?q=webglRenderer#api/en/renderers/WebGLRenderer.shadowMap)

* BasicShadowMap
* PCFShadowMap (default)
* PCFSoftShadowMap
* VSMShadowMap

<br />

위 설정을 추가한 후, 결과를 확인하면 Hard Shadow 와 다른점이 없어 보입니다.

이는 그림자를 생성하는 Light 의 **Blur 정도** 와 **번지는 영역의 Radius** 를 변경하면서 부드러움이 달라지는 것을 확인할 수 있습니다.

```js title="DirectionalLight 의 Blur 와 Radius 설정" showLineNumbers{79} {6-7}
function initDirectionalLight() {
    const color = new Color('#fff');
    const light = new DirectionalLight(color);
    light.position.set(2, 2, 2);
    light.castShadow = true;
    light.shadow.blurSamples = 30;
    light.shadow.radius = 12;

    const helper = new DirectionalLightHelper(light);

    scene.add(light);
    scene.add(helper);
}
```

<img src="/markdownAssets/threejs/2024-01-07-02/2024-01-07-02-02.png" alt="Soft Shadow" />

<br />

Light 의 shadow 설정 시, 주의할 사항은 다음과 같습니다.

* `shadow.blurSamples`: 값이 커질수록 부드러운 그림자를 표현하지만, 필요 성능이 높아집니다.
* `shadow.radius`: 값이 너무 작으면 화면이 깨지는 현상이 있으므로, **10 이상** 설정을 권장합니다.



<br />



## 추가: VSMShadowMap 에 대하여

Soft Shadow 를 표현하기 위해 VSMShadowMaper 을 사용해 보았습니다.

VSMShadowMap 은 곡선에 대한 그림자를 부드럽게 표현할 수 있는 특징을 가졌습니다.

그래서 지금까지 실습했던 Shpere Mesh 의 그림자를 부드럽게 표현할 수 있었습니다.

<br />

만약 Sphere Mesh 가 아닌 Box Mesh 에 VSMShadowMap 을 적용한다면, 그림자가 드리우지 않아야 하는 영역까지 침범하는 현상을 볼 수 있습니다.

이는 VSMShadowMap 의 Blur 처리가 되면서 번지는 그림자가 렌더링된 결과 입니다.

<br />

화면 구성에 Box Mesh 가 많다면, VSMShadowMap 을 사용했을 때 오히려 지저분한 그림자가 만들어질 수 있다는 점을 고려하여 선택해야 합니다.

<img src="/markdownAssets/threejs/2024-01-07-02/2024-01-07-02-03.png" alt="VSMShadow 단점" />



<br />



## 마치며

그림자는 조명과 물제의 상호연산을 사용하기 때문에 연산량이 많이 필요하다고 합니다.

그래서 그림자를 최소한으로 사용할 수 있도록 여러가지 설정을 분리시켜놓은 느낌이 들었습니다.

Three.js 를 활용할 때, 그림자 설정이 성능 최적화 대상이라는 것을 알게 되었습니다.
1a:T1a79,---
id: 4
title: 평평한 바닥(땅) 만들기 (Plane Mesh)
description: '바닥을 표현하기 위해 Plane Mesh 를 생성합니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'threejs',
    'javascript',
    '3d',
    'plane',
]

createdAt: '2024-01-07 23:20:00'
modifiedHistories: []
---

# 평평한 바닥(땅) 만들기 (Plane Mesh)

이번 포스팅에서는 바닥(땅) 을 만들어 보겠습니다.

Three.js 에서는 바닥(땅) 을 **Plane Mesh** 로 만들 수 있습니다.

다음 포스팅에서 다룰 그림자를 표현하려면, 바닥(땅) 이 있어야 하므로 별도의 포스팅으로 분리하게 되었습니다.



<br />



## 예시 코드

이번 포스팅에서 사용할 예시 코드는 다음과 같습니다.

```js title="예시 코드" showLineNumbers {96}
import {
    WebGLRenderer,
    Scene,
    PerspectiveCamera,

    Mesh,
    MeshStandardMaterial,
    SphereGeometry,

    Color,
    HemisphereLight,
    HemisphereLightHelper,
    DirectionalLight,
    DirectionalLightHelper,
} from 'three';
import {
    OrbitControls,
} from 'three/examples/jsm/controls/OrbitControls';
import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { Scene } */
let scene;

/** @type { PerspectiveCamera } */
let camera;

/** @type { OrbitControls } */
let controls;

function initCanvas() {
    const $canvas = document.createElement('canvas');
    $canvas.width = window.innerWidth;
    $canvas.height = window.innerHeight;

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    return $canvas;
}

function initScene() {
    scene = new Scene();
}

function initCamera() {
    camera = new PerspectiveCamera();
    camera.fov = 35;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.position.set(0, 0, 12);

    camera.updateProjectionMatrix();
}

function initControls($canvas) {
    controls = new OrbitControls(camera, $canvas);
    controls.enableDamping = true;
}

function initHemisphereLight() {
    const skyColor = new Color('#fff');
    const groundColor = new Color('#000');
    const light = new HemisphereLight(
        skyColor,
        groundColor,
        0.75
    );

    const helper = new HemisphereLightHelper(light);

    scene.add(light);
    scene.add(helper);
}

function initDirectionalLight() {
    const color = new Color('#fff');
    const light = new DirectionalLight(color);
    light.position.set(2, 2, 2);

    const helper = new DirectionalLightHelper(light);

    scene.add(light);
    scene.add(helper);
}

function initSphereMesh() {
    const geometry = new SphereGeometry();
    const material = new MeshStandardMaterial();
    const sphere = new Mesh(geometry, material);

    scene.add(sphere);
}

// 여기에 Plane Mesh(바닥) 을 생성하는 함수를 구현할 예정입니다.

function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });
}

function render() {
    window.requestAnimationFrame(render);

    renderer.render(scene, camera);
    controls.update();
}

(function init() {
    const $canvas = initCanvas();
    initRenderer($canvas);
    initScene();
    initCamera();
    initControls($canvas);

    initHemisphereLight();
    initDirectionalLight();

    initSphereMesh();

    render();
}());
```



<br />



## Plane Mesh 생성 함수 만들기

Plane Mesh 는 **PlaneGeometry** class 를 사용하여 생성할 수 있습니다.

```js title="PlaneGeometry class import 하기" showLineNumbers {9}
import {
    WebGLRenderer,
    Scene,
    PerspectiveCamera,

    Mesh,
    MeshStandardMaterial,
    SphereGeometry,
    PlaneGeometry,

    Color,
    HemisphereLight,
    HemisphereLightHelper,
    DirectionalLight,
    DirectionalLightHelper,
} from 'three';
```

```js title="initPlaneMesh() 함수 구현하기" showLineNumbers{97}
function initPlaneMesh() {
    const geometry = new PlaneGeometry();
    const material = new MeshStandardMaterial();
    const plane = new Mesh(geometry, material);
    plane.position.set(0, -1, 0);

    scene.add(plane);
}
```

```js title="initPlaneMesh 함수 호출하기" showLineNumbers{120} {12}
(function init() {
    const $canvas = initCanvas();
    initRenderer($canvas);
    initScene();
    initCamera();
    initControls($canvas);

    initHemisphereLight();
    initDirectionalLight();

    initSphereMesh();
    initPlaneMesh();

    render();
}());
```

<img src="/markdownAssets/threejs/2024-01-07-01/2024-01-07-01-01.png" alt="PlaneMesh" />



<br />



## Plane Mesh 회전 및 크기 변경하기

위 코드를 실행하면, Sphere 하부에 사각형 물체가 렌더링됩니다.

**width**, **height**, **rotation** 을 변경하여 바닥(땅) 처럼 보이도록 설정해 보겠습니다.

```js title="initPlaneMesh() 함수 구현하기" showLineNumbers{97} {2, 6-10}
function initPlaneMesh() {
    const geometry = new PlaneGeometry(5, 5);
    const material = new MeshStandardMaterial();
    const plane = new Mesh(geometry, material);
    plane.position.set(0, -1, 0);
    plane.rotation.set(
        Math.PI * -0.5, 
        0, 
        0
    );

    scene.add(plane);
}
```

<br />

PlaneGeometry class 는 생성자에 **width** 와 **height** 를 넘겨주어 크기를 설정할 수 있습니다.

```js title="width, height 설정" showLineNumbers{98}
const geometry = new PlaneGeometry(5, 5);
```

<br />

그리고 Plane Mesh 인스턴스의 `rotation.set()` 메소드를 사용하여 회전시킬 수 있습니다.

회전시킬 값은 **Radian** 으로 넘겨주어야 하므로, **Math.PI** 를 사용합니다.

```js title="회전 시키기" showLineNumbers{102} {2}
plane.rotation.set(
    Math.PI * -0.5, 
    0, 
    0
);
```

위 코드에서 X축 회전으로 `Math.PI * -0.5` 를 주었는데, 이는 아래와 같은 Plane Mesh 의 특성으로 고려한 것입니다.

* Plane Mesh 는 한쪽면만 렌더링되는 단면 물체 입니다.
* 렌더링되지 않는 반대쪽 면에는 그림자가 드리우지 않습니다.

<br />

이렇게 실행한 결과는 다음과 같습니다.

<img src="/markdownAssets/threejs/2024-01-07-01/2024-01-07-01-02.png" alt="PlaneMesh 설정" />

<br />

카메라를 회전시켜서 Plane Mesh 의 반대쪽 면을 보면, 렌더링되지 않은 결과를 볼 수 있습니다.

<img src="/markdownAssets/threejs/2024-01-07-01/2024-01-07-01-03.png" alt="PlaneMesh 반대면" />



## 마치며

Plane Mesh 를 생성하여 바닥(땅) 을 만들 수 있게 되었습니다.

다음 포스팅에서는 바닥(땅) 에 그림자를 표현하여, 조명과 물체의 자연스러운 연출 방법을 정리해 보겠습니다.
1b:T2eef,---
id: 3
title: 조명 종류와 설정
description: '조명 종류와 설정 방법에 대해 정리합니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'threejs',
    'javascript',
    '3d',
    'light',
]

createdAt: '2024-01-06 23:00:00'
modifiedHistories: []
---

# 조명 종류와 설정

Three.js 는 조명이 없으면 검은 화면만 보이게 됩니다.

이번 포스팅에서는 조명의 종류와 특징, 설정 방법에 대해 정리하고자 합니다.



<br />



## 조명 종류

조명의 종류는 다음과 같습니다.

* DirectionalLight
* PointLight
* AmbientLight
* HemisphereLight

그리고 개발환경에서 조명의 광원 위치를 파악하기 쉽게 도와주는 **Helper class** 가 있습니다.

자세한 사항은 각 조명과 함께 정리하겠습니다.



<br />



## 예시 코드

이번 포스팅에서 사용할 예시 코드는 다음과 같습니다.

```js title="예시 코드" showLineNumbers {94}
import {
    WebGLRenderer,
    Scene,
    PerspectiveCamera,

    SphereGeometry,
    MeshStandardMaterial,
    Mesh,

    Color,

    DirectionalLight,
    DirectionalLightHelper,
} from 'three';
import './style.css';
import {
    OrbitControls,
} from 'three/examples/jsm/controls/OrbitControls';

/** @type { WebGLRenderer } */
let renderer;

/** @type { Scene } */
let scene;

/** @type { PerspectiveCamera } */
let camera;

/** @type { OrbitControls } */
let controls;

function initCanvas() {
    const $canvas = document.createElement('canvas');
    $canvas.width = window.innerWidth;
    $canvas.height = window.innerHeight;

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    return $canvas;
}

function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });
}

function initScene() {
    scene = new Scene();
}

function initCamera() {
    camera = new PerspectiveCamera();
    camera.fov = 35;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.position.set(0, 0, 10);

    camera.updateProjectionMatrix();
}

function initControls($canvas) {
    controls = new OrbitControls(camera, $canvas);
    controls.enableDamping = true;
}

function createSphere() {
    const geometry = new SphereGeometry();
    const material = new MeshStandardMaterial();
    const sphere = new Mesh(geometry, material);

    return sphere;
}

function render() {
    requestAnimationFrame(render);

    renderer.render(scene, camera);
    controls.update();
}

function init() {
    const $canvas = initCanvas();

    initRenderer($canvas);
    initScene();
    initCamera();
    initControls($canvas);

    const sphere = createSphere();
    scene.add(sphere);

    // 여기에서 `조명 설정` 함수를 호출하며 실습할 예정입니다.

    render();
}

init();
```



<br />



## DirectionalLight

DirectionalLight 는 **광원** 에서 **특정 지점(lookAt(좌표))** 로 비추는 **단방향 조명** 입니다.

물체에 비추는 빛의 양은 광원과의 거리와 무관한 빛의 세기(intensity) 설정값이 적용됩니다.

<br />

```js title="DirectionalLight import 하기" showLineNumbers
import {
    DirectionalLight,
} from 'three';
```

```js title="DirectionalLight" showLineNumbers{83} {9, 14-18}
function init() {
    initRenderer(initCanvas());
    initCamera();
    initScene();

    const sphere = createSphere();
    scene.add(sphere);

    initDirectionalLight();

    render();
}

function initDirectionalLight() {
    const light = new DirectionalLight();
    light.position.set(1, 1, 1);
    scene.add(light);
}

init();
```

<br />

DirectionalLight 생성자에 인자로 **Color 객체** 를 넘겨주어 빛의 색상을 변경할 수 있습니다.

**Color** 는 Three.js 에서 제공하는 class 이며, Three.js 의 색상관련 설정은 **Color 인스턴스** 를 받습니다.

```js title="Color import 하기" showLineNumbers
import {
    Color,
} from 'three';
```

```js title="DirectionalLight 색상 설정하기" showLineNumbers{83} {15}
function init() {
    initRenderer(initCanvas());
    initCamera();
    initScene();

    const sphere = createSphere();
    scene.add(sphere);

    initDirectionalLight();

    render();
}

function initDirectionalLight() {
    const color = new Color('#f0f400');
    const light = new DirectionalLight(color);
    light.position.set(1, 1, 1);

    scene.add(light);
}

init();
```

<img src="/markdownAssets/threejs/2024-01-06-01/2024-01-06-01-01.png" alt="DirectionalLight" />



<br />



### DirectionalLightHelper

DirectionalLight 의 광원을 표기해주는 기능을 사용해 보겠습니다.

DirectionalLightHelper 인스턴스를 생성한 후, `scene.add()` 를 사용하여 등록해 줍니다.

```js title="DirectionalLightHelper import 하기" showLineNumbers {3}
import {
    DirectionalLight,
    DirectionalLightHelper,
} from 'three';
```

```js title="DirectionalLight 색상 설정하기" showLineNumbers{83} {20-21}
function init() {
    initRenderer(initCanvas());
    initCamera();
    initScene();

    const sphere = createSphere();
    scene.add(sphere);

    initDirectionalLight();

    render();
}

function initDirectionalLight() {
    const color = new Color('#f0f400');
    const light = new DirectionalLight(color);
    light.position.set(1, 1, 1);
    scene.add(light);

    const helper = new DirectionalLightHelper(light);
    scene.add(helper);
}

init();
```

<img src="/markdownAssets/threejs/2024-01-06-01/2024-01-06-01-02.png" alt="DirectionalLightHelper" />



<br />



## 빛의 세기(intensity) 설정하기

조명은 빛의 세기(intensity) 가 있습니다.

Three.js 의 모든 조명에도 빛의 세기(intensity) 를 설정할 수 있습니다.

빛의 세기 값은 **0 ~ 1** 값으로 설정합니다.

아래 코드는 DirectionalLight 에 빛의 세기(intensity) 를 0.75 로 설정하고 있습니다.

```js title="DirectionalLight 색상 설정하기" showLineNumbers{83} {18}
function init() {
    initRenderer(initCanvas());
    initCamera();
    initScene();

    const sphere = createSphere();
    scene.add(sphere);

    initDirectionalLight();

    render();
}

function initDirectionalLight() {
    const color = new Color('#f0f400');
    const light = new DirectionalLight(
        color, 
        0.75
    );
    light.position.set(1, 1, 1);
    scene.add(light);

    const helper = new DirectionalLightHelper(light);
    scene.add(helper);
}

init();
```



<br />



## PointLight

전등처럼 한 점에서 빛을 방사하는 조명 입니다.

사용방법은 다음과 같습니다.

```js title="PointLight import 하기" showLineNumbers
import {
    PointLight,
    PointLightHelper,
} from 'three';
```

```js title="PointLight 색상 설정하기" showLineNumbers{83} {9, 14-25}
function init() {
    initRenderer(initCanvas());
    initCamera();
    initScene();

    const sphere = createSphere();
    scene.add(sphere);

    initPointLight();

    render();
}

function initPointLight() {
    const color = new Color('#f0f400');
    const light = new PointLight(
        color,
        0.75 // 빛의 세기(intensity)
    );
    light.position.set(1, 1, 1);
    scene.add(light);

    const helper = new PointLightHelper(light);
    scene.add(helper);
}

init();
```

<img src="/markdownAssets/threejs/2024-01-06-01/2024-01-06-01-03.png" alt="PointLight" />



<br />



## AmbientLight

Ambient 는 `주변` 이라는 뜻을 가지고 있습니다.

AmbientLight 는 특정한 광원이 없고, 모든 영역에 동일하게 비추는 조명입니다.

즉 `(x, y, z)` 에 관계없이 동일한 빛을 비춥니다.

<br />

AmbientLight 가 적용된 결과를 확인하기 위해, PointLight 와 함께 사용해 보겠습니다.

```js title="PointLight import 하기" showLineNumbers {5}
import {
    PointLight,
    PointLightHelper,

    AmbientLight,
} from 'three';
```

```js title="PointLight 색상 설정하기" showLineNumbers{83} {10, 28-35}
function init() {
    initRenderer(initCanvas());
    initCamera();
    initScene();

    const sphere = createSphere();
    scene.add(sphere);

    initPointLight();
    initAmbientLight();

    render();
}

function initPointLight() {
    const color = new Color('#f0f400');
    const light = new PointLight(
        color,
        0.75 // 빛의 세기(intensity)
    );
    light.position.set(1, 1, 1);
    scene.add(light);

    const helper = new PointLightHelper(light);
    scene.add(helper);
}

function initAmbientLight() {
    const color = new Color('#fff');
    const light = new AmbientLight(
        color,
        0.25, // 빛의 세기(intensity)
    );
    scene.add(light);
}

init();
```

<img src="/markdownAssets/threejs/2024-01-06-01/2024-01-06-01-04.png" alt="AmbientLight" />

<br />

그리고 AmbientLight 는 모든 영역에 비추는 조명이므로, **Helper class 가 없다는 특징** 이 있습니다.



<br />



## HemisphereLight

HemisphereLight 는 위쪽(skyColor) 와 아래쪽(groundColor) 를 인자로 받고, 그라데이션으로 비추는 조명입니다.

일반적으로 기본 조명으로 사용하는데, 이는 Three.js 특성 때문입니다.

* 조명이 없으면, 물체(Mesh) 는 보이지 않는 검은 화면만 렌더링 됩니다.
* 다른 조명에 의해 생기는 그림자를 좀 더 자연스럽고 부드럽게 만들어줍니다.

<br />

아래 코드는 HemisphereLight 와 DirectionalLight 를 조합한 예시 입니다.

```js title="PointLight import 하기" showLineNumbers {5-6}
import {
    DirectionalLight,
    DirectionalLightHelper,

    HemisphereLight,
    HemisphereLightHelper,
} from 'three';
```

```js title="PointLight 색상 설정하기" showLineNumbers{83} {10, 28-40}
function init() {
    initRenderer(initCanvas());
    initCamera();
    initScene();

    const sphere = createSphere();
    scene.add(sphere);

    initDirectionalLight();
    initHemisphereLight();

    render();
}

function initDirectionalLight() {
    const color = new Color('#fff');
    const light = new DirectionalLight(
        color,
        0.75 // 빛의 세기(intensity)
    );
    light.position.set(1, 1, 1);
    scene.add(light);

    const helper = new PointLightHelper(light);
    scene.add(helper);
}

function initHemisphereLight() {
    const skyColor = new Color('#fff');
    const groundColor = new Color('#000');
    const light = new HemisphereLight(
        skyColor,
        groundColor,
        0.25, // 빛의 세기(intensity)
    );
    scene.add(light);

    const helper = new HemisphereLightHelper(light);
    scene.add(helper);
}

init();
```

<img src="/markdownAssets/threejs/2024-01-06-01/2024-01-06-01-05.png" alt="Hemisphere" />



<br />



## 마치며

일반적으로 DirectionalLight 와 HemisphereLight 를 조합하여 기본 조명을 구성합니다.

각 설정은 다음과 같습니다.

```js title="일반적인 조명 설정" showLineNumbers
function initDirectionalLight() {
    const color = new Color('#fff');
    const light = new DirectionalLight(
        color,
        0.75 // HemispherLight 보다 0.5 강하게 설정합니다.
    );
    scene.add(light);
}

function initHemisphereLight() {
    const skyColor = new Color('#fff');
    const groundColor = new Color('#000');
    const light = new HemisphereLight(
        skyColor,
        groundColor,
        0.25 // DirectionalLight 보다 0.5 약하게 설정합니다.
    );
    scene.add(light);
}
```

<br />

HemisphereLight 를 사용하므로써 그림자 부분이 검은색으로 보이지 않도록 해주며, 좀 더 자연스러운 조명을 연출할 수 있습니다.

그리고 PointLight 는 특정 물체를 강조하거나 효과를 주기위해 주로 사용합니다.

<br />

Three.js 는 개발 능력뿐만 아니라 사물을 표현하는 예술 능력도 필요하겠다는 느낌이 듭니다. 😱
1c:T3ac1,---
id: 2
title: 카메라 설정 (PerspectiveCamera)
description: 'Three.js 의 카메라인 PerspectiveCamera 설정에 대한 포스팅입니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'threejs',
    'javascript',
    '3d',
    'camera',
]

createdAt: '2024-01-01 23:50:00'
modifiedHistories: []
---

# 카메라 설정 (PerspectiveCamera)

Three.js 가 `<canvas />` 에 실제로 렌더링하는 부분은 `카메라 (PerspectiveCamera)` 가 비추는 영역입니다.

이번 포스팅에서는 카메라 설정과 효과, 사용자 인터렉션 적용 방법에 대해 정리해 보겠습니다.

이번 포스팅에서는 아래의 코드를 시작점으로 사용하겠습니다.

```js title="샘플 코드" showLineNumbers
import {
    WebGLRenderer,
    PerspectiveCamera,
    Scene,
    DirectionalLight,

    BoxGeometry,
    MeshPhongMaterial,
    Mesh,
} from 'three';
import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

/** @type { Scene } */
let scene;

(function init() {
    const $canvas = initCanvas();

    initRenderer($canvas);

    const light = createLight();
    const boxMesh = createBoxMesh();

    initCamera();
    initScene(light, boxMesh);

    render();

    console.log('시작');
}());

function render() {
    renderer.render(scene, camera);

    window.requestAnimationFrame(render);
}

function initCanvas() {
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    return $canvas;
}

/**
 * @param { HTMLCanvasElement } $canvas 
 */
function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });

    renderer.setSize(
        window.innerWidth,
        window.innerHeight
    );
}

function createLight() {
    const light = new DirectionalLight();
    light.position.set(1, 2, 3);

    return light;
}

function createBoxMesh() {
    const boxGeometry = new BoxGeometry();
    const boxMaterial = new MeshPhongMaterial();

    return new Mesh(boxGeometry, boxMaterial);
}

function initCamera() {
    camera = new PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight
    );

    camera.position.set(0, 0, 5);
}

function initScene(...items) {
    scene = new Scene();

    items.forEach(item => {
        scene.add(item);
    });
}
```



<br />



## PerspectiveCamera 생성자 params

카메라 생성자 params 를 사용하여 초기 설정을 할 수 있습니다.

```ts title="PerspectiveCamera 생성자 함수" showLineNumbers
class PerspectiveCamera {
    constructor(
        fov?: number,
        aspect?: number,
        near?: number,
        far?: number
    );
}
```

* fov (Field of View): 시야각 (화각)
    * fov 설정값이 클수록 먼 거리에서 보는 느낌이 납니다.
    * fov 설정값이 커질수록 **투시에 따른 왜곡현상** 이 도드라지게 나타납니다.
* aspect: 카메라 종횡비 (aspect radio)
    * 카메라의 가로, 세로 비율값 입니다.
* near: (Near clipping)
    * 카메라를 기준으로 가까운 물체(Mesh) 에 대한 렌더링 잘라내기 설정값 입니다.
* far: (Far clipping)
    * 카메라를 기준으로 먼 물체(Mesh) 에 대한 렌더링 잘라내기 설정값 입니다.

<br />

위 설정들은 PerspectiveCamera 생성자를 통해서도 설정할 수 있고, 객체를 생성한 후 설정을 변경할 수도 있습니다.

만약 객체를 생성한 후 설정을 변경한다면, 카메라 메소드인 **updateProjectionMatrix()** 함수를 호출하여야 실제 렌더링에 반영됩니다.

아래 코드는 PerspectiveCamera 객체를 생성한 후, 카메라 설정을 변경하고 있습니다.

```js title="카메라 객체 설정값 변경하기" showLineNumbers {88, 89, 92}
import {
    WebGLRenderer,
    PerspectiveCamera,
    Scene,
    DirectionalLight,

    BoxGeometry,
    MeshPhongMaterial,
    Mesh,
} from 'three';
import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

/** @type { Scene } */
let scene;

(function init() {
    const $canvas = initCanvas();

    initRenderer($canvas);

    const light = createLight();
    const boxMesh = createBoxMesh();

    initCamera();
    initScene(light, boxMesh);

    render();

    console.log('시작');
}());

function render() {
    renderer.render(scene, camera);

    window.requestAnimationFrame(render);
}

function initCanvas() {
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    return $canvas;
}

/**
 * @param { HTMLCanvasElement } $canvas 
 */
function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });

    renderer.setSize(
        window.innerWidth,
        window.innerHeight
    );
}

function createLight() {
    const light = new DirectionalLight();
    light.position.set(1, 2, 3);

    return light;
}

function createBoxMesh() {
    const boxGeometry = new BoxGeometry();
    const boxMaterial = new MeshPhongMaterial();

    return new Mesh(boxGeometry, boxMaterial);
}

function initCamera() {
    camera = new PerspectiveCamera(
        // 45,
        // window.innerWidth / window.innerHeight
    );

    camera.fov = 45;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.position.set(0, 0, 3);

    camera.updateProjectionMatrix();
}

function initScene(...items) {
    scene = new Scene();

    items.forEach(item => {
        scene.add(item);
    });
}
```

<br />

위 코드의 실행 결과로 BoxMesh 의 단면을 볼 수 있습니다.

<img src="/markdownAssets/threejs/2024-01-01-01/2024-01-01-01-01.png" alt="실행 결과" />



<br />



## 카메라의 주시 좌표값 변경하기

현재는 BoxMesh 의 단면만을 비추고 있어서 마치 2D 인것 처럼 보입니다.

카메라의 위치와 카메라의 주시 좌표값을 변경하면, 물체를 다각도에서 다양한 구도로 렌더링할 수 있습니다.

<br />

먼저 카메라의 위치를 (1, 1, 2) 로 변경해 보겠습니다.

```js title="카메라 position 변경" showLineNumbers{82} {6}
function initCamera() {
    camera = new PerspectiveCamera();

    camera.fov = 45;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.position.set(1, 1, 2);

    camera.updateProjectionMatrix();
}
```

<img src="/markdownAssets/threejs/2024-01-01-01/2024-01-01-01-02.png" alt="실행 결과" />

<br />

카메라의 position 만을 변경한 결과, BoxMesh 의 일부분만 렌더링되고 있습니다.

이는 카메라의 주시 좌표값을 설정하지 않아서 카메라 위치에서 정면을 주시하고 있기 때문입니다.

카메라 객체의 `lookAt()` 메소드를 사용하면, 카메라의 위치인 position 에서 특정 좌표를 주시하게 됩니다.

BoxMesh 가 카메라의 중앙에 오도록 하기위해, BoxMesh 의 position 위치값인 (0, 0, 0) 으로 카메라 주시 좌표를 설정해 보겠습니다.

```js title="카메라 position 변경" showLineNumbers{82} {8}
function initCamera() {
    camera = new PerspectiveCamera();

    camera.fov = 45;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.position.set(1, 1, 2);

    camera.lookAt(0, 0, 0);

    camera.updateProjectionMatrix();
}
```

<img src="/markdownAssets/threejs/2024-01-01-01/2024-01-01-01-03.png" alt="실행 결과" />



<br />



## 카메라 fov 와 position 설정에 따른 왜곡 현상

fov(Field of View) 값이 커질수록 멀리서 보는 느낌으로 렌더링됩니다.

이는 물체가 더 작게 보이는 결과를 볼 수 있습니다.

<br />

만약 fov 를 큰 값으로 설정하여 물체가 작게 보이도록 한 후, 카메라의 위치를 물체와 가깝게 설정하면 어떻게 될까요?

이는 카메라의 **왜곡 현상** 에 의해 좀 더 렌즈의 굴곡이 커지게 됩니다.

fov 와 position 의 관계를 표현해 보면 다음과 같습니다.

* fov 작게 설정, position 멀리 설정
    * 왜곡 현상이 적어집니다.
* fov 크게 설정, position 가깝게 설정
    * 왜곡 현상이 커집니다.

<br />

실제 왜곡 현상의 차이를 확인하기 위해 두가지 설정을 비교해 보겠습니다.

* 첫번째 설정: **fov 작게, position 멀리** 설정
* 두번째 설정: **fov 크게, position 가깝게** 설정

```js title="fov 작게, position 멀리 설정" showLineNumbers{82} {5-6}
function initCamera() {
    camera = new PerspectiveCamera();

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.fov = 45;
    camera.position.set(2, 2, 2);

    camera.lookAt(0, 0, 0);

    camera.updateProjectionMatrix();
}
```

<img src="/markdownAssets/threejs/2024-01-01-01/2024-01-01-01-04.png" alt="실행 결과" />

<br /><br />

```js title="fov 크게, position 가깝게 설정" showLineNumbers{82} {5-6}
function initCamera() {
    camera = new PerspectiveCamera();

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.fov = 90;
    camera.position.set(1, 1, 1);

    camera.lookAt(0, 0, 0);

    camera.updateProjectionMatrix();
}
```

<img src="/markdownAssets/threejs/2024-01-01-01/2024-01-01-01-05.png" alt="실행 결과" />



<br />



## 추가: 마우스를 사용하여 카메라 제어하기

Three.js 는 여러가지 Addons 를 제공합니다.

이 중 **OrbitControls** 객체를 사용하면, 마우스를 사용하여 카메라를 제어하는 기능을 제공할 수 있습니다.

<br />

OrbitControls 는 **PerspectiveCamera 의 Addon** 개념으로 사용하게 되며, 카메라의 제어를 담당하게 됩니다.

주의할 점은 PerspectiveCamera 의 `lookAt()` 메소드를 함께 사용하게 되면, 카메라 제어에 충돌이 발생하는 현상입니다.

그러므로 OrbitControls 를 사용하려면, `lookAt()` 메소드는 꼭 제거해 주는 것이 좋습니다.

<br />

먼저 OrbitControls 의 생성자를 살펴보면 다음과 같습니다.

```ts
class OrbitControls {
    constructor(
        object: Camera, 
        domElement?: HTMLElement
    );
}
```

* object: 제어할 카메라 객체
* domElement: 마우스 이벤트를 발생시킬 HTMLElement

<br />

PerspectiveCamera 에 OrbitControls 를 적용하는 `initControls()` 함수를 추가해 보겠습니다.

```js title="OrbitControls 로 카메라 제어하기" showLineNumbers {11-13, 25-26, 37, 45, 103-108}
import {
    WebGLRenderer,
    PerspectiveCamera,
    Scene,
    DirectionalLight,

    BoxGeometry,
    MeshPhongMaterial,
    Mesh,
} from 'three';
import {
    OrbitControls,
} from 'three/examples/jsm/controls/OrbitControls'
import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

/** @type { Scene } */
let scene;

/** @type { OrbitControls } */
let controls;

(function init() {
    const $canvas = initCanvas();

    initRenderer($canvas);

    const light = createLight();
    const boxMesh = createBoxMesh();

    initCamera();
    initControls($canvas);
    initScene(light, boxMesh);

    render();
}());

function render() {
    renderer.render(scene, camera);
    controls.update();

    window.requestAnimationFrame(render);
}

function initCanvas() {
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    return $canvas;
}

/**
 * @param { HTMLCanvasElement } $canvas 
 */
function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });

    renderer.setSize(
        window.innerWidth,
        window.innerHeight
    );
}

function createLight() {
    const light = new DirectionalLight();
    light.position.set(1, 2, 3);

    return light;
}

function createBoxMesh() {
    const boxGeometry = new BoxGeometry();
    const boxMaterial = new MeshPhongMaterial();

    return new Mesh(boxGeometry, boxMaterial);
}

function initCamera() {
    camera = new PerspectiveCamera();

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.fov = 45;
    camera.position.set(2, 2, 2);

    camera.fov = 90;
    camera.position.set(1, 1, 1);

    camera.lookAt(0, 0, 0);

    camera.updateProjectionMatrix();
}

/**
 * @param { HTMLElement } $targetElement 
 */
function initControls($targetElement) {
    controls = new OrbitControls(camera, $targetElement);
}

function initScene(...items) {
    scene = new Scene();

    items.forEach(item => {
        scene.add(item);
    });
}
```

<br />

OrbitControls 를 카메라에 설치하게 되면 아래와 같은 마우스 인터렉션을 사용할 수 있습니다.

* 마우스 좌클릭 - 드래그
    * 카메라 주시 좌표를 회전 중심점으로 하여, **드래그 반대 방향으로 카메라를 회전** 시킵니다.
    * 결과적으로 카메라가 고정된 상태에서 **바라보는 물체가 회전** 하게 됩니다.
* 마우스 휠
    * 확대, 축소 동작을 합니다.
* 마우스 우클릭 - 드래그
    * **드래그 반대 방향으로 카메라의 위치를 이동** 시킵니다.
    * 결과적으로 카메라가 고정된 상태에서 **바라보는 물체가 이동** 하게 됩니다.

<br />

OrbitControls 객체의 설정을 사용하여, 특정 마우스 인터렉션의 사용 여부를 설정할 수 있습니다.

이 설정 프로퍼티들은 `enable` 을 접두사로 사용하고 있습니다.

* `enableRotate`: `false` 값을 대입하면, 회전기능을 막습니다.
* `enableZoom`: `false` 값을 대입하면 확대, 축소 기능을 막습니다.
* `enablePan`: `false` 값을 대입하면 이동 기능을 막습니다.

<br />

추가로 `enableDamping` 에 `true` 값을 대입하게 되면, 카메라의 모든 인터렉션에 감속도가 적용되어 **카메라의 부드러운 움직임이 연출** 됩니다.



<br />



## 마치며

일전에 HTML Canvas API 를 스터디하면서, 도형에 대한 인터렉션이나 애니메이션을 구현해본 적이 있습니다.

물체의 튕김이나 가속도, 감속도를 구현해 보려는 시도를 했었지만, 제가 구현한 결과물은 너무나 어색했습니다.

Three.js 의 인터렉션은 OrbitControls 하나를 접했을 뿐인데, 부드러운 3D 엔진에 그저 놀라울 뿐입니다.

<br />

하지만 실제 구현할 기획에 따라 엔진의 물리 효과를 커스터마이징을 할 수 있어야 자연스러운 결과물이 나올 것 같습니다.

OrbitControls 가 제공하는 효과는 마치 물속의 부력이 작용하는 것처럼 느껴졌습니다.

Three.js 의 기본 사용법과 원리를 이해한 후, 물리 엔진 커스터마이징에 대해서도 도전해 보고 싶어졌습니다.
b:["$","$Lc",null,{"featuredMarkdownFileDataList":[{"category":"jest","slug":"2023-12-17-01","href":"/blog/jest/2023-12-17-01","frontmatter":{"id":1,"title":"\"node:fs\" 테스트 하기","description":"node 모듈중 File System 기능, \"fs\" 를 테스트하는 방법에 대해 정리합니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":true,"tags":["mock-fs","fs","node:fs","jest","@testing-library","유닛 테스트"],"createdAt":"$D2023-12-17T15:33:00.000Z","modifiedHistories":[]},"markdownFile":"$d"},{"category":"threejs","slug":"2023-12-31-01","href":"/blog/threejs/2023-12-31-01","frontmatter":{"id":1,"title":"Three.js 설치 및 실행","description":"Three.js 를 사용하기 위한 설치와 첫번째 화면을 그려봅니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":true,"tags":["threejs","javascript","3d"],"createdAt":"$D2023-12-31T22:47:00.000Z","modifiedHistories":[]},"markdownFile":"$e"}],"commonMarkdownFileDataList":[{"category":"javascript","slug":"2023-12-21-01","href":"/blog/javascript/2023-12-21-01","frontmatter":{"id":1,"title":"구조 분해 할당의 기본값 지정, null 은 사용 불가!","description":"구조 분해 할당의 기본값 설정은 Nullish(undefined 와 null) 가 아닌, 오직 undefined 일 때만 적용됩니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["javascript"],"createdAt":"$D2023-12-21T20:20:00.000Z","modifiedHistories":[]},"markdownFile":"$f"},{"category":"javascript","slug":"2023-12-30-01","href":"/blog/javascript/2023-12-30-01","frontmatter":{"id":2,"title":"AWS S3 를 사용한 PDF 뷰어 구현시, Metadata 설정","description":"AWS S3 에 업로드한 PDF 파일이 렌더링되지 않고 다운로드 되는 이슈에 대한 정리 입니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["javascript","PDF","PDF Metadata","AWS","S3"],"createdAt":"$D2023-12-30T16:00:00.000Z","modifiedHistories":[]},"markdownFile":"$10"},{"category":"jest","slug":"2024-01-06-01","href":"/blog/jest/2024-01-06-01","frontmatter":{"id":4,"title":"Nextjs 의 useRouter mock 정의하기","description":"Nextjs 의 useRouter 를 사용하는 컴포넌트를 테스트하기 위한 방법을 정리합니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["jest","@testing-library","useRouter","next-router-mock","유닛 테스트"],"createdAt":"$D2024-01-06T17:30:00.000Z","modifiedHistories":[]},"markdownFile":"$11"},{"category":"jest","slug":"2023-12-26-01","href":"/blog/jest/2023-12-26-01","frontmatter":{"id":3,"title":"\"styled-components\" 로 구현한 컴포넌트 테스트하기","description":"\"styled-components\" 를 사용한 컴포넌트를 테스트하기 위한 환경설정에 대해 알아봅니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["jest","styled-components","@testing-library","유닛 테스트"],"createdAt":"$D2023-12-26T23:50:00.000Z","modifiedHistories":[]},"markdownFile":"$12"},{"category":"jest","slug":"2023-12-23-01","href":"/blog/jest/2023-12-23-01","frontmatter":{"id":2,"title":"\"jest.fn()\" 으로 함수 테스트하기","description":"컴포넌트 props 로 넘겨주는 함수를 테스트하는 방법으로 \"jest.fn()\" 사용방법에 대한 정리 입니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["jest.fn","jest","@testing-library","유닛 테스트"],"createdAt":"$D2023-12-23T14:45:00.000Z","modifiedHistories":[]},"markdownFile":"$13"},{"category":"llmops","slug":"2023-12-16-01","href":"/blog/llmops/2023-12-16-01","frontmatter":{"id":1,"title":"LLMOps 와 친해지기 1 - 용어 정리","description":"AI 학습 모델인 Large Language Model 에 대한 정리입니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":[],"createdAt":"$D2023-12-16T15:00:00.000Z","modifiedHistories":[]},"markdownFile":"$14"},{"category":"nextjs","slug":"2024-01-01-01","href":"/blog/nextjs/2024-01-01-01","frontmatter":{"id":2,"title":".DS_Store not found 에러","description":"Nextjs 빌드 시, .DS_Store 파일을 찾을 수 없다는 에러를 마주하게 되었습니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["nextjs",".DS_Store"],"createdAt":"$D2024-01-01T15:20:00.000Z","modifiedHistories":[]},"markdownFile":"---\nid: 2\ntitle: .DS_Store not found 에러\ndescription: 'Nextjs 빌드 시, .DS_Store 파일을 찾을 수 없다는 에러를 마주하게 되었습니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'nextjs',\n    '.DS_Store',\n]\n\ncreatedAt: '2024-01-01 15:20:00'\nmodifiedHistories: []\n---\n\n# .DS_Store not found 에러\n\nNextjs 프로젝트에 이미지 파일을 추가하고 삭제한 후, 빌드 에러가 발생하였습니다.\n\n> Error: ENOENT: no such file or directory, open '/.../.DS_Store\n\n\n\n<br />\n\n\n\n## 에러 원인 파악\n\n.DS_Store 는 맥북의 폴더 관련 메타데이터 파일이며, Finder 로 폴더에 접근하게 되면 자동으로 생성됩니다.\n\n문제는 Nextjs 프로젝트를 개발 환경으로 실행하거나 빌드할 때, .DS_Store 파일이 추가되면, 빌드 에러가 발생합니다.\n\n\n\n\n<br />\n\n\n\n## 해결 방법\n\n* 참고: [Stack Overflow](https://github.com/vercel/next.js/discussions/15573#discussioncomment-2415012)\n\n<br />\n\nNextjs 프로젝트 하위에 존재하는 .DS_Store 파일을 모두 삭제하는 것으로 해결할 수 있었습니다.\n\n모든 폴더를 직접 열어보면서 지우는 방법도 있겠지만, 터미널을 사용하여 삭제 명령으로 처리할 수 있습니다.\n\n```bash title=\"프로젝트 내의 모든 .DS_Store 파일 삭제\"\nrm **/.DS_Store\n```\n\n<br />\n\n삭제 명령이 실행 완료되면, Nextjs 프로젝트가 정상적으로 빌드되는 것을 확인할 수 있습니다.\n"},{"category":"nextjs","slug":"2023-12-16-01","href":"/blog/nextjs/2023-12-16-01","frontmatter":{"id":1,"title":"Nextjs 프로젝트의 유닛 테스트","description":"유닛 테스트를 위해 Jest 와 @testing-library 설치 및 설정에 대한 정리 입니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["nextjs","jest","@testing-library","react","유닛 테스트"],"createdAt":"$D2023-12-16T22:13:00.000Z","modifiedHistories":[]},"markdownFile":"$15"},{"category":"react","slug":"2023-12-19-01","href":"/blog/react/2023-12-19-01","frontmatter":{"id":1,"title":"Custom Hook 으로 분리하며 발생한 실수","description":"Custom Hook 으로 분리한 useEffect 가 여러번 호출 케이스 중 한가지를 정리합니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["react","custom hook"],"createdAt":"$D2023-12-19T22:50:00.000Z","modifiedHistories":[]},"markdownFile":"$16"},{"category":"threejs","slug":"2024-01-10-01","href":"/blog/threejs/2024-01-10-01","frontmatter":{"id":7,"title":"모델 파일을 Three.js 에 렌더링하기","description":".gltf 또는 .glb 확장자인 모델 파일을 Three.js 에 불러오고 렌더링하는 방법을 정리합니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["threejs","javascript","3d","hdr",".gltf",".glb","model"],"createdAt":"$D2024-01-10T23:50:00.000Z","modifiedHistories":[]},"markdownFile":"$17"},{"category":"threejs","slug":"2024-01-08-01","href":"/blog/threejs/2024-01-08-01","frontmatter":{"id":6,"title":"배경화면 및 환경조명 설정하기","description":"360도 이미지 확장자인 .hdr 파일을 사용하여 배경화면을 설정하고, 배경화면에 의한 환경조명 설정에 대한 정리입니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["threejs","javascript","3d","hdr","background","3D 배경화면","환경조명"],"createdAt":"$D2024-01-08T23:50:00.000Z","modifiedHistories":[]},"markdownFile":"$18"},{"category":"threejs","slug":"2024-01-07-02","href":"/blog/threejs/2024-01-07-02","frontmatter":{"id":5,"title":"그림자 표현하기","description":"그림자 설정방법과 특징에 대해 정리합니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["threejs","javascript","3d","shadow"],"createdAt":"$D2024-01-07T23:50:00.000Z","modifiedHistories":[]},"markdownFile":"$19"},{"category":"threejs","slug":"2024-01-07-01","href":"/blog/threejs/2024-01-07-01","frontmatter":{"id":4,"title":"평평한 바닥(땅) 만들기 (Plane Mesh)","description":"바닥을 표현하기 위해 Plane Mesh 를 생성합니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["threejs","javascript","3d","plane"],"createdAt":"$D2024-01-07T23:20:00.000Z","modifiedHistories":[]},"markdownFile":"$1a"},{"category":"threejs","slug":"2024-01-06-01","href":"/blog/threejs/2024-01-06-01","frontmatter":{"id":3,"title":"조명 종류와 설정","description":"조명 종류와 설정 방법에 대해 정리합니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["threejs","javascript","3d","light"],"createdAt":"$D2024-01-06T23:00:00.000Z","modifiedHistories":[]},"markdownFile":"$1b"},{"category":"threejs","slug":"2024-01-01-01","href":"/blog/threejs/2024-01-01-01","frontmatter":{"id":2,"title":"카메라 설정 (PerspectiveCamera)","description":"Three.js 의 카메라인 PerspectiveCamera 설정에 대한 포스팅입니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["threejs","javascript","3d","camera"],"createdAt":"$D2024-01-01T23:50:00.000Z","modifiedHistories":[]},"markdownFile":"$1c"}]}]
