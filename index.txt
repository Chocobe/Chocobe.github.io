1:HL["/_next/static/media/0c7e3e2387401c47-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
2:HL["/_next/static/css/6566b64e7f0e478f.css","style",{"crossOrigin":""}]
0:["f-kaMTx4dPkt7gBHQ32FP",[[["",{"children":["__PAGE__",{}]},"$undefined","$undefined",true],"$L3",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/6566b64e7f0e478f.css","precedence":"next","crossOrigin":""}]],"$L4"]]]]
5:I[9248,["576","static/chunks/576-dc377cf448834f03.js","251","static/chunks/251-ef7560cc4f7a9f6d.js","185","static/chunks/app/layout-5bdea2f994faa404.js"],""]
6:I[179,["576","static/chunks/576-dc377cf448834f03.js","251","static/chunks/251-ef7560cc4f7a9f6d.js","185","static/chunks/app/layout-5bdea2f994faa404.js"],""]
7:I[6962,["576","static/chunks/576-dc377cf448834f03.js","251","static/chunks/251-ef7560cc4f7a9f6d.js","185","static/chunks/app/layout-5bdea2f994faa404.js"],""]
8:I[6954,[],""]
9:I[7264,[],""]
3:[null,["$","html",null,{"lang":"ko","children":["$","body",null,{"className":"__className_7bb6ba","children":["$","div",null,{"className":"w-full\n            h-full\n            overflow-y-scroll\n            overflow-x-auto","children":["$","$L5",null,{"children":[["$","$L6",null,{}],["$","$L7",null,{"style":{"minHeight":"calc(100% - 72px)"},"children":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L9",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"childProp":{"current":["$La","$Lb",null],"segment":"__PAGE__"},"styles":null}]}]]}]}]}]}],null]
4:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"Chocobe Blog v2"}],["$","meta","3",{"name":"description","content":"Frontend 기술 블로그 입니다."}],["$","link","4",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}],["$","meta","5",{"name":"next-size-adjust"}]]
a:null
c:I[463,["281","static/chunks/08ffe114-a8e3ed06beefbf38.js","465","static/chunks/48507feb-6de01ca04009bb96.js","306","static/chunks/39209d7c-a33d4549f726b4ab.js","576","static/chunks/576-dc377cf448834f03.js","251","static/chunks/251-ef7560cc4f7a9f6d.js","128","static/chunks/128-a9a4b8134fdbdc1d.js","931","static/chunks/app/page-2a9b84f80b166504.js"],""]
d:T162a,---
id: 1
title: '"node:fs" 테스트 하기'
description: 'node 모듈중 File System 기능, "fs" 를 테스트하는 방법에 대해 정리합니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: true
tags: [
    'mock-fs',
    'fs',
    'node:fs',
    'jest',
    '@testing-library',
    '유닛 테스트',
]

createdAt: '2023-12-17 15:33:00'
modifiedHistories: []
---


# "node:fs" 테스트 하기

Nextjs 를 사용하게 되면서 SSG(static site generators) 와 SSR(server side rendering) 을 사용하게 되었습니다.

덕분에 CSR(client side rendering) 의 단점인 SEO 를 해소할 수 있게 되었습니다.

SSG(static site generators) 와 SSR(server side rendering) 을 사용하게 되면, **node** 모듈들을 사용할 수 있습니다.

이번 포스팅은 **node:fs** 를 사용하는 코드의 유닛 테스트 방법에 대해 정리합니다.



<br />



## Jest 에서 안내하는 built-in modules 테스트

* 참고: [[Jest 공식문서] Mocking Node modules](https://jestjs.io/docs/manual-mocks#mocking-node-modules)

<br />

Jest 공식문서에 의하면, built-in modules 를 테스트하기 위해 몇가지 사전준비가 필요합니다.

1. **node_modules** 와 인접한 경로에 **__mocks__** 폴더 만들기
2. 테스트할 built-in module 과 동일한 이름의 파일(**fs.js**) 을 **__mocks__** 하위에 만들기
3. **fs.js** 파일 구현하기
    1. `jest.createMockFromModule('fs')` 를 호출하여 mock 적용하기
    2. `fs` 의 메시드 중, 테스트 대상이 사용하는 모든 메서드에 mock 구현
4. 유닛 테스트 파일에서 `jest.mock('fs')` 로 mock 적용하기

<br />

위 과정을 모두 구현할 수도 있지만, 좀 더 편리한 방법을 찾아본 결과 **mock-fs** 라는 라이브러리를 찾게 되었습니다.

**mock-fs** 는 Jest 에서 안내하는 "node:fs" 테스트 준비 과정을 제공합니다.



<br />



## **mock-fs** 설치하기

만약 **Typescript** 를 사용한다면, **@types/mock-fs** 모듈도 함께 설치합니다.

```bash title="Javascript 사용 시" 
yarn add -D mock-fs
```

```bash title="Typescript 사용 시"
yarn add -D mock-fs @types/mock-fs
```



<br />



## **node:fs** 테스크 코드 작성하기

* 참고: [mock-fs 공식 문서](https://github.com/tschaub/mock-fs?tab=readme-ov-file#mock-fs)
* 참고: [[지나가던 개발자]jest와 mock-fs로 fs 유닛 테스트하기](https://znagadeon.dev/post/test-fs/index.html)

<br />

**mock-fs** 를 사용하게 되면 아래의 2가지 작업이 필요합니다.

* `jest.beforeEach()`: **mock-fs** 를 사용한 file system mockup
* `jest.afterEach()`: **mock-fs** 해제

<br />

먼저 테스트 준비를 위한 mockup 을 구현하면 다음과 같습니다.

```typescript showLineNumbers
import mock from 'mock-fs';

describe('mock-fs 를 사용한 "node:fs" 테스트', () => {
    beforeEach(() => {
        mock({
            '경로1': {
                '하위_경로1': {
                    '파일_1.mdx': '파일 내용 mockup',
                    '파일_2.mdx': '파일 내용 mockup',
                },
            },
            '경로2/경로3': {
                '하위_경로2': {
                    // 빈 폴더
                },
            },
        });
    });
});
```

<br />

이제 **node:fs** 는 mockup 에서 정의한 mock file system 을 사용하게 됩니다.

```typescript {22} showLineNumbers
import fs from 'node:fs/promises';
import mock from 'mock-fs';

describe('mock-fs 를 사용한 "node:fs" 테스트', () => {
    beforeEach(() => {
        mock({
            '경로1': {
                '하위_경로1': {
                    '파일_1.mdx': '파일 내용 mockup',
                    '파일_2.mdx': '파일 내용 mockup',
                },
            },
            '경로2/경로3': {
                '하위_경로2': {
                    // 빈 폴더
                },
            },
        });
    });

    it('"node:fs" 를 사용하여 파일을 가져올 수 있다.', async () => {
        const fileNameList = await fs.readdir('경로1/하위_경로1');

        expect(fileNameList).toEqual([
            '파일_1.mdx',
            '파일_2.mdx',
        ]);
    });
});
```

<br />

마지막으로 **mock-fs** 를 해제할 수 있도록 `jest.afterEach()` 를 작성하면 "node:fs" 유닛 테스트는 작성완료 됩니다.

```typescript {21} showLineNumbers
import fs from 'node:fs/promises';
import mock from 'mock-fs';

describe('mock-fs 를 사용한 "node:fs" 테스트', () => {
    beforeEach(() => {
        mock({
            '경로1': {
                '하위_경로1': {
                    '파일_1.mdx': '파일 내용 mockup',
                    '파일_2.mdx': '파일 내용 mockup',
                },
            },
            '경로2/경로3': {
                '하위_경로2': {
                    // 빈 폴더
                },
            },
        });
    });

    afterEach(mock.restore);

    it('"node:fs" 를 사용하여 파일을 가져올 수 있다.', async () => {
        const fileNameList = await fs.readdir('경로1/하위_경로1');

        expect(fileNameList).toEqual([
            '파일_1.mdx',
            '파일_2.mdx',
        ]);
    });
});
```



<br />



## 마치며

이번 포스팅에서는 built-in modules 중 "fs" 를 테스트하는 방법에 대해 정리해 보았습니다.

"fs" 가 아닌 다른 module 에 대한 테스트를 한다면, 결국은 Jest 공식문서에서 안내하는 mockup 방법도 사용해 보아야 할 것 같습니다.
e:Te10,---
id: 10
title: 'Gamma, GammFactor, sRGB 정리'
description: '디지털 환경에서 색상을 표현하는데 사용되는 일부 개념들을 정리합니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: true
tags: [
    'threejs',
    'gamma',
    'gamma factor',
    'sRGB',
]

createdAt: '2024-01-28 18:00:00'
modifiedHistories: []
---

# Gamma, GammFactor, sRGB 정리

Three.js 를 스터디하며 아래와 같은 용어를 접하게 되었습니다.

* Gamma
* GammaFactor`
* sRGB

<br />

이번 포스팅에서는 위 용어에 대한 개념을 정리하고 Three.js 에서는 어떻게 설정할 수 있는지 살펴 보겠습니다.

> 참고: [What is Gamma? - Benq](https://www.benq.com/en-us/knowledge-center/knowledge/gamma-monitor.html)
>
> 참고: [Deprecated Gamma Correction Alternative - discourse.threejs](https://discourse.threejs.org/t/deprecated-gamma-correction-alternative/57170)
>
> 참고: [sRGB - 위키피디아](https://en.wikipedia.org/wiki/SRGB)



<br />



## Gamma 란?

Gamma 는 이미지나 색상을 처리하는 기술 중 하나입니다.

**색상간의 밝기와 대비를 보정** 하거나, 사용자 **모니터의 특성을 보상** 하기 위해 사용되는 기술입니다.

<br />

좀 더 구체적으로 정의한다면 다음과 같습니다.

* **디지털 환경에서 Black 과 White 사이를 얼마나 부드럽게 전환(표현)할 것인지에 대한 수치** 입니다.

<br />

Gamma 는 **sRGB (Standard RGB)** 환경에서 사용되는 개념이며, 아래에서 정리하겠습니다.

<br />

Gamma 는 일반적으로 **2.2** 값을 사용합니다.

이 값은 **Gamma Curve** 를 그리는 연산식의 도출값인데, 값에 따른 차이를 비교하면 아래와 같습니다.

> 이미지 출처: [Deprecated Gamma Correction Alternative - discourse.threejs](https://discourse.threejs.org/t/deprecated-gamma-correction-alternative/57170)

<img src="/markdownAssets/threejs/2024-01-28-01/2024-01-28-01-01.png" alt="Gamma" />

<br />

<img src="/markdownAssets/threejs/2024-01-28-01/2024-01-28-01-02.png" alt="Gamma" />

<br />

<img src="/markdownAssets/threejs/2024-01-28-01/2024-01-28-01-03.png" alt="Gamma" />



## GammaFactor

GammaFactor 는 Three.js 에서 Gamma 를 지칭하는 property 입니다.

Three.js 구버전에서는 `WebGLRenderer` 인스턴스의 property 로 `gammaFactor` 를 설정할 수 있었습니다.

`gammaFactor` 는 Three.js 에서 **Deprecated** 되었고, 포스팅을 작성하는 시점의 Three.js 최신 버전인 `0.160.1` 에서는 사라진 설정입니다.

<br />

만약 구버전 Three.js 코드에서 `gammaFactor` 설정을 보게 된다면, 최신 버전에서는 **Light** 인스턴스의 **intensity (빛의 강함 설정)** 을 사용해 봅시다.



<br />



## sRGB

sRGB 는 **Standard RGB Color Space** 의 약자 입니다.

모니터, 프린터, 웹 과 같은 디지털 환경에서 색상을 표현하귀 위한 **표준 색상 공간(환경)** 입니다.

앞서 살펴보았던 **Gamma 의 기본값이 2.2 인 것은 sRGB 의 값을 2.2 로 사용** 한다는 의미로 보여집니다.



<br />



## 마치며

Three.js 스터디를 하는 중, gammaFactor 설정이 궁금하여 이번 포스팅을 작성하게 되었습니다.

의미와 용도 정도만 파악하려는 목적이었지만, gamma 와 sRGB 는 상당히 깊고 어려운 내용이었습니다.

지금은 간단한 의미 정도만 파악한 후, 차후 필요성이 생겼을 때 좀 더 깊게 알아볼 예정입니다.
f:T1171,---
id: 1
title: 구조 분해 할당의 기본값 지정, null 은 사용 불가!
description: '구조 분해 할당의 기본값 설정은 Nullish(undefined 와 null) 가 아닌, 오직 undefined 일 때만 적용됩니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'javascript',
]

createdAt: '2023-12-21 20:20:00'
modifiedHistories: []
---

# 구조 분해 할당의 기본값 지정, Null 은 사용 불가!

plain object 를 사용하여, 데이터를 의미단위로 묶어서 사용합니다.

의미를 가지는 key 와 쌍을 이루는 value 로 구성되며, Javascript built-in object 에도 많은 기능을 제공합니다.

이번 포스팅에서는 이러한 plain object 의 기능들 중, **구조 분해 할당의 기본값 설정** 에 대해 정리합니다.



<br />



## 구조 분해 할당의 기본값

구조 분해 할당은 plain object 의 하위 프로퍼티에 좀 더 효율적으로 참조하는 기능입니다.

```javascript title="구조 분해 할당 예시" showLineNumbers {8-14}
const obj = {
    keyA: 'value a',
    keyB: 'value b',
    keyC: undefined,
    keyD: null,
};

// 구조 분해 할당
const {
    keyA,
    keyB,
    keyC,
    keyD,
} = obj;
```

<br />

위 예시처럼 value 가 `undefined` 인 경우도 있고, `null` 인 경우가 있었습니다.

이러한 경우 **기본값을 지정하여 유효한 value 를 보장** 하도록 의도하였습니다.

```javascript title="구조 분해 할당의 기본값 예시" showLineNumbers {8-14}
const obj = {
    keyA: 'value a',
    keyB: 'value b',
    keyC: undefined,
    keyD: null,
};

// 구조 분해 할당 기본값 지정
const {
    keyA,
    keyB,
    keyC =. '빈 값',
    keyD = '빈 값',
};
```

<br />

여기서 제가 실수한 부분이 있습니다.

~~`value` 가 `Nullish (undefined 또는 null)` 일 경우, 기본값을 설정할 수 있다고 생각했습니다.~~

하지만 `null` 에는 기본값 설정이 불가능 하고, **`value` 가 `undefined` 일 경우에만 기본값을 설정** 할 수 있었습니다.

* [MDN - 구조 분해 할당](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%EA%B8%B0%EB%B3%B8%EA%B0%92)

<br />

제가 실수한 부분이 일으킨 이슈는 아래의 코드와 같습니다.

```javascript title="구조 분해 할당의 기본값 이슈" showLineNumbers {11-12, 15-17}
const obj = {
    keyA: 'value a',
    keyB: 'value b',
    keyC: undefined,
    keyD: null,
};

const {
    keyA,
    keyB,
    keyC = '값 없음',
    keyD = '값 없음',
} = obj;

// 에러 발생
// Error: Cannot read properties of null (reading 'toUpperCase')
console.log('keyD.toUpperCase(): ', keyD.toUpperCase());
```

<br />

`keyD` 에 기본값을 `string` 으로 지정하였지만, `null` 이므로 기본값 지정이 적용되지 않습니다.

그러므로 `keyD.toUpperCase()` 를 호출할 경우, `null` 에 대한 메소드 호출이 되며 에러가 발생하게 됩니다.



<br />



## null 은 명시적으로 표현한 값이 없음!

값이 없을을 나타내는 `undefined` 와 `null` 은 타입도 다르지만, 더 **중요한 것은 의미** 인 것 같습니다.

변수나 프로퍼티에 할당한 값이 없는 경우 `undefined` 를 가지고, `null` 은 개발자가 의도를 가지고 값을 비운다는 의미입니다.

즉, 의도를 가지고 비워둔 값에는 구조 분해 할당의 기본값이 적용되지 않는 것 입니다.

<br />

만약 `Nullish` 에 대한 기본값을 지정하고 싶을 경우는 **Nullish 병합 연산자** 를 사용합니다.

```javascript title="Nullish 병합 연산자" showLineNumbers {11-12, 15-16}
const obj = {
    keyA: 'value a',
    keyB: 'value b',
    keyC: undefined,
    keyD: null
};

const {
    keyA,
    keyB,
    keyC: _keyC,
    keyD: _keyD,
};

const keyC = _keyC ?? '값 없음';
const keyD = _keyD ?? '값 없음';
```



<br />



## 유감스러운 구조 분해 할당의 기본값

`undefined` 뿐만 아니라, `Nullish` 에 대한 기본값을 설정하고 싶다면, 위 예시코드와 같이 코드 1줄씩 추가로 작성하게 됩니다.

이 기능의 의미는 이해하지만, 작성할 코드가 늘어난다는 점에서는 아쉽습니다.

<br />

다른분들은 저와 같은 실수가 없기를 바라며, 이번 포스팅을 마무리 합니다.
10:T1174,---
id: 2
title: AWS S3 를 사용한 PDF 뷰어 구현시, Metadata 설정
description: 'AWS S3 에 업로드한 PDF 파일이 렌더링되지 않고 다운로드 되는 이슈에 대한 정리 입니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'javascript',
    'PDF',
    'PDF Metadata',
    'AWS',
    'S3',
]

createdAt: '2023-12-30 16:00:00'
modifiedHistories: []
---

# 웹에서 PDF 뷰어를 제공하는 방법

PDF 파일은 범용적으로 사용되는 문서 파일 입니다.

PDF 뷰어를 제공하는 방법에는 여러가지가 있습니다.

* `<iframe />`, `<object />`, `<embed />` 태그
* PDF 뷰어 관련 라이드러리들



<br />



## `<object />` 를 사용한 PDF 뷰어 구현하기

PDF 파일은 브라우저 내장 뷰어에서 다양한 기능을 제공합니다.

구현 초기에는 `<iframe />` 이나 `<object />` 의 보안문제를 피하기 위해, PDF 라이브러리를 사용하고자 하였습니다.

하지만 브라우저의 내장 PDF 뷰어의 강력한 기능들을 포기하거나 직접 구현해야 하는 문제가 있습니다.

<br />

이러한 이유로 `<object />` 태그를 사용하여 PDF 뷰어를 사용하기로 하였습니다.

또한 `<iframe />` 보다는 `<object />` 태그가 PDF 에는 적합하다는 MDN 공식문서에 따르게 되었습니다.

* 참고: [MDN 공식 문서](https://developer.mozilla.org/ko/docs/Learn/HTML/Multimedia_and_embedding/Other_embedding_technologies#embed_%EC%99%80_object_%EC%9A%94%EC%86%8C)



<br />



## `<object />` 를 사용하여 간단한 PDF 뷰어 만들기

아래와 같이 `<object />` 태그를 사용하여 간단하게 PDF 뷰어 기능을 사용할 수 있습니다.

```tsx title="PDF 뷰어 예시 코드" showLineNumbers
type TMyPdfViewerProps = {
    url: string;
}

function MyPdfViewer(props: TMyPdfViewerProps) {
    const {
        url,
    } = props;

    const data = `${url}#view=FitH`;

    return (<>
        <object 
            data={data}
            type='application/pdf' 
            width='100%' 
            height='100%' />
    </>);
}

export default MyPdfViewer;
```



<br />



## AWS S3 에 업로드한 PDF 파일이 다운로드되는 이슈

AWS S3 는 널리 사용되는 클라우드 스토리지 입니다.

PDF 파일을 S3 에 업로드한 후, `<MyPdfViewer />` 컴포넌트로 보여주고자 합니다.

만약 단순히 S3 에 PDF 파일을 업로드 했다면, `<object />` 에 연동한 **PDF 파일이 렌더링 되지 않고 다운로드되는 현상**을 마주하게 됩니다.



<br />



## PDF 파일이 다운로드만 되는 이유

AWS S3 에 파일을 업로드할 경우, 별도의 설정을 하지 않는다면 아래와 같은 **Metadata** 기본값으로 설정됩니다.

* `Content-Type: binary/octet-stream`
* `Content-Disposition: attachment`

<br />

위와 같은 파일을 브라우저에서 요청할 경우, 해당 파일은 첨부파일로 인식하고 다운로드하는 동작을 하게 됩니다.

AWS S3 에 업로드한 파일이 **단순 첨부파일 응답 으로 처리되기 때문에** `<object />` 태그에 렌더링되는 것이 아닌 다운로드가 됩니다.

<br />

이를 PDF 뷰어로 동작하도록 하려면, **AWS S3 에 업로드한 PDF 파일의 Metadata 를 아래와 같이 수정** 해서 해결할 수 있습니다.

* `Content-Type: application/pdf`
* `Content-Disposition: inline`

<br />

위와 같이 Metadata 를 변경했다면, `<object />` 태그에서 요청한 PDF 파일은 다운로드되지 않고 브라우저 내장 PDF 뷰어로 렌더링됩니다.



<br />



## 마치며

이번 이슈를 해결하기 위해, 최초 시도했던 방법은 AWS S3 에 PDF 파일을 별도로 요청한 후, 응답 결과인 PDF 파일 데이터를 `Blob` 으로 wrapping 하는 방식을 구현했습니다.

하지만 이렇게 wrapping 한 Blob 은 파일내용에 따라 렌더링이 되지 않는 이슈가 발생하였습니다.

Blob 으로 변환한 PDF 파일을 다운로드하여 확인하면 정상적으로 열리지만 `<object />` 태그에 렌더링되지 않는 경우가 있다보니, AWS S3 에 업로드한 파일의 Metadata 를 수정하는 방법을 사용하게 되었습니다.

이번 이슈를 통해, 파일을 다루는 경우에는 Metadata 에 대한 확인 및 설정이 필요하다는 것을 배우게 되었습니다.
11:T1598,---
id: 4
title: 'Nextjs 의 useRouter mock 정의하기'
description: 'Nextjs 의 useRouter 를 사용하는 컴포넌트를 테스트하기 위한 방법을 정리합니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'jest',
    '@testing-library',
    'useRouter',
    'next-router-mock',
    '유닛 테스트',
]

createdAt: '2024-01-06 17:30:00'
modifiedHistories: []
---

# Nextjs 의 useRouter mock 정의하기

페이지 이동을 위한 컴포넌트는 웹페이지에서 빠질 수 없는 컴포넌트 입니다.

Nextjs 프로젝트에서 페이지 이동은 Nextjs 의 `useRouter` hook 을 사용하여 구현합니다.

이러한 컴포넌트는 내부에서 `useRouter` 를 사용하고 있기 때문에, Jest 의 `render()` 를 사용한 렌더링 시, 에러가 발생하게 됩니다.

이번 포스팅에서는 `useRouter` 를 mocking 하여 테스트 하는 방법에 대해 정리하고자 합니다.



<br />



## 컴포넌트 렌더링 실패

`useRouter` 를 사용하는 컴포넌트를 아무런 설정없이 Jest 의 `render()` 를 실행시키면, 렌더링 에러가 발생합니다.

이는 테스트 환경에서 `useRouter()` 가 렌더링 되지 않으면서 발생하게 됩니다.

이를 해결하기 위해, `next-router-mock` 라이브러리를 활용할 수 있습니다.

```bash
yarn add -D next-router-mock
```



<br />



## `useRouter` 를 사용하는 테스트용 컴포넌트

이번 포스트에서 테스트할 컴포넌트는 아래와 같습니다.

`onClick()` 내부에서 `router.push()` 를 사용하여 페이지를 이동 시키는 동작을 합니다.

```tsx title="MyAnchor.tsx" showLineNumbers
import {
    useCallback,
    PropsWithChildren,
} from 'react';
import {
    useRouter,
} from 'next/navigation';

type TMyAnchorProps = PropsWithChildren<{
    className?: string;
    href: string;
}>;

function MyAnchor(props: TMyAnchorProps) {
    const {
        className,
        href,
        children,
    } = props;

    const router = useRouter();

    const onClick = useCallback(() => {
        router.push(href);
    }, [href]);

    return (
        <a 
            className={className}
            href={href}>
            {children}
        </a>
    );
}

export default MyAnchor;
```



<br />



## `jest.mock()` 을 사용하여 `useRouter()` mocking 하기

`jest.mock()` 을 사용하면, 특정 모듈을 mocking 할 수 있습니다.

이를 활용하여, `next/navigation` 모듈을 mocking 하여 `useRouter` 가 테스트 환경에서 렌더링될 수 있도록 합니다.

```ts title="jest.mock() 으로 useRouter mocking 하기"
jest.mock('next/navigation', () => jest.requireActual('next-router-mock'));
```

* `jest.mock()`: 특정 모듈을 mocking 합니다.
    * 첫번째 인자: mocking 할 모듈명
    * 두번째 인자: mocking 반환 함수
* `jest.requireActual()`: 실제 모듈을 가져옵니다. (`import`, `require`)

<br />

위 코드를 사용하여 `useRouter` 를 mocking 하게 되면, 정상적으로 렌더링됨을 확인할 수 있습니다.

아래는 테스트 예시 코드 입니다.

```tsx title="MyAnchor 테스트" showLineNumbers {7, 9, 12-15, 48-50}
import MyAnchor from './MyAnchor';
import {
    render,
    screen,
} from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import mockRouter from 'next-router-mock';

jest.mock('next/navigation', () => jest.requireActual('next-router-mock'));

describe('<MyAnchor /> 테스트', () => {
    beforeEach(() => {
        // mockRouter 의 pathname 을 '/' 으로 초기화 합니다.
        mockRouter.push('/');
    });

    it('DOM 에 렌더링 된다.', () => {
        render(
            <div data-testid="test-MyAnchor">
                <MyAnchor href="/test-url">
                    Test Page
                </MyAnchor>
            </div>
        );

        const $anchor = screen.getByTestId('test-MyAnchor');

        expect($anchor).toBeInTheDocument();
    });

    it('click 시, href 경로로 페이지 이동한다.', async () => {
        render(
            <div data-testid="test-MyAnchor">
                <MyAnchor 
                    className="test-className"
                    href="test-url">
                    Test Page
                </MyAnchor>
            </div>
        );

        const $anchor = screen
            .getByTestId('test-MyAnchor')
            .querySelector('.test-className');

        await userEvent.click($anchor);

        expect(mockRouter).toMatchObject({
            pathname: '/test-url',
        });
    });
});
```

<br />

그리고 `router` 가 클릭된 후, 페이지 이동이 되었는지 테스트하기 위해, `mockRouter` 를 활용할 수 있습니다.

`mockRouter` 의 `pathname` 에 이동할 페이지의 url 이 반영되었다면, 실제로는 페이지 이동이 된 것으로 볼 수 있습니다.



<br />



## 마치며

프레임워크는 개발에 필요한 다양한 기능을 제공합니다.

이를 테스트하기 위해서는 프레임워크와 동일한 환경을 만들어주어야 함을 알게 되었습니다.

단순 컴포넌트나 함수를 테스트할 때는 신경쓰지 않았던 **모듈 mocking** 이 필요하고, `jest.mock()` 을 사용하여 mocking 할 수 있었습니다.

`next-router-mock` 라이브러리 처럼 오픈 소스 문화가 있기에 저도 웹 개발을 할 수 있음을 새삼 느끼게 됩니다. 🫠
12:T14bb,---
id: 3
title: '"styled-components" 로 구현한 컴포넌트 테스트하기'
description: '"styled-components" 를 사용한 컴포넌트를 테스트하기 위한 환경설정에 대해 알아봅니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'jest',
    'styled-components',
    '@testing-library',
    '유닛 테스트',
]

createdAt: '2023-12-26 23:50:00'
modifiedHistories: []
---

# styled-components 로 구현한 컴포넌트 테스트하기

컴포넌트의 style 작성에는 여러가지 선택지가 있습니다.

그 중 저는 **styled-components** 를 가장 선호합니다.

이번 포스팅에서는 **styled-components** 를 사용한 컴포넌트를 테스트하기 위한 jest 환경을 설정해보겠습니다.



<br />



## 설정없이 jest 를 실행하면? throw Error!

**styled-components** 는 `<ThemeProvider />` 하위에서 사용할 수 있습니다.

만약 추가 설정없이 jest 를 실행하게 되면, `render()` 호출에서 에러가 발생합니다.

```tsx title="에러 발생 예시" showLineNumbers {10-12}
import MyComponent from './MyComponent';
import {
    render,
} from '@testing-library/react';

describe('MyComponent 테스트', () => {
    it('DOM 에 렌더링 된다.', () => {
        // render() 호출 시, Error 발생
        render(
            <div data-testid="my-component">
                <MyComponent />
            </div>
        );

        const $myComponent = screen.getByTestId('my-component');

        expect($myComponent).toBeInTheDocument();
    });
});
```

```bash title="에러 메시지"
TypeError: Cannot read properties of undefined (reading 'MarkdownAnchor')
```

<br />

아래와 같이 `render()` 호출부에 `<ThemeProvider />` 를 함께 넘겨주면 테스트가 정상적으로 실행되는 것을 확인할 수 있습니다.

```tsx title="테스트 정상 동작" showLineNumbers {11, 13}
import MyComponent from './MyComponent';
import {
    render,
} from '@testing-library/react';

describe('MyComponent 테스트', () => {
    it('DOM 에 렌더링 된다.', () => {
        // render() 성공
        render(
            <div data-testid="my-component">
                <ThemeProvier theme={theme}>
                    <MyComponent />
                </ThemeProvier>
            </div>
        );

        const $myComponent = screen.getByTestId('my-component');

        // 테스트 통과
        expect($myComponent).toBeInTheDocument();
    });
});
```



<br />



## util 또는 hook 으로 `<ThemeProvider />` 제공하기

테스트 코드를 작성할 때, 각 테스트 케이스별로 중복되는 코드들이 생기게 됩니다.

이러한 부분들을 공통 함수로 묶어내거나 추상화하지 않는 이유는, 테스트 코드를 읽어나가는 것으로 어떤 테스트를 수행하는지 파악할 수 있는 것이 더 테스트 코드의 가치를 높이기 때문입니다.

<br />

하지만 `<ThemeProvider />` 를 감싸는 코드는 **styled-components** 설정을 테스트하는 것이 아닌 이상, 특정 컴포넌트를 테스트하는데 의미를 두기 어렵습니다.

그러므로 이 부분은 별도의 **util 함수** 또는 **custom hook** 으로 분리하여 사용해도 무방해 보입니다.

<br />

저는 **@testing-library** 에서 제공하는 `render()` 함수 처럼 `util 함수` 로 만드는 것이 좀 더 일관되는 패턴으로 생각하여 아래와 같이 작성해 보았습니다.

```tsx title="@/utils/testing-library/renderTestComponent.tsx" showLineNumbers
// react
import { 
    ReactElement,
} from 'react';
// jest
import { 
    render,
} from '@testing-library/react';
// styled-components
import { 
    ThemeProvider,
} from 'styled-components';
import theme from '@/styles/theme';

const renderTestComponent = (element: ReactElement) => {
    const { rerender } = render(
        <ThemeProvider theme={theme('light')}>
            {element}
        </ThemeProvider>
    );

    return {
        rerender,
    };
};

export default renderTestComponent;
```

<br />

이를 테스트 코드에 적용하면 다음과 같습니다.

```tsx title="util 함수를 적용한 테스트 코드" showLineNumbers {5, 10}
import MyComponent from './MyComponent';
// import {
//     render,
// } from '@testing-library/react';
import renderTestComponent from '@/utils/testing-library/renderTestComponent';

describe('MyComponent 테스트', () => {
    it('DOM 에 렌더링 된다.', () => {
        // render() 성공
        renderTestComponent(
            <div data-testid="my-component">
                <MyComponent />
            </div>
        );

        const $myComponent = screen.getByTestId('my-component');

        // 테스트 통과
        expect($myComponent).toBeInTheDocument();
    });
});
```



<br />



## 마치며

유닛 테스트를 하나씩 추가하며, coverage 가 높아져 가는 것이 하나의 재미요소가 되었습니다.

`renderTestComponent()` 처럼 테스트 환경을 위한 기능을 만드는 과정은 성취감과 연결되었습니다.

이 블로그 프로젝트는 개발 초기 시점인 만큼, 모든 컴포넌트를 테스트할 수 있도록 목표를 잡아야겠습니다!
13:T15fe,---
id: 2
title: '"jest.fn()" 으로 함수 테스트하기'
description: '컴포넌트 props 로 넘겨주는 함수를 테스트하는 방법으로 "jest.fn()" 사용방법에 대한 정리 입니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'jest.fn',
    'jest',
    '@testing-library',
    '유닛 테스트',
]

createdAt: '2023-12-23 14:45:00'
modifiedHistories: []
---

# "jest.fn()" 으로 함수 테스트하기

컴포넌트에는 props 를 사용하여 데이터와 함수를 넘겨주도록 만들 수 있습니다.

이번 포스팅에서는 `jest.fn()` 을 사용하여 컴포넌트에 넘겨준 함수가 정상동작하는지 테스트하는 방법에 대해 정리합니다.



<br />



## 컴포넌트 props 에 넘겨주는 함수

컴포넌트 props 에는 함수를 넘겨줄 수 있습니다.

사용자 인터렉션을 처리하기 위한 함수가 될 수도 있고, 특정 동작에 대한 callback 으로 활용되도록 구현할 수 있습니다.

이렇게 넘겨준 함수가 의도한 시점, 상황에 호출이 되는지 테스트하고자 합니다.



<br />



## 테스트 예시 컴포넌트

이번 포스팅에서 테스트에 사용할 input 컴포넌트를 만들어보겠습니다.

```typescript title="./ChocobeInput.tsx" showLineNumbers
import {
    useCallback,
    memo,
    ChangeEvent,
} from 'react';

type TChocobeButtonProps = {
    value: string;
    onChange: (value: string) => void;
};

function ChocobeInput(props: TChocobeInputProps) {
    const {
        value,
        onChange,
    } = props;

    //
    // callback
    //
    const onChangeInput = useCallback((e: ChangeEvent<HTMLInputElement>) => {
        const value = e.target.value;
        onChange(value);
    }, [onChange]);

    return (
        <input
            value={value}
            onChange={onChangeInput} />
    );
}

export default memo(ChocobeInput);
```



<br />



## `jest.fn()` 으로 onChange mockup function 만들기

* 참고: [[Jest 공식 문서] Using a mock function](https://jestjs.io/docs/mock-functions#using-a-mock-function)

`Jest` 는 `fn()` 이라는 **함수 mockup 메소드** 를 제공하고 있습니다.

위 예시 컴포넌트를 테스트한다면, `props.onChange()` 를 테스트하기 위해 `jest.fn()` 을 사용하게 됩니다.

```typescript title="jest.fn() 으로 mockup function 생성하기" showLineNumbers {11, 16}
// UI Components
import ChocobeInput from './ChocobeInput';
// jest
import {
    render,
    screen,
} from '@testing-library/react';

describe('ChocobeInput 컴포넌트 테스트', () => {
    it('ChocobeInput 에 값을 입력하면 onChange() 가 호출된다.', async () => {
        const fn_onChange = jest.fn();

        render(
            <ChocobeInput
                value=""
                onChange={fn_onChange} />
        );
    });
});
```



<br />

## input 요소에 KeyboardEvent 발생시키기

`fn_onChange()` 함수는 `<ChocobeInput />` 컴포넌트에 `KeyboardEvent` 가 발생하면 호출되는 구조 입니다.

`userEvent` 를 사용하여 `KeyboardEvent` 나 `click` 이벤트 등을 발생시킬 수 있으며, `<ChocobeInput />` 컴포넌트의 경우에는 `KeyboardEvent` 가 발생하면 `onChange()` 가 호출됩니다.

컴포넌트에 `KeyboardEvent` 를 발생시키려면 `userEvent.type()` 메소드를 활용하게 됩니다.

```typescript title="userEvent.type() 으로 KeyboardEvent 발생시키기" showLineNumbers {24}
// UI Components
import ChocobeInput from './ChocobeInput';
// jest
import {
    render,
    screen,
} from '@testing-library/react';
import {
    userEvent,
} from '@testing-library/user-event';

describe('ChocobeInput 컴포넌트 테스트', () => {
    it('ChocobeInput 에 값을 입력하면 onChange() 가 호출된다.', async () => {
        const fn_onChange = jest.fn();

        render(
            <ChocobeInput
                value=""
                onChange={fn_onChange} />
        );

        const $chocobeInput = screen.getByRole('textbox');

        await userEvent.type($chocobeInput, 'Hello');
    });
});
```



<br />



## KeyboardEvent 에 의해 fn_onClick() 호출 여부 테스트하기

위 예시 코드를 통해 `<ChocobeInput />` 컴포넌트에 `KeyboardEvent` 가 발생한 상태 입니다.

`userEvent.type(요소, 입력값)` 으로 넘겨준 `입력값` 은 문자 1개당 1번의 KeyboardEvent 가 발생하게 되므로, 총 5번의 KeyboardEvent 가 발생한 상태 입니다.

이를 테스트하면 다음과 같습니다.

```typescript title="발생한 이벤트 테스트" showLineNumbers
// UI Components
import ChocobeInput from './ChocobeInput';
// jest
import {
    render,
    screen,
} from '@testing-library/react';
import {
    userEvent,
} from '@testing-library/user-event';

describe('ChocobeInput 컴포넌트 테스트', () => {
    it('ChocobeInput 에 값을 입력하면 onChange() 가 호출된다.', async () => {
        const fn_onChange = jest.fn();

        render(
            <ChocobeInput
                value=""
                onChange={fn_onChange} />
        );

        const $chocobeInput = screen.getByRole('textbox');

        await userEvent.type($chocobeInput, 'Hello');

        expect(fn_onChange).toHaveBeenCalledTimes(5);
    });
});
```



<br />



## 마치며

함수 테스트는 `jest.fn()` 뿐만 아니라 `jest.spyOn()` 으로도 가능합니다.

다음 포스팅에서는 `jest.spyOn()` 으로 테스트하는 방법과 `jest.fn()` 과 차이점에 대해 정리하겠습니다.
14:T1e27,---
id: 1
title: LLMOps 와 친해지기 1 - 용어 정리
description: 'AI 학습 모델인 Large Language Model 에 대한 정리입니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: []

createdAt: '2023-12-16 15:00:00'
modifiedHistories: []
---

# LLMOps 와 친해지기 1 - 용어 정리

**LLMOps** 란, Large Language Model 의 약자이며 대규모 언어 모델 입니다.

사내 신규 프로젝트로 **LLMOps** 를 사용하기 위한 UI 툴 서비스를 개발하게 되었습니다.

개발할 서비스에 대한 도메인 지식이 필요함을 느끼게 되었기에, 관련 용어와 개념을 정리하고자 합니다.

일반인의 시야에서 조사한 내용을 정리하는 목적을 가지고 LLM 에 초점을 가지므로, 좀 더 정확한 내용은 첨부한 **참고 링크** 를 확인해주세요.



<br />



## 용어 정리

### 머신러닝

> 참고: [Machine learning (ML) –  머신러닝 이란?](https://www.ibm.com/kr-ko/topics/machine-learning)

<br />

기계학습 방법을 말합니다.

**딥러닝** 이 아닌 **머신러닝** 은 정형화된 데이터를 학습하며 사람의 개입이 많이 필요합니다.

정형화된 데이터란 데이터 각각에 대하여 **labeling** 이나 **tagging** 작업을 한 학습 데이터를 말합니다.

데이터가 많을수록 좋은 결과를 기대할 수 있기 때문에, 정형화된 데이터를 만드는 과정부터 많은 시간과 노력이 필요하게 됩니다.



<br />



### 딥러닝

> 참고: [Machine learning (ML) –  머신러닝 이란?](https://www.ibm.com/kr-ko/topics/machine-learning)

<br />

머신러닝의 하위 분야이며, 머신러닝 처럼 정형화된 데이터로 학습할 수 있으며, 추가로 비정형 데이터를 학습할 수도 있습니다.

비정형 데이터 학습을 위해 사용되는 개념으로 **신경망** 이 있습니다.



<br />



### 신경망

> 참고: [AWS - 신경망이란 무엇인가요?](https://aws.amazon.com/ko/what-is/neural-network/)
>
> 참고: [Machine learning (ML) –  머신러닝 이란?](https://www.ibm.com/kr-ko/topics/machine-learning)

<br />

신경망은 머신러닝의 하위 분야이며 딥러닝의 기계 학습 알고리즘 중 하나입니다.

신경망은 구조화 되지 않은 데이터와 명시적이지 않은 훈련 방식을 사용하며, 이렇게 학습한 데이터를 **일반화** 하고 **추론** 할 수 있습니다.

예를 들면 다음과 같습니다.

```bash
질문1: "결제 방법을 알려줘"

질문2: "비용 송금 방법을 알려줘"
```

위 질문은 문장은 다르지만, 컴퓨터는 신경망을 통해 "결제 방법 안내" 라는 동일한 문맥임을 이해합니다.

<br />

신경망은 **노드** 로 구성되며, 노드에는 **입력 노드**, **출력 노드** 등, 무수히 많은 노드로 구성됩니다.

각 노드는 **관련성에 대한 임계치** 가 있으며, 임계치에 다다르면 활성화 되는데, 이러한 방식으로 관련된 노드들의 활성화를 통해 **일반화** 와 **추론** 을 할 수 있게 됩니다.



<br />



### MLOps

> 참고: [MLOps란?](https://www.ibm.com/kr-ko/topics/machine-learning)

<br />

**MLOps** 는 **Machine Learning** 과 **Operations** 의 합성어로, 효율적인 머신러닝 **모델 개발**, **배포**, **운용** 을 위한 개발 방법론이며, **새로운 모델 개발이 목적** 입니다.

**MLOps** 를 구성하는 요소는 다음과 같습니다.

* 지속적 통합 (**CI**: Continuous Integration)
* 지속적 배포 (**CD**: Continuous Deployment)
* 지속적 학습 (**CT**: Continuous Training)



<br />



### FMOps

> 참고: [카카오엔터프라이즈 기술블로그 Tech&(테크앤):티스토리](https://tech.kakaoenterprise.com/196)

**FM(Foundation Model)** 을 한국어로 **기반 모델** 이라고 합니다.

**FMOps(Foundation Model Operations)** 는 **기반 모델 개발**, **배포**, **운용** 을 위한 개발 방법론 입니다.

**FMOps(Foundation Model Operations)** 에는 자연어 뿐만 아니라, 이미지나 음성을 기반으로 하는 모델(예시: **DALL-E**) 을 모두 포함합니다.



<br />



### LLMOps

> 참고: [카카오엔터프라이즈 기술블로그 Tech&(테크앤):티스토리](https://tech.kakaoenterprise.com/196)

<br />

**FMOps** 에 포함되는 개념이며, **자연어 처리** 를 위한 개념으로 **LLM(Large Language Model)** 이 있습니다.

**LLMOps(Large Langague Model Operations)** 는 **LLM 개발**, **배포**, **운용** 을 위한 개발 방법론입니다.



<br />



### MLOps 와 FMOps 비교

> 참고: [카카오엔터프라이즈 기술블로그 Tech&(테크앤):티스토리](https://tech.kakaoenterprise.com/196)

<br />

* 목적
    * MLOps: **새로운 모델을 개발** 합니다.
    * FMOps: 이미 학습이 완료된 모델과 자신의 데이터를 사용하여, **자신만의 AI 앱을 개발** 합니다.
* 다루는 모델 유형
    * MLOps: 기업이 직접 모델과 파이프라인 모두 개발하게 됩니다.
    * FMOps: **API 를 통해서 원하는 모델을 사용** 합니다.
* 산출물
    * MLOps: **Model** 과 이를 사용할 수 있는 **API** 를 만들게 됩니다.
    * FMOps: LLM 과 사용자의 커스텀 데이터를 사용한 **AI 어플리케이션** 을 만들게 됩니다.



<br />



### 프롬프트

> [프롬프트 (Prompt) 란 무엇인가? - 정의, 원리, fine tuning](https://www.thedatahunt.com/trend-insight/what-is-prompt)

<br />

개발 환경에서는 다양한 설정과 실행방법이 있습니다.

이를 UI 로 모두 제공하는 것은 어렵기도 하고, 사용성도 복잡해집니다.

그래서 CLI 를 사용하는 경우가 많습니다.

프롬프트란, 컴퓨터에게 실행할 태스크를 전달하는 메시지, **명령어** 라는 의미를 가집니다.

AI 가 발전함에 따라 현재는 명령어뿐만 아니라, 자연어까지 컴퓨터가 이해할 수 있게 되어서, 프롬프트의 의미는 **컴퓨터에게 어떤 태스크를 수행할지 전달하는 자연어 메시지** 라는 의미로 확장되었습니다.



<br />



### 프롬프트 체이닝

> 참고: [카카오엔터프라이즈 기술블로그 Tech&(테크앤):티스토리](https://tech.kakaoenterprise.com/196)

<br />

프롬프트를 잘 작성할수록 AI 는 더 정확한 응답을 할 수 있습니다.

LLM 에 하나의 프롬프트를 연결하여 AI 앱을 만들수도 있지만, 더 정확한 기능을 구현하기 위해 LLM 에 외부의 프롬프트를 포함하여 복수의 프롬프트를 연결하여 개발하게 되는데, 이를 **프롬프트 체이닝(Prompt Chaing)** 이라고 합니다.



<br />



### LangChain

> 참고: [카카오엔터프라이즈 기술블로그 Tech&(테크앤):티스토리](https://tech.kakaoenterprise.com/196)

<br />

**LangChain** 은 **프롬프트 체이닝** 을 지원하는 프레임워크 입니다.

LLM 과 외부의 프롬프트들을 자유롭게 연결할 수 있는 기능을 제공합니다.



<br />



### LLM 앱 개발 플렛폼

LLM 과 LangChain 을 사용하여 AI 앱을 만들 수 있는 플렛폼이 있습니다. (프롬프트 체이닝 서비스 플렛폼)

대표적으로 **LangFlow** 와 **FlowiseAI** 가 있습니다.

<br />

* LangFlow:
    * [LangFlow Github](https://github.com/logspace-ai/langflow)
    * 서버: `Python`
    * 프론트: `React(Typescript)`
* FlowiseAI
    * [FlowiseAI Github](https://github.com/FlowiseAI/Flowise)
    * 서버: `Express(Typescript)`
    * 프론트: `React(Javascript)`
15:T1d77,---
id: 1
title: Nextjs 프로젝트의 유닛 테스트
description: '유닛 테스트를 위해 Jest 와 @testing-library 설치 및 설정에 대한 정리 입니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'nextjs',
    'jest',
    '@testing-library',
    'react',
    '유닛 테스트',
]

createdAt: '2023-12-16 22:13:00'
modifiedHistories: []
---

# Nextjs 프로젝트의 유닛 테스트

* 참고: [Next.js with React Testing Library, Jest, and TypeScript](https://medium.com/readytowork-org/next-js-with-react-testing-library-jest-and-typescript-a6aa11b85434)
* 참고: [Nextjs 공식문서](https://nextjs.org/docs/pages/building-your-application/testing/jest)



<br />



<details>
<summary>유닛 테스트를 멀리한 핑계와 결심</summary>

<br />

스타트업에 재직하며 다양한 프로젝트를 개발하고 있습니다.

진행했던 프로젝트를 되돌아보면, 한결같이 시간이 부족하였고, 이를 핑계삼아 유닛 테스트 없이 기능 구현만을 하였습니다.

<br />

### 🤪 유닛 테스트 없이도 개발 가능한데?

테스트에 관한 블로그 글이나 **클린코드** 와 같은 책에서 언급한 **코드에 대한 신뢰도** 는 사실 체감을 하지 못하였습니다.

오히려 유닛 테스트 작성 때문에 기능 구현할 시간을 뺏긴다는 느낌이 컸고, 유닛 테스트 없이도 기능 개발은 충분히 가능했습니다.

<br />

### 😰 `console.log` 와 수작업 테스트 노가다...

기능 개발을 완료한 후, 기억이 흐릿해질 정도로 시간이 지나서 기능 추가/수정 작업이 생겼습니다.

기억을 상기하기 위해 여기 저기에 `console.log()` 를 작성하였고, 기능 추가 후에는 남아있는 `console.log()` 를 제거하는 귀찮은 작업들이 남게 되었습니다.

사실 함수명, 메소드명, 변수명 등이 모두 명확하고, 모든 코드가 서로 의존성 없이 독립적인 기능을 한다면 `console.log()` 로 확인하는 작업이 필요 없을 수 있습니다.

하지만 기능이 언제나 단순 명료하게 구현될 수 없고, 더더욱 이 코드를 작성한 저의 코드 품질에 부족함이 많기 때문에 `console.log()` 노가다와 함께할 가능성이 보였습니다.

**그리고 가장 큰 문제는, 변경된 기능이 다른 부분에 영향을 미치는지, 버그를 찾기위한 반복된 수작업 테스트를 하게 되었습니다.**

기능을 추가하는 코드 베이스가 클 수록, 수작업 테스트는 상당한 시간을 소비하게 하였습니다.

<br />

### 🤓 유닛 테스트를 사용한 테스트 자동화가 필요해!

만약 유닛 테스트를 작성해 두었다면, 아래와 같은 보상이 있었다고 생각됩니다.

* 현재 코드가 테스트에 통과하고 있으므로, 적어도 작성된 **Test Case** 내에서는 신뢰할 수 있는 코드다.
* 테스트 대상이 지원하는 모든 기능과 `porps` 에 대하여, 독립적인 **Use Case** 를 확인할 수 있다.
* **수정한 코드가 의도한 부분에만 적용됨을 보장 받을 수 있다.**

<br />

위와 같은 기대값을 가지며, **유닛 테스트에 대한 결심** 을 하게 되었습니다.

</details>



<br />



## 유닛 테스트 라이브러리 설치

유닛 테스트를 위해, `jest` 와 `@testing-library` 를 사용하고자 합니다.

```bash title="jest 관련 패키지"
yarn add -D jest ts-jest ts-node jest-environment-jsdom @types/jest
```

```bash title="@testing-library 관련 패키지"
yarn add -D @testing-library/jest-dom @testing-library/react @testing-library/user-event
```


<br />



## jest 실행을 위한 명령어 추가하기

`package.json` 의 `scripts` 를 통해 프로젝트에 대한 명령어를 추가할 수 있습니다.

단발성 테스트를 위한 명령어와 코드 변경마다 테스트를 실행하는 명령어를 추가합니다.

```json title="package.json" {5-7}
{
    // ...
    "scripts": {
        // ...
        "test": "jest",
        "test:watch": "jest --watch",
        "test:watchAll": "jest --watchAll"
    },
    // ...
}
```



<br />



## jest 설정하기

[Nextjs 공식 문서](https://nextjs.org/docs/pages/building-your-application/testing/jest#manual-setup) 에서도 **jest** 와 **@testing-library** 를 사용하는 방법에 대해 안내하고 있습니다.

<br />

**jest.config.ts** 파일을 사용하여 설정할 수 있습니다.

직접 파일을 생성하지 않고, CLI 를 통해 설정 템플릿을 생성하여 수정하는 방향으로 설정하겠습니다.

터미널에서 아래의 명령을 실행합니다.

```bash title="npm 으로 jest.config.ts 생성하기"
npm init jest@latest
```

```bash title="yarn 으로 jest.config.ts 생성하기"
yarn create jest@latest
```

<br />

명령을 실행하면, 몇가지 질문(Y/N)으로 기본 설정값이 반영된 **jest.config.ts** 파일이 생성됩니다.

생성된 **jest.config.ts** 를 아래와 같이 수정합니다.

```typescript showLineNumbers
import {
    Config,
} from 'jest';
import nextJest from 'next/jest.js';

const createJestConfig = nextJest({
    dir: './',
});

/**
 * For a detailed explanation regarding each configuration property, visit:
 * https://jestjs.io/docs/configuration
 */

const config: Config = {
    // The directory where Jest should output its coverage files
    coverageDirectory: "coverage",

    // Indicates which provider should be used to instrument code for coverage
    coverageProvider: "babel",

    // A preset that is used as a base for Jest's configuration
    preset: "ts-jest",

    // A list of paths to modules that run some code to configure or set up the testing framework before each test
    setupFilesAfterEnv: ["<rootDir>/jest.setup.ts"],

    // The test environment that will be used for testing
    testEnvironment: "jest-environment-jsdom",
};

export default createJestConfig(config);
```

<br />

`jest.config.ts` 파일의 **26번줄** 에서 설정한 **jest.setup.ts** 파일을 생성하고 아래의 코드를 작성합니다.

```typescript title="jest.setup.ts"
import '@testing-library/jest-dom';
```

**jest.setup.ts** 에서 `import` 하는 모듈은 **@testing-library** 에서 제공하는 **확장 matcher** 를 사용할 수 있게 해줍니다.

이로써 Nextjs 의 유닛 테스트 설정을 완료 하였습니다.



<br />



## 첫번째 컴포넌트 테스트 만들기

먼저 테스트를 할 React 컴포넌트를 만들겠습니다.

```tsx title="Hello.tsx"
function Hello() {
    return (
        <h1>
            Hello World
        </h1>
    );
}

export default Hello;
```

<br />

*Hello.tsx* 와 동일한 경로에 **Hello.spec.tsx** 파일을 생성하고, 유닛 테스트를 작성합니다.

```typescript title="Hello.spec.tsx"
import Hello from './Hello';
import {
    render,
    screen,
} from '@testing-library/react';

describe('<Hello /> 컴포넌트 유닛 테스트', () => {
    it('Dom 에 렌더링 됨', () => {
        render(<Hello />);

        const $hello = screen.getByRole('heading', {
            level: 1,
        });

        expect($hello).toBeInTheDocument();
    });
});
```

<br />

유닛 테스트를 작성한 후, 터미널에 아래의 명령어로 테스트를 실행할 수 있으며, 모든 테스트가 통과됨을 확인할 수 있습니다.

```bash title="jest 실행하기"
yarn test
```
16:T2361,---
id: 1
title: Custom Hook 으로 분리하며 발생한 실수
description: 'Custom Hook 으로 분리한 useEffect 가 여러번 호출 케이스 중 한가지를 정리합니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'react',
    'custom hook',
]

createdAt: '2023-12-19 22:50:00'
modifiedHistories: []
---

# Custom Hook 으로 분리하며 발생한 실수

## 실수가 발생한 상황

페이지가 mount 되면 API 를 호출하는 흐름은 빈번히 사용됩니다.

그리고 API 응답을 받으면, 후처리를 하는 `useEffect` 를 사용할 수 있습니다.

<br />

이번 이슈에서는 Custom Hook 으로 나누기 전까지는 의도한 대로 API 응답과 Effect 가 1:1 로 실행되었습니다.

```tsx title="MyPage.tsx" showLineNumbers {28-30, 32-34}
import {
    useCallback,
    useEffect,
} from 'react';
import {
    useAppSelector,
} from '@/redux/hooks';

function MyPage() {
    const triggerState = useAppSelector(({ triggerState }) => triggerState);

    const responseOfApi_1 = useAppSelector(({ api_1 }) => api_1);
    const responseOfApi_2 = useAppSelector(({ api_2 }) => api_2);

    const callApi_1 = useCallback(() => {
        // API 호출 1
    }, []);

    const callApi_2 = useCallback(() => {
        // API 호출 2
    }, []);

    useEffect(function handleTriggerState() {
        callApi_1();
        callApi_2();
    }, [triggerState]);

    useEffect(function onSuccessApi_1() {
        // API 1 응답 후처리
    }, [responseOfApi_1]);

    useEffect(function onSuccessApi_2() {
        // API 2 응답 후처리
    }, [responseOfApi_2]);

    return (
        // ...
    );
}

export default MyPage;
```

<br />

이런 방식으로 **호출하는 API 가 늘어나자, 컴포넌트가 점점 복잡해졌습니다.**

**또한 사용자 인터렉션에 의해 다시 호출해야 하는 API 도 있어서** Custom Hook 으로 분리하여 재사용하는 방향으로 생각하게 되었습니다.

<br />

리펙토링 결과, API 후처리를 담당하는 `useEffect` 가 번복 실행되는 현상이 나타났습니다.

```tsx title="./hooks/useApi_1.ts" showLineNumbers {16-18}
import {
    useCallback,
    useEffect,
} from 'react';
import {
    useAppSelector
} from '@/redux/hooks';

const useApi_1 = () => {
    const responseOfApi_1 = useAppSelector(({ api_1 }) => api_1);

    const callApi_1 = useCallback(() => {
        // API 호출 1
    }, []);

    useEffect(function onSuccessApi_1() {
        // (번복 실행됨) API 1 응답 후처리
    }, [responseOfApi_1]);

    return {
        callApi_1,
    };
};

export default useApi_1;
```

```tsx title="./hooks/useApi_2.ts" showLineNumbers {16-18}
import {
    useCallback,
    useEffect,
} from 'react';
import {
    useAppSelector
} from '@/redux/hooks';

const useApi_2 = () => {
    const responseOfApi_2 = useAppSelector(({ api_2 }) => api_2);

    const callApi_2 = useCallback(() => {
        // API 호출 2
    }, []);

    useEffect(function onSuccessApi_2() {
        // (번복 실행됨) API 2 응답 후처리
    }, [responseOfApi_2]);

    return {
        callApi_2,
    };
};

export default useApi_2;
```

```tsx title="MyPage.tsx" showLineNumbers {10-11, 13-16}
import {
    useEffect,
} from 'react';
import useApi_1 from './hooks/useApi_1';
import useApi_2 from './hooks/useApi_2';

function MyPage() {
    const triggerState = useAppSelector(({ triggerState }) => triggerState);

    const { callApi_1 } = useApi_1();
    const { callApi_2 } = useApi_2();

    useEffect(function onSuccessApi_2() {
        callApi_1();
        callApi_2();
    }, [triggerState]);

    return (
        // ...
    );
};

export default MyPage;
```



<br />



## useEffect 의 dependencies 는 무죄

`useEffect` 의 `dependencies` 는 redux 에서 가져온 state 였습니다.

(위의 예시 코드에서는 `triggerState` 로 표현하였습니다.)

**`triggerState` 에 의도치 않은 mutate 가 발생하는 것인가** 라고 생각했지만, 이는 아니였습니다.



<br />



## Custom Hook 을 재사용한 만큼 번복되는 useEffect

Custom Hook 으로 분리하는 단위를 **특정 API 호출 함수** 와 **해당 API 응답 후처리 Effect** 로 묶어서 구성하였습니다.

그리고 필요한 곳에서 재사용을 하였습니다.

<br />

결과적으로 재사용한 횟수만큼 `useEffect` 가 번복 실행된 것입니다.

Custom Hook 은 사용하는 곳에 scope 를 만드는 것이므로, 당연한 결과임에도 알아차리지 못하였습니다.



<br />



## API 호출함수와 Effect 를 분리한 Custom Hook 으로 이슈 해결

원인을 찾은 후, API 의 후처리를 담당하는 `useEffect` 를 Custom Hook 에서 빼고, 기존의 `MyPage` 에 위치시켰습니다.

그러자 번복되는 `useEffect` 이슈는 해결 되었습니다.


```tsx title="./hooks/useApi_1.ts" showLineNumbers {15-17}
import {
    useCallback,
} from 'react';
import {
    useAppSelector
} from '@/redux/hooks';

const useApi_1 = () => {
    const responseOfApi_1 = useAppSelector(({ api_1 }) => api_1);

    const callApi_1 = useCallback(() => {
        // API 호출 1
    }, []);

    // useEffect(function onSuccessApi_1() {
    //     // API 1 응답 후처리
    // }, [responseOfApi_1]);

    return {
        callApi_1,
    };
};

export default useApi_1;
```

```tsx title="./hooks/useApi_2.ts" showLineNumbers {15-17}
import {
    useCallback,
} from 'react';
import {
    useAppSelector
} from '@/redux/hooks';

const useApi_2 = () => {
    const responseOfApi_2 = useAppSelector(({ api_2 }) => api_2);

    const callApi_2 = useCallback(() => {
        // API 호출 2
    }, []);

    // useEffect(function onSuccessApi_2() {
    //     // API 2 응답 후처리
    // }, [responseOfApi_2]);

    return {
        callApi_2,
    };
};

export default useApi_2;
```

```tsx title="MyPage.tsx" showLineNumbers {20-22, 24-26}
import {
    useEffect,
} from 'react';
import useApi_1 from './hooks/useApi_1';
import useApi_2 from './hooks/useApi_2';

function MyPage() {
    const triggerState = useAppSelector(({ triggerState }) => triggerState);

    const { callApi_1 } = useApi_1();
    const { callApi_2 } = useApi_2();

    useEffect(function onSuccessApi_2() {
        callApi_1();
        callApi_2();

        // eslint-disable-next-line
    }, [triggerState]);

    useEffect(function onSuccessApi_1() {
        // API 1 응답 후처리
    }, [responseOfApi_1]);

    useEffect(function onSuccessApi_2() {
        // API 2 응답 후처리
    }, [responseOfApi_2]);

    return (
        // ...
    );
};

export default MyPage;
```



<br />



## MyPage 에서 API 후처리를 담당하는 useEffect 분리

위 코드처럼 리펙토링한 이후, 의도한 동작은 되었습니다.

하지만, **MyPage.tsx 파일을 열어보기 전까지는 API 후처리를 어디서 하는지 파악하기가 어렵다고 느껴졌습니다.**

<br />

그래서 MyPage.tsx 의 **API 후처리 Effect 들을 Custom Hook 으로** 나눠보기로 하였습니다.

```ts title="./hooks/useMyPageApiEffects.ts" showLineNumbers {9-11, 13-15}
import {
    useEffect,
} from 'react';

const useMyPageApiEffects = () => {
    const responseOfApi_1 = useAppSelector(({ api_1 }) => api_1);
    const responseOfApi_2 = useAppSelector(({ api_2 }) => api_2);

    useEffect(function onSuccessApi_1() {
        // API 1 응답 후처리
    }, [responseOfApi_1]);

    useEffect(function onSuccessApi_2() {
        // API 2 응답 후처리
    }, [responseOfApi_2]);
}

export default useMyPageApiEffects;
```

```tsx title="MyPage.tsx" showLineNumbers {13}
import {
    useEffect,
} from 'react';
import useApi_1 from './hooks/useApi_1';
import useApi_2 from './hooks/useApi_2';
import useMyPageApiEffects from './hooks/useMyPageApiEffects';

function MyPage() {
    const triggerState = useAppSelector(({ triggerState }) => triggerState);

    const { callApi_1 } = useApi_1();
    const { callApi_2 } = useApi_2();
    useMyPagteApiEffects();

    useEffect(function onSuccessApi_2() {
        callApi_1();
        callApi_2();
    }, [triggerState]);

    return (
        // ...
    );
};

export default MyPage;
```



<br />



## 마치며

여기까지 수정한 결과, MyPage.tsx 에서 API 에 대한 후처리 Effect 가 있다는 것을 파일 목록을 통해서도 파악할 수 있게 되었습니다.

개인적으로는 위와 같은 구조의 Custom Hook 이 마음에 들었습니다.

이렇게 분리한 Custom Hook 은 아래와 같은 파일 구조가 되었습니다.

```bash
└── MyPage
    ├── MyPage.tsx
    └── hooks
        ├── useApi_1.ts
        ├── useApi_2.ts
        └── useMyPageApiEffects.ts
``` 

<br />

사소한 실수에 의한 이슈라서 자책 포인트가 되었지만, Custom Hook 으로 분리하는 구조를 생각할 수 있는 계기가 되어서 성취감이 느껴졌습니다.
17:T3178,---
id: 13
title: 'Model 에 Click Event 적용하기 (추가: ToneMapping, light.shadow.camera)'
description: 'Canvas 에 렌더링된 Model 에 Click 인터렉션을 적용 해봅니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'threejs',
    '3D',
    'mouse event',
    'click interaction',
]

createdAt: '2024-02-03 16:00:00'
modifiedHistories: []
---

# Model 에 Click Event 적용하기 (추가: ToneMapping, light.shadow.camera)

Canvas 에 렌더링된 Model 에 Click 기능을 추가해 보겠습니다.

DOM 과 다르게 Canvas 에 그려지는 Model 은 직접 eventListener 를 적용할 수 없습니다.

그래서 **Raycasting** 이라는 개념을 사용하여 Click Event 를 구현합니다.



<br />



## 예시 코드

이번 포스팅에서 사용할 예시코드는 다음과 같습니다.

<br />

예시코드에서 사용한 Model 은 [상상력을 자극하는 고퀄리티 3D 인터랙티브 웹 제작 (최인 강사님)](https://coloso.co.kr/products/graphicdesign-choiin) 강좌 리소스를 사용하였습니다.

```js title="예시 코드" showLineNumbers {6, 57}
// three/js
import {
    WebGLRenderer,
    Scene,
    PerspectiveCamera,
    ACESFilmicToneMapping,

    Color,
    DirectionalLight,
    HemisphereLight,

    MeshStandardMaterial,
} from 'three';
// three.js - addons
import {
    GLTFLoader,
} from 'three/examples/jsm/loaders/GLTFLoader';
// style
import './style.css';

//
// state
//
/** @type { WebGLRenderer } */
let renderer;

/** @type { Scene } */
let scene;

/** @type { PerspectiveCamera } */
let camera;

/** @type { Parameters<Parameters<GLTFLoader['load']>[1]>[0]['scene'] } */
let mainModel;

//
// core
//
function initCanvas() {
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    return $canvas;
}

function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });

    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.toneMapping = ACESFilmicToneMapping;
}

function initScene() {
    scene = new Scene();
}

function initCamera() {
    camera = new PerspectiveCamera();

    camera.fov = 45;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.near = 0.5;
    camera.far = 2000;
    camera.position.set(100, 100, 100);
    camera.lookAt(-20, 0, -20);

    camera.updateProjectionMatrix();
}

//
// light
//
function initDirectionalLight() {
    const color = new Color('#fff');

    const light = new DirectionalLight(
        color,
        Math.PI * 1
    );

    light.position.set(-1, 1, 0.5);
    light.castShadow = true;

    light.shadow.mapSize.set(1024, 1024);
    light.shadow.camera.near = 0.5;
    light.shadow.camera.far = 500;

    light.shadow.camera.top = 180;
    light.shadow.camera.bottom = -100;
    light.shadow.camera.left = -120;
    light.shadow.camera.right = 120;

    scene.add(light);
}

function initHemisphereLight() {
    const skyColor = new Color('#fff');
    const groundColor = new Color('#555');

    const light = new HemisphereLight(
        skyColor,
        groundColor,
        Math.PI * 0.5
    );

    light.position.set(0, -1, 0);

    scene.add(light);
}

//
// model
//
function initMainModel() {
    const loader = new GLTFLoader();

    loader.load('/gltf/click.glb', gltf => {
        const ratio = 0.1;

        mainModel = gltf.scene;
        mainModel.position.set(0, 0, 0);
        mainModel.scale.set(ratio, ratio, ratio);

        mainModel.traverse(child => {
            if (!child.isMesh) {
                return;
            }

            child.material = new MeshStandardMaterial({
                color: child.material.color,
                roughness: 0.3,
            });

            child.castShadow = true;
            child.receiveShadow = true;
        });

        scene.add(mainModel);
    });
}

//
// executor
//
function render() {
    window.requestAnimationFrame(render);

    renderer.render(scene, camera);
}

(function init() {
    const $canvas = initCanvas();

    initRenderer($canvas);
    initScene();
    initCamera();

    initDirectionalLight();
    initHemisphereLight();

    initMainModel();

    render();
}());
```



<br />



## toneMapping 이란?

예시 코드 57번줄을 보면 다음과 같은 코드가 있습니다.

```js title="toneMapping 설정"
renderer.toneMapping = ACESFilmicToneMapping;
```

<br />

HDR(High Dynamic Range) 과 같은 Model 을 LDR(Low Dynamic Range) 로 변환하는 방식을 설정하는 부분입니다.

3D Model 의 경우 HDR 로 만드는데, 사용자의 모니터나 모바일 화면은 LDR 입니다.

고해상도를 저해상도로 변환하는 원리는, 복수 Pixel 의 근사치를 구하여 하나의 Pixel 로 만드는 것입니다.

설정한 방식의 HDR => LDR 변환 방식을 사용하여 렌더링을 하게 되므로, 선명도가 다르거나 색상의 밝기가 달라지는 차이를 확인할 수 있습니다.

<br />

예시 코드에서 사용한 **ACESFilmicToneMapping** 은 toneMapping 중 하나입니다.

* ACESFilmicToneMapping: Academy Color Encoding System FIlmic Tone Mapping

ACESFilmicToneMapping 는 영화 예술 과학 아카데미의 후원으로 개발한 무료 ToneMapping 방식입니다.

**실제 사진과 유사한 시각혁 효과를 만들 때 사용합니다.**

<br />

어떤 toneMapping 을 사용할지는 자신의 시각적 취향이나 개발 요구사항에 맞게 선택하면 됩니다.



<br />



## DirectionalLight 의 shadow 설정

예시 코드의 DirectionalLight 생성 함수를 보면, shadow 관련 설정이 있습니다.

```js title="DirectionalLight 의 shadow 설정"
function initDirectionalLight() {
    const color = new Color('#fff');

    const light = new DirectionalLight(
        color,
        Math.PI * 1
    );

    light.position.set(-1, 1, 0.5);
    light.castShadow = true;

    light.shadow.mapSize.set(1024, 1024);
    light.shadow.camera.near = 0.5;
    light.shadow.camera.far = 500;

    light.shadow.camera.top = 180;
    light.shadow.camera.bottom = -100;
    light.shadow.camera.left = -120;
    light.shadow.camera.right = 120;

    scene.add(light);
}
```

이 중, `light.shahdow.camera` 속성을 살펴보고자 합니다.

<br />

Light 는 빛을 만들고 Mesh 의 그림자도 만들어 줍니다.

위 코드를 보면 `shadow` 속성 하위에 `camera` 속성이 있습니다.

쏘아지는 빛에 의한 **그림자를 만드는 시점 설정** 으로 볼 수 있습니다.

<br />

`light.shadow.camera` 는 **OrthographicCamera** 객체 입니다.

우리가 지금까지 사용했던 Camera 인 **PerspectiveCamera** 와 다른점은 다음과 같습니다.

* PerspectiveCamera: 3D 환경처럼 **원근법** 이 표현되는 카메라 입니다.
* OrthographicCamera: 2D 환경처럼 원근법이 나타나지 않는 카메라 입니다.

즉, light 가 비추는 빛은 2D 환경과 같이 원근법을 계산하지 않는 방식을 사용합니다.

<br />

그림자는 Light 가 비추는 범위 내에 Mesh 가 있어야 생성됩니다.

이 범위는 **절두체(frustum)** 로 표현됩니다.

> [이미지 출처: 위키백과](https://ko.wikipedia.org/wiki/%EC%A0%88%EB%91%90%EC%B2%B4)

<img src="/markdownAssets/threejs/2024-02-03-02/2024-02-03-02-01.png" alt="절두체" />

<br />

`light.shadow.camera.top` 설정은 카메라가 비추는 절두체 영역의 중신점에서 **top (위쪽)** 까지의 거리를 설정하는 것입니다.

마찬가지로 bottom, left, right 도 같은 맥락의 설정입니다.

> [이미지 출처: 게임을 게임답게](https://m.blog.naver.com/canny708/221547085908)

<img src="/markdownAssets/threejs/2024-02-03-02/2024-02-03-02-02.png" alt="절두체" />



<br />



## Raycaster 를 사용하여 Click 이벤트 만들기

이번 포스팅의 메인 내용인 Click 이벤트에 대해 알아보겠습니다.

canvas 에 렌더링하는 요소는 DOM 이벤트로 감지할 수 없습니다.

그래서 **Raycasting** 이라는 개념을 사용합니다.

> 참고: [위키백과](https://ko.wikipedia.org/wiki/%EA%B4%91%EC%84%A0_%ED%88%AC%EC%82%AC)

* Raycasting: 가상의 광선을 쏘아서 물체와 교차되는 좌표값을 계산하기 위한 기법

<br />

Three.js 에서는 `Raycaster` 인스턴스를 생성하여 Mesh, Model 을 특정할 수 있습니다.

HTMLCanvasElement 에 click 이벤트를 추가하고, handler 에서 Raycaster 를 사용하여 어떤 Mesh, Model 이 교차되었는지 식별하는 방법으로 구현합니다.

<br />

```js title="Raycaster import 하기" showLineNumbers {14-15}
// three/js
import {
    WebGLRenderer,
    Scene,
    PerspectiveCamera,
    ACESFilmicToneMapping,

    Color,
    DirectionalLight,
    HemisphereLight,

    MeshStandardMaterial,

    Raycaster,
    Vector2,
} from 'three';
```

```js title="Raycaster 로 click 이벤트 만들기" showLineNumbers{152} {4-9, 11-42, 65}
//
// interaction
//
function changeColor(color) {
    scene.background = color;

    const targetModel = scene.getObjectByName('change');
    targetModel.material.color = color;
}

function initClickInteraction() {
    const raycaster = new Raycaster();

    window.addEventListener('click', e => {
        const {
            clientX,
            clientY,
        } = e;

        // Raycaster 좌표계로 변환 및 Vector2 인스턴스 생성
        const mouseCoord = new Vector2();
        mouseCoord.x = (clientX / window.innerWidth) * 2 - 1;
        mouseCoord.y = -(clientY / window.innerHeight) * 2 + 1;

        // Raycaster 에 좌표값과 대상 카메라 적용
        raycaster.setFromCamera(mouseCoord, camera);

        // `Ray(광선)` 과 교차하는 Mesh, Model 을 추출
        const intersects = raycaster.intersectObjects(scene.children, true);
        const firstIntersect = intersects[0];
        const firstModel = firstIntersect?.object;

        if (!firstModel) {
            return;
        }

        if (!firstModel.name.match(/^button.*/)) {
            return;
        }

        const buttonColor = firstModel.material.color;

        changeColor(buttonColor);
    });
}

//
// executor
//
function render() {
    window.requestAnimationFrame(render);

    renderer.render(scene, camera);
}

(function init() {
    const $canvas = initCanvas();

    initRenderer($canvas);
    initScene();
    initCamera();

    initDirectionalLight();
    initHemisphereLight();

    initMainModel();

    initClickInteraction();

    render();
}());
```

<video width="100%" height="auto" preload="none" autoPlay={true} loop={true} muted={true} controls={false}>
    <source src="/markdownAssets/threejs/2024-02-03-02/2024-02-03-02-03.webm" type="video/webm" />
    Raycaster
</video>

<br />

click 이벤트를 초기화 하는 `initClickInteraction` 함수를 살펴보겠습니다.

Raycasting 을 사용하기 위해 `new Raycaster()` 로 인스턴스를 만듭니다.

그리고 click 이벤트가 발생하면, raycaster 인스턴스를 사용하게 됩니다.

<br />

위 코드에서 사용한 Raycaster 메소드는 다음과 같습니다.

* `setFromCamera(좌표값, 카메라)`
* `intersectObjects(감지대상_리스트, 재귀_여부)`

<br />

click 이벤트가 발생하면, 마우스위 위치를 알 수 있습니다.

이 좌표값을 사용하여 **Vector2** 인스턴스를 생성할 수 있습니다.

> 참고: [Three.js 공식문서 - Raycaster](https://threejs.org/docs/?q=raycaster#api/en/core/Raycaster)

여기서 중요한 점은 **Raycaster 의 좌표계** 에 맞도록 변환하는 것입니다.

Raycaster 의 좌표계는 2D 이며 다음과 같습니다.

* X축: **-1 ~ 1**
* Y축: **-1 ~ 1**

<br />

그래서 clientX, clientY 좌표값을 아래와 같은 공식으로 변환하여 Vector2 인스턴스를 생성하게 됩니다.

```js title="Raycaster 좌표계로 변환"
window.addEventListener('click', e => {
    const {
        clientX,
        clientY,
    } = e;

    const x = (clientX / window.innerWidth) * 2 - 1;
    const y = -(clientY / window.innerHeight) * 2 + 1;
});
```



<br />



## 마치며

Path2D 를 사용하여 구현했었던 Canvas API 에 비해, Raycaster 는 코드상으로도 가독성이 좋은 것 같습니다.

Three.js 를 좀 더 잘 사용할 수 있게된다면, 지금까지 사용했던 Canvas API 를 대체하여 사용하고 싶습니다.
18:T1049,---
id: 13
title: '(Issue) 조명이 어둡게 보이는 현상'
description: '강좌의 결과물에 비해 실습 결과물의 밝기가 어둡게 렌더링되는 현상이 발생하였습니다. 현상 원인과 해결 방법에 대해 정리하고자 합니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'threejs',
    '3D',
    'DirectionalLgith',
    'HemisphereLight',
    'intensity'
]

createdAt: '2024-02-03 14:00:00'
modifiedHistories: []
---

# (Issue) 조명이 어둡게 보이는 현상

강좌에서 제공하는 프로젝트 환경에서 실습을 하였습니다.

그 후, Vite 프로젝트를 생성하여 복습한 결과, 어둡게 렌더링되는 현상이 발생하였습니다.

* 강좌 결과: 밝게 렌더링
* 복습 결과: 어둡게 렌더링

<img src="/markdownAssets/threejs/2024-02-03-01/2024-02-03-01-01.png" alt="발기 차이" />



<br />



## 원인은 Three.js 버전

강좌에서 사용한 Three.js 버전은 **0.132.2**, 복습에서는 **0.162.2** 을 사용하였습니다.

<br />

동일한 코드임에도 불구하고 복습 결과가 더 어둡게 렌더링된 것은, Three.js 의 버전이 올라가면서 Light 의 **intensity** 값에 대한 단위가 바뀌었기 때문입니다.

> 참고: [Three.js 포럼](https://discourse.threejs.org/t/breaking-changes-between-r132-vs-r133/30629)
>
> 참고: [Three.js 포럼 질문](https://discourse.threejs.org/t/r132-r133-darkened-scene/30951)



<br />



## 해결 방법 1 (deprecated)

WebGLRenderer 인스턴스의 `useLegacyLights` 속성을 `true` 설정하면 강좌 처럼 밝게 렌더링됩니다.

다만 `useLegacyLights` 는 deprecated 된 속성이기 때문에 권장하는 방법이 필요합니다.

```js title="useLegacyLights 설정" {6}
const renderer = new WebGLRenderer({
    canvas,
    antialias: true,
});

renderer.useLegacyLights = true;
```



<br />



## 해결 방법 2 (recommanded)

어둡게 렌더링되는 원인인 Light 의 intensity 값을 조정하는 방법을 권장합니다.

기존에는 intensity 값을 **정수** 를 기준으로 하였지만, **PI** 값을 기준으로 변경되었습니다.

그래서 기존과 동일한 밝기로 렌더링하고자 한다면, **기존_intensity_값 * PI** 를 사용하여 얻을 수 있습니다.

* v0.131.0 에서 Light intensity: **1**
* 이후 버전에서 Light intensity: **1 * Math.PI**

<br />

```js title="Light intensity 에 PI 적용"
const directionalLight = new DirectionalLight(
    new Color('#fff'),
    Math.PI * 1
);

const hemisphereLight = new HemisphereLight(
    new Color('#fff'),
    new Color('#000'),
    Math.PI * 0.5
);
```

<img src="/markdownAssets/threejs/2024-02-03-01/2024-02-03-01-02.png" alt="Light intensity 에 PI 적용" />

<br />

Light 의 intensity 를 사용하여 기존과 거의 유사한 밝기의 결과를 확인할 수 있습니다.

다만 완벽히 동일한 결과를 얻을수는 없습니다.



<br />



## Light 의 intensity 단위가 바뀐 이유

> [참고: Physically Based Rendering and Lighting](https://discoverthreejs.com/book/first-steps/physically-based-rendering/)

**물리 기반 렌더링 (Phycally Based Renderering)** 을 위해 Light 의 intensity 값에 PI 를 도입하게 되었다고 합니다.

물리 기반이란, Light 와 물체의 거리에 따라 생성할 그림자에 물리 법칙을 적용하여 더 사실적으로 렌더링할 수 있게 됩니다.

<br />

intensity 에 PI 를 적용하도록 변경된 Light 는 다음과 같습니다.

* AmbientLight
* DirectionalLight
* HemisphereLight
* SpotLight



<br />



## 마치며

복습한 결과가 강좌의 결과와 다른 이유가 너무나 궁금하였습니다.

만약 이번 이슈를 해결하지 못하고 넘어간다면, 의도한 밝기의 결과를 만들지 못한다는 걱정이 컸습니다.

다행히 Three.js 포럼에 관련 질문과 설명이 있었습니다.

<br />

Three.js 의 공식 문서는 개요 파악 정도로 사용하고, Three.js 포럼에서 좀 더 자세한 내용을 찾아보아야 할 것 같습니다.
19:T2afe,---
id: 12
title: '키보드를 사용하여 카메라 이동 인터렉션 만들기'
description: '키보드 입력에 대한 event listener 를 사용하여 카메라를 이동할 수 있는 인터렉션을 구현해 봅니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'threejs',
    '3D',
    'keyboard event',
    'camera',
    'interaction',
]

createdAt: '2024-01-30 18:00:00'
modifiedHistories: []
---

# 키보드를 사용하여 카메라 이동 인터렉션 만들기

이번에는 사용자 인터렉션을 구현해 보겠습니다.

키보드 입력값에 따라 카메라를 이동할 수 있는 기능을 구현해 보고자 합니다.

추가로 브라우저 resize 이벤트를 사용하여 canvas 의 크기를 조정하는 기능까지 구현해 보겠습니다.



<br />



## 예시 코드

이번 포스팅에서 사용할 예시 코드는 다음과 같습니다.

```js title="예시 코드" showLineNumbers
// three.js
import {
    WebGLRenderer,
    Scene,
    PerspectiveCamera,

    Color,
    PointLight,
    HemisphereLight,

    MeshBasicMaterial,
    MeshStandardMaterial,
} from 'three';
// three.js - addons
import {
    GLTFLoader,
} from 'three/examples/jsm/loaders/GLTFLoader';
// style
import './style.css';

/** @type { WebGLRenderer} */
let renderer;

/** @type { Scene } */
let scene;

/** @type { PerspectiveCamera } */
let camera;

//
// core
//
function initCanvas() {
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    return $canvas;
}

function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });

    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(
        window.innerWidth,
        window.innerHeight
    );
}

function initScene() {
    scene = new Scene();
    scene.background = new Color('#000');
}

function initCamera() {
    camera = new PerspectiveCamera();
    camera.fov = 45;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.near = 0.1;
    camera.far = 3000;
    camera.position.set(0, 0, 0);
    camera.lookAt(0, 0, 0);

    camera.updateProjectionMatrix();
}

//
// light
//
function initPointLight() {
    const color = new Color('#fff');

    const light = new PointLight(color, 1);
    light.position.set(0, 0, 0);

    scene.add(light);
}

function initHemisphereLight() {
    const skyColor = new Color('#000');
    const groundColor = new Color('#fff');

    const light = new HemisphereLight(
        skyColor,
        groundColor,
        0.4
    );
    light.position.set(1, 0, 1);

    scene.add(light);
}

//
// model
//
function initMoveModel() {
    const loader = new GLTFLoader();

    loader.load('/gltf/move.glb', gltf => {
        const moveModel = gltf.scene;

        // Model 의 크기가 너무 커서, 0.1 배로 줄여서 사용합니다.
        const ratio = 0.1;

        moveModel.scale.set(
            ratio,
            ratio,
            ratio
        );
        moveModel.position.set(0, 0, 0);

        moveModel.traverse(child => {
            if (!child.isMesh) {
                return;
            }

            switch(child.name) {
                case 'light':
                    child.material = new MeshBasicMaterial({
                        color: new Color('#fff'),
                    });
                    break;
                default:
                    child.material = new MeshStandardMaterial({
                        color: new Color('#fff'),
                        roughness: 0.5,
                    });
            }
        });

        // Model 에 포함되어 있는 카메라 위치값을 사용합니다.
        const moveModelCamera = gltf.cameras[0];
        camera.position.set(
            moveModelCamera.position.x * ratio,
            moveModelCamera.position.y * ratio,
            moveModelCamera.position.z * ratio
        );

        scene.add(moveModel);
    });
}

//
// executor
//
function render() {
    window.requestAnimationFrame(render);

    renderer.render(scene, camera);
}

(function init() {
    const $canvas = initCanvas();

    initRenderer($canvas);
    initScene();
    initCamera();

    initPointLight();
    initHemisphereLight();

    initMoveModel();

    render();
}());
```

<br />

예시코드에서 사용한 Model 은 [상상력을 자극하는 고퀄리티 3D 인터랙티브 웹 제작 (최인 강사님)](https://coloso.co.kr/products/graphicdesign-choiin) 강좌 리소스를 사용하였습니다.



<br />



## 이동 상태값 만들기

눌러진 키보드 방향키에 따라 카메라의 Z 축 위치를 변경하는 인터렉션을 만들고자 합니다.

* ArrowUp(위쪽 방향키): 카메라가 -Z 축으로 이동합니다.
* ArrowDown(아래쪽 방향키): 카메라가 +Z 축으로 이동합니다.

<br />

ArrowUp, ArrowDown 키가 눌려졌는지 상태값이 필요합니다.

이 상태값을 사용하여, 키가 눌려졌다면 Camera 의 `position.z` 값을 증감시켜서, 마치 화면(카메라) 가 이동하는 듯한 효과를 연출하겠습니다.

<br />

```js title="이동 상태값 만들기" showLineNumbers{21} {10-13}
/** @type { WebGLRenderer} */
let renderer;

/** @type { Scene } */
let scene;

/** @type { PerspectiveCamera } */
let camera;

const moveInteractionState = {
    forward: false,
    backward: false,
};
```



<br />



## 키보드 이벤트 리스너 만들기

ArrowUp, ArrowDown 에 대한 키보드 이벤트 리스너를 추가해 보겠습니다.

이벤트 리스너는 `moveInteractionState` 의 값을 변경하여, 해당 키가 눌려졌는지에 대한 상태를 변경하는 역할을 하게 됩니다.

```js title="키보드 이벤트 리스너 만들기" showLineNumbers{153}
//
// interaction
//
function initMoveInteraction() {
    window.addEventListener('keydown', e => {
        const key = e.key.toLowerCase();

        switch(key) {
            case 'up':
            case 'arrowup':
                moveInteractionState.forward = true;
                break;
            case 'down':
            case 'arrowdown':
                moveInteractionState.backward = true;
                break;
        }
    });

    window.addEventListener('keyup', e => {
        const key = e.key.toLowerCase();

        switch(key) {
            case 'up':
            case 'arrowup':
                moveInteractionState.forward = false;
                break;
            case 'down':
            case 'arrowdown':
                moveInteractionState.backward = false;
                break;
        }
    });
}
```



<br />



## 키보드 상태값으로 카메라 이동시키기

예시 코드의 `render()` 함수는 60 프레임으로 호출됩니다.

매 프레임마다 키보드 상태값에 따라 카메라의 위치를 증감 시켜주는 기능을 추가하여, 카메라를 이동시키는 기능을 구현할 수 있습니다.

<br />

카메라를 이동시키는 기능으로 `animateCamera()` 함수를 만들면 다음과 같습니다.

```js title="키보다 상태값으로 카메라 이동시키기" showLineNumbers {4-13, 23, 38}
//
// animation
//
function animateCamera() {
    switch(true) {
        case moveInteractionState.forward:
            camera.position.z -= 6;
            break;
        case moveInteractionState.backward:
            camera.position.z += 6;
            break;
    }
}

//
// executor
//
function render() {
    window.requestAnimationFrame(render);

    renderer.render(scene, camera);

    animateCamera();
}

(function init() {
    const $canvas = initCanvas();

    initRenderer($canvas);
    initScene();
    initCamera();

    initPointLight();
    initHemisphereLight();

    initMoveModel();

    initMoveInteraction();

    render();
}());
```

<video width="100%" height="auto" preload="none" autoPlay={true} loop={true} muted={true} controls={false}>
    <source src="/markdownAssets/threejs/2024-01-30-01/2024-01-30-01-01.webm" type="video/webm" />
    키보드 상태값으로 카메라 이동시키기
</video>



<br />



## 브라우저 resize 이벤트로 canvas 크기 조정하기

**resize** 이벤트는 브라우저의 크기가 변경되면 발생하는 이벤트 입니다.

resize 이벤트가 발생했을 때, canvas 의 크기를 변경된 브라우저 크기로 변경하는 기능을 구현해 보겠습니다.

<br />

먼저 canvas 의 크기를 변경하기 위에 `renderer.setSize()` 메솓드를 사용합니다.

```js title="브라우저 resize 이벤트로 canvas 크기 조정하기" showLineNumbers{47} {13-18}
function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });

    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(
        window.innerWidth,
        window.innerHeight
    );

    window.addEventListener('resize', () => {
        renderer.setSize(
            window.innerWidth,
            window.innerHeight
        );
    });
}
```

<br />

위 코드를 적용한 후, 브라우저 크기를 변경해보면, canvas 의 크기도 함께 조정됩니다.

하지만 찌그러진 결과가 렌더링됨을 볼 수 있습니다.

<img src="/markdownAssets/threejs/2024-01-30-01/2024-01-30-01-02.png" alt="찌그러진 결과" />

<br />

이 현상은 **Camera** 의 **비율 (aspect ratio)** 는 최초 브라우저의 비율을 그대로 사용하고 있기 때문입니다.

`camera.aspect` 속성에도 변경된 브라우저 크기의 비율을 적용하여 문제를 해결할 수 있습니다.

```js title="찌그러짐 해소" showLineNumbers{47} {19-20}
function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });

    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(
        window.innerWidth,
        window.innerHeight
    );

    window.addEventListener('resize', () => {
        renderer.setSize(
            window.innerWidth,
            window.innerHeight
        );

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
    });
}
```



<br />



## 마치며

처음으로 사용자 인터렉션을 적용해 보았습니다.

Javascript 의 이벤트 처리 방식을 그대로 따르는 방법이라서 친숙하였습니다.

<br />

그리고 인터렉션에 의한 렌더링을 변경할 때, **프레임** 을 그리는 `render()` 함수에서 변화를 적용하여야 함을 알게 되었습니다.

만약 화면을 변경하는 부분을 `render()` 함수가 아닌, event listener 에서 직접 하게 되면, **뚝뚝 끊기면서 렌더링되는 현상** 이 나타났습니다.

이는 키보드를 누르고 있을 때, 체터링 간격이 `1 /60` 보다 큰 값인 것으로 추측되었습니다.
1a:T1d82,---
id: 11
title: 'canvas 크기 설정 및 material 렌더링 side 설정'
description: '사용자 모니터 대응을 위한 WebGLRenderer 설정과 material 의 렌더링 side 설정에 대해 정리합니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'threejs',
    'setSize()',
    'setPixelRatio()',
    'material',
    'FrontSide',
    'BackSide',
    'DoubleSide',
]

createdAt: '2024-01-28 23:00:00'
modifiedHistories: []
---

# canvas 크기 설정 및 material 렌더링 side 설정

지금까지는 HTMLCanvasElement 인스턴스의 width, height 를 직접 설정하여 사용하고 있었습니다.

이번에는 좀 더 사용자 장치(모니터)에 적합한 렌더링이 되도록 설정하는 방법과 material 의 side 속성에 대해 정리하겠습니다.



<br />



## WebGLRenderer 를 사용한 canvas 크기 및 Pixel 비율 설정

지금까지는 HTMLCanvasElement 의 크기를 아래와 같이 설정하였습니다.

```js title="HTMLCanvasElement 크기 설정하기" showLineNumbers
function initCanvas() {
    const $canvas = document.createElement('canvas');
    $canvas.width = window.innerWidth;
    $canvas.height = window.innerHeight;

    // ...
}
```

이렇게 설정하여도 일반적인 모니터에서는 문제없이 렌더링 됩니다.

이는 **Pixel Ratio** 가 **1** 인 모니터에 대한 설정이며, 기본 설정값입니다.

<br />

> 참고: [Window: devicePixelRatio 속성 - MDN](https://developer.mozilla.org/ko/docs/Web/API/Window/devicePixelRatio)

Pixel Ratio 이란, **렌더링할 Pixel 크기** 와 **모니터의 물리적 Pixel 크기** 에 대한 비율입니다.

웹을 기준으로 본다면, 아래의 값이 Pixel Ratio 를 도출할 수 있습니다.

* `물리적(모니터) Pixel 크기` / `CSS Pixel 크기`

즉, 일반적인 모니터의 **Pixel Ratio** 가 **1** 이라는 뜻은, **CSS Pixel 1개** 당 **모니터의 실제 Pixel 1개** 를 사용하여 렌더링한다는 의미입니다.

<br />

**HiDPI** 와 **Apple 의 retina** 디스플레이는 Pixel Ratio 가 2인 모니터입니다.

이는 기존의 **CSS Pixel 1개** 를 **모니터의 실제 Pixel 2개** 에 렌더링한다는 의미가 되며, 이러한 제품은 더 많은 물리적 Pixel 을 사용하여 더 선명한 화질을 제공하기 위함입니다.

<br />

우리가 Web 에서 사용하는 HTMLCanvasElement 에 Pixel Ratio 를 적용하려면, 아래와 같은 설정이 필요합니다.

```js title="HTMLCanvasElement 에 Pixel Ratio 적용하기" showLineNumbers
const pixelRatio = window.devicePixelRatio;

const $canvas = document.createElement('canvas');

$canvas.style.width = `${window.innerWidth}px`;
$canvas.style.height = `${window.innerHeight}px`;

$canvas.width = window.innerWidth * pixelRatio;
$canvas.width = window.innerHeight * pixelRatio;
```

<br />

이렇게 설정하게 되면, 아래와 같이 선명도의 차이가 나타납니다.

> 이미지 출처: [Window: devicePixelRatio 속성 - MDN](https://developer.mozilla.org/ko/docs/Web/API/Window/devicePixelRatio)

<img src="/markdownAssets/threejs/2024-01-28-02/2024-01-28-02-01.png" alt="Pixel Ratio" />

<br />

Three.js 는 WebGLRenderer 인스턴스를 사용하여 Pixel Ratio 를 설정할 수 있습니다.

```js title="Three.js 에 Pixel Ratio 설정하기"
const renderer = new WebGLRenderer();

renderer.setPixelRatio(window.devicePixelRatio);
```

<br />

추가로 HTMLCanvasElement 의 width 와 height 를 직접 설정하는 것이 아닌 WebGLRenderer 의 `setSize()` 메소드를 사용하여 설정할 수 있습니다.

`setSize()` 는 HTMLCanvasElement 의 크기 변경과 함께, **Viewport** 까지 **Fit** 하게 설정해 줍니다.

이를 적용하면 아래와 같이 코드를 작성할 수 있습니다.

```js title="WebGLRenderer 설정" showLineNumbers
import {
    WebGLRenderer,
} from 'three';

/** @type { WebGLRenderer } */
let renderer;

function initCanvas() {
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    return $canvas;
}

function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });

    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(
        window.innerWidth,
        window.innerHeight
    );
}

function init() {
    const $canvas = initCanvas();

    initRenderer($canvas);
}
```



<br />



## Material 의 side 프로퍼티

Material 은 Model 의 재질을 담당하며, 렌더링 대상 중 하나입니다.

렌더링 대상이 많을수록 더 많은 PC 성능을 요구하게 되므로, Material 도 최적화가 필요합니다.

<br />

Three.js 의 Material 인스턴스는 `side` 라는 프로퍼티를 제공합니다.

이는 실제로 렌더링할 **면** 을 지정하여, 렌더링 대상에 속한 Material 만 렌더링하게 됩니다.

<br />

Material 의 `side` 는 다음과 같은 설정을 할 수 있습니다.

* `FrontSide`
    * Mesh 의 **앞면** 에 해당하는 Material 만 렌더링 합니다.
    * 뒷면은 렌더링하지 않습니다.
    * 기본값 입니다.
* `BackSide`
    * Mesh 의 **뒷면** 에 해당하는 Material 만 렌더링 합니다.
    * 앞면은 렌더링하지 않습니다.
* `DoubleSide`
    * Mesh 의 전체 Material 을 렌더링 합니다.

<br />

GLTFLoader 를 사용하여 불러온 Model 에 `side` 를 적용하면 다음과 같습니다.

```js title="Material 의 side 설정" showLineNumbers
import {
    FrontSide,
    BackSide,
    DoubleSide,
} from 'three';
import {
    GLTFLoader,
} from 'three/examples/jsm/loader/GLTFLoader';

function initFrontSideModel() {
    const loader = new GLTFLoader();

    loader.load('/gltf/someModel.gltf', gltf => {
        gltf.scene.traverse(child => {
            if (!child.isMesh) {
                return;
            }

            // `앞면` 만 렌더링
            child.material.side = FrontSide;
        });
    });
}

function initBackSideModel() {
    const loader = new GLTFLoader();

    loader.load('/gltf/someModel.gltf', gltf => {
        gltf.scene.traverse(child => {
            if (!child.isMesh) {
                return;
            }

            // `뒷면` 만 렌더링
            child.material.side = BackSide;
        });
    });
}

function initDoubleSideModel() {
    const loader = new GLTFLoader();

    loader.load('/gltf/someModel.gltf', gltf => {
        gltf.scene.traverse(child => {
            if (!child.isMesh) {
                return;
            }

            // 앞, 뒤 모두 렌더링
            child.material.side = DoubleSide;
        });
    });
}
```



<br />



## 마치며

스터디를 한 후, 내용이 이해되지 않거나 전혀 생각나지 않을 경우, 상실감을 느낍니다.

그래서 강의 수강과 함께 정리를 병행하고 있습니다.

내용에 따라 하나의 강의를 분리하여 정리하기도 합니다.

이렇게 학습하게 되면, 비교적 학습시간이 많이 필요하게 되지만, 많은 것을 기억할 수 있습니다.

<br />

느린 학습 속도에 조바심이 나기도 하고, 정리에 대한 부담감도 생깁니다.

100% 를 기억하지는 못하더라도, 맥락과 주요 개념을 기억하기 위해서는 당연한 방법이라고 생각합니다.

다만 투자하는 시간에 대한 아쉬움으로 짧은 푸념을 남깁니다.
1b:T2b48,---
id: 9
title: 'Model 에 Animation 효과 적용하기'
description: 'Model 파일인 .gltf, .glb 에 Animation 을 적용하는 방법에 대해 정리합니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'threejs',
    'javascript',
    '3d',
    '.gltf',
    '.glb',
    'model',
    'animation',
]

createdAt: '2024-01-26 20:00:00'
modifiedHistories: []
---

# Model 에 Animation 효과 적용하기

C4D 또는 Blender 를 사용하여 Model 을 만들고 Three.js 에 렌더링할 수 있게 되었습니다.

이번 포스팅에서는 Model 에 Animation 효과를 적용하는 방법에 대해 알아보고자 합니다.

<br />

예시코드에서 사용한 Model 은 [상상력을 자극하는 고퀄리티 3D 인터랙티브 웹 제작 (최인 강사님)](https://coloso.co.kr/products/graphicdesign-choiin) 강좌 리소스를 사용하였습니다.



<br />



## Model 의 Animation 을 적용하는 방법

Animation 은 2가지 방법으로 적용할 수 있습니다.

* 첫번쨰 방법: Model 의 position, rotation, scale 등의 값을 직접 update 하는 방법
* 두번째 방법: 3D Tool 에서 Model 에 적용한 Keyframe Animation 을 불러와서 Update 하는 방법

<br />

두가지 방법 모두 원리는 HTMLCanvasElement 를 사용한 Animation 을 적용하는 방법과 동일합니다.

첫번째 방법은 가속도와 같은 자연스러운 효과를 구현하기 어렵지만, 두번째 방법을 사용하면 3D Tool 에서 정교하게 만든 Animation 을 사용할 수 있습니다.



<br />



## 예시 코드

이번 포스팅은 Rocket Model 을 렌더링 한 시점부터 시작합니다.

```js title="예시 코드" showLineNumbers
// three.js
import {
    WebGLRenderer,
    Scene,
    PerspectiveCamera,

    Color,
    DirectionalLight,
} from 'three';
import {
    OrbitControls,
} from 'three/examples/jsm/controls/OrbitControls';
import {
    GLTFLoader,
} from 'three/examples/jsm/loaders/GLTFLoader';
// style
import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { Scene } */
let scene;

/** @type { PerspectiveCamera } */
let camera;

/** @type { OrbitControls } */
let controls;

//
// core
//
function initCanvas() {
    const $canvas = document.createElement('canvas');
    $canvas.width = window.innerWidth;
    $canvas.height = window.innerHeight;

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    return $canvas;
}

function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });

    renderer.shadowMap.enabled = true;
}

function initScene() {
    scene = new Scene();
}

function initCamera() {
    camera = new PerspectiveCamera();
    camera.fov = 35;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.position.set(0, 0, 30);

    camera.updateProjectionMatrix();
}

function initControls($target) {
    controls = new OrbitControls(camera, $target);
    controls.enableDamping = true;
}

//
// light
//
function initDirectionalLight() {
    const color = new Color('#fff');

    const light = new DirectionalLight(color, 1);
    light.castShadow = true;
    light.shadow.mapSize.set(2048, 2048);
    light.shadow.radius = 8;
    light.position.set(10, 10, 10);
    light.lookAt(0, 0, 0);

    scene.add(light);
}

//
// model
//
function initRocketModel() {
    const loader = new GLTFLoader();

    loader.load('/gltf/rocket.glb', gltf => {
        gltf.scene.position.set(0, -5, 5);
        gltf.scene.traverse(child => {
            if (!child.isMesh) {
                return;
            }

            child.castShadow = true;
            child.receiveShadow = true;
            child.material.metalness = 0;
        });

        scene.add(gltf.scene);
    });
}

//
// executor
//
function render() {
    window.requestAnimationFrame(render);

    renderer.render(scene, camera);
    controls.update();
}

(function init() {
    const $canvas = initCanvas();

    initRenderer($canvas);
    initScene();
    initCamera();
    initControls($canvas);

    initDirectionalLight();

    initRocketModel();

    render();
}());
```

<img src="/markdownAssets/threejs/2024-01-26-01/2024-01-26-01-01.png" alt="예시 코드 결과" />



<br />



## 첫번째 방법: Model 을 직접 변형하여 Animation 효과 구현하기

GLTFLoader 를 사용하여 Model 을 불러옵니다.

불러온 Model 의 position, roation, scale 을 변경하는 함수를 만들고, 매 Frame 을 렌더링할 때마다 update 시켜줍니다.

<br />

아래 코드는 Model 의 rotation.y 의 좌표값을 변경하여, 로켓 Model 이 회전하는 Animation 을 구현합니다.

```js title="첫번째 방법: rocketModel global 변수 추가" showLineNumbers {10, 33-34}
// three.js
import {
    WebGLRenderer,
    Scene,
    PerspectiveCamera,

    Color,
    DirectionalLight,

    Mesh,
} from 'three';
import {
    OrbitControls,
} from 'three/examples/jsm/controls/OrbitControls';
import {
    GLTFLoader,
} from 'three/examples/jsm/loaders/GLTFLoader';
// style
import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { Scene } */
let scene;

/** @type { PerspectiveCamera } */
let camera;

/** @type { OrbitControls } */
let controls;

/** @type { Mesh } */
let rocketModel;
```

```js title="첫번쨰 방법 - Animation 구현" showLineNumbers{93} {8, 25-34, 45}
//
// model
//
function initRocketModel() {
    const loader = new GLTFLoader();

    loader.load('/gltf/rocket.glb', gltf => {
        rocketModel = gltf.scene;

        gltf.scene.position.set(0, -5, 5);
        gltf.scene.traverse(child => {
            if (!child.isMesh) {
                return;
            }

            child.castShadow = true;
            child.receiveShadow = true;
            child.material.metalness = 0;
        });

        scene.add(gltf.scene);
    });
}

//
// animation
//
function animateRocket() {
    if (!rocketModel) {
        return;
    }

    rocketModel.rotation.y += 0.1;
}

//
// executor
//
function render() {
    window.requestAnimationFrame(render);

    renderer.render(scene, camera);
    controls.update();

    animateRocket();
}
```

<video width="100%" height="auto" preload="none" autoPlay={true} loop={true} muted={true} controls={false}>
    <source src="/markdownAssets/threejs/2024-01-26-01/2024-01-26-01-02.webm" type="video/webm" />
    첫번쨰 방법 - Animation 구현
</video>



<br />



## 두번째 방법: 3D Model 의 Keyframe Animation 사용하기

첫번쨰 방법으로는 복잡한 Animation 을 구현하기 어렵습니다.

3D Tool 을 사용하여 Model 의 Keyframe Animation 을 만들 수 있으며, Model 이 가진 Animation 을 그대로 사용할 수 있으므로, 정교하고 자연스러운 Animation 을 연출할 수 있습니다.

<br />

GLTFLoader 를 사용하여 Model 을 불러오면, callback 을 통하여 gltf 객체에 접근할 수 있습니다.

gltf 객체에는 animations 속성이 Model 의 Keyframe Animation 을 가지고 있습니다.

<br />

gltf 객체의 animations 를 사용하기 위해 `THREE.AnimationMixer` 객체를 생성합니다.

아래는 `THREE.AnimationMixer` 를 사용하여 Animation 을 적용한 코드 입니다.

```js title="두번째 방법 - AnimationMixer global 변수 정의" showLineNumbers {12, 38-39}
// three.js
import {
    WebGLRenderer,
    Scene,
    PerspectiveCamera,

    Color,
    DirectionalLight,

    Mesh,

    AnimationMixer,
} from 'three';
import {
    OrbitControls,
} from 'three/examples/jsm/controls/OrbitControls';
import {
    GLTFLoader,
} from 'three/examples/jsm/loaders/GLTFLoader';
// style
import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { Scene } */
let scene;

/** @type { PerspectiveCamera } */
let camera;

/** @type { OrbitControls } */
let controls;

/** @type { Mesh } */
let rocketModel;

/** @type { AnimationMixer } */
let animationMixer;
```

```js title="두번째 방법: Animation 구현" showLineNumbers{98} {10-13, 40-44}
//
// model
//
function initRocketModel() {
    const loader = new GLTFLoader();

    loader.load('/gltf/rocket.glb', gltf => {
        rocketModel = gltf.scene;

        animationMixer = new AnimationMixer(rocketModel);
        gltf.animations.forEach(clip => {
            animationMixer.clipAction(clip).play();
        });

        gltf.scene.position.set(0, -5, 5);
        gltf.scene.traverse(child => {
            if (!child.isMesh) {
                return;
            }

            child.castShadow = true;
            child.receiveShadow = true;
            child.material.metalness = 0;
        });

        scene.add(gltf.scene);
    });
}

//
// animation
//
function animateRocket() {
    // if (!rocketModel) {
    //     return;
    // }

    // rocketModel.rotation.y += 0.1;

    if (!animationMixer) {
        return;
    }

    animationMixer.update(1 / 60);
}
```

<video width="100%" height="auto" preload="none" autoPlay={true} loop={true} muted={true} controls={false}>
    <source src="/markdownAssets/threejs/2024-01-26-01/2024-01-26-01-03.webm" type="video/webm" />
    두번쨰 방법 - Animation 구현
</video>

<br />

위 코드를 살펴 보겠습니다.

먼저 `AnimationMixer` 타입 변수를 선언하고 있습니다.

이는 `AnimationMixer` 인스턴스를 생성하는 곳과 사용하는 scope 가 달라서 global 변수로 선언합니다.

<br />

그리고 GLTFLoader 를 사용하여 gltf 파일을 로드하게 되면, `AnimationMixer` 인스턴스를 생성합니다.

여기서 중요한 점은 `gltf.animations` 의 구성요소인 `animationClip` 객체를 `AnimationMixer` 에 모두 등록`(clipAction())` 해주고 `play()` 시켜주는 것 입니다.

이렇게 등록하게 되면, Frame 을 그릴때 마다 호출하는 `animate()` 함수 내부에서 `AnimationMixer` 의 `update(프레임_증감_값)` 으로 다음 Frame 을 그리게 됩니다.

결과적으로 `AnimationMixer` 에 등록한 Model 의 `animations` 속성을 렌더링하여, Animation 효과가 연출됩니다.



<br />



## 추가: gltf.animations 구성

* `AnimationClip` 타입: `gltf.animations` 를 구성하는 객체 타입




<br />



## 추가: AnimationClip 구성

* `duration`: Animation 의 길이(`초` 단위 시간값)
* `tracks`: Animation 을 구성하는 변화 데이터
    * `VectorKeyframeTrack` 타입 객체: Model 의 위치를 변경하는 Track
    * `QuaternionKeyframeTrack` 타입 객체: Model 을 회전시키는 Track
    * `tracks` 하위의 타입은 Three.js 에서 변경하기 보다, 어떤 효과로 구성된 Animation 인지 파악하는 정도로만 사용하면 될 것 같습니다.



<br />



## 마치며

원하는 Animation 을 구현하기 위해서는 3D Tool 사용방법도 익혀야 할 것 같습니다.

Model 의 Animation 을 코드로 구현하는 것은 원하는 결과를 얻기에는 쉽지 않을 것으로 생각되었습니다.
1c:T25c2,---
id: 8
title: 'Model (.gltf, .glb) 객체 구조파악 및 그림자 적용'
description: 'Three.js 환경에 불러온 Model 객체의 주요 구성요소를 파악하고, 속성값을 변경하여 그림자를 만들어 봅니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'threejs',
    'javascript',
    '3d',
    '.gltf',
    '.glb',
    'model',
    'traverse',
    'shadow',
]

createdAt: '2024-01-21 16:00:00'
modifiedHistories: []
---

# Model (.gltf, .glb) 객체 구조파악 및 그림자 적용

3D Tool (Cinema3D, Blender...) 에서 만든 Model 파일은 Three.js 에서 제공하는 `GLTFLoader` 를 사용하여 불러올 수 있습니다.

이렇게 불러온 Model 객체에 원하는 연출을 적용하려면, 불러온 Model 객체의 속성값을 변경하며 설정해주어야 합니다.

<br />

예를들어 그림자 효과는 Three.js 환경에 불러온 Model 객체의 `castShadow` 또는 `receiveShadow` 를 `true` 로 설정해주어야 적용됩니다.

뿐만아니라 렌더링 된 Model 의 Material 을 수정한다거나 하는 작업들을 통해서 **빛에 대한 Model 의 양감** 을 변경할 수도 있습니다.



<br />



## 예시코드

> [Model 다운로드 링크](https://polyhaven.com/a/coast_rocks_05)

이번 포스팅의 예시코드는 위 모델을 렌더링한 시점입니다.

```js title="예시코드" showLineNumbers {63-64, 82-84, 92-98}
// three.js
import {
    WebGLRenderer,
    Scene,
    PerspectiveCamera,

    Color,
    DirectionalLight,
} from 'three';
import {
    OrbitControls,
} from 'three/examples/jsm/controls/OrbitControls';
import {
    GLTFLoader,
} from 'three/examples/jsm/loaders/GLTFLoader';
// style
import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { Scene } */
let scene;

/** @type { PerspectiveCamera } */
let camera;

/** @type { OrbitControls } */
let controls;

//
// core
//
function initCanvas() {
    const $canvas = document.createElement('canvas');
    $canvas.width = window.innerWidth;
    $canvas.height = window.innerHeight;

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    return $canvas;
}

function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });

    renderer.shadowMap.enabled = true;
}

function initScene() {
    scene = new Scene();
}

function initCamera() {
    camera = new PerspectiveCamera();
    camera.fov = 35;
    camera.aspect = window.innerWidth / window.innerHeight;

    camera.position.set(-3, 3, 3);
    camera.lookAt(0, 0, 0);

    camera.updateProjectionMatrix();
}

function initControls($target) {
    controls = new OrbitControls(camera, $target);
    controls.enableDamping = true;
}

//
// light
//
function initDirectionalLight() {
    const color = new Color('#fff');
    const light = new DirectionalLight(color, 0.75);

    light.position.set(10, 10, 10);
    light.castShadow = true;
    light.shadow.mapSize.width = 2048;
    light.shadow.mapSize.height = 2048;

    scene.add(light);
}

//
// mesh
//
function initCoastRocksMesh() {
    const loader = new GLTFLoader();

    loader.load('/gltf/coast-rocks-05/coast_rocks_05_4k.gltf', gltf => {
        scene.add(gltf.scene);
    });
}

//
// executor
//
function render() {
    window.requestAnimationFrame(render);

    renderer.render(scene, camera);
    controls.update();
}

(function init() {
    const $canvas = initCanvas();
    initRenderer($canvas);
    initScene();
    initCamera();
    initControls($canvas);

    initDirectionalLight();

    initCoastRocksMesh();

    render();
}());
```

<img src="/markdownAssets/threejs/2024-01-21-01/2024-01-21-01-01.png" alt="예시코드 결과" />



<br />



## Model 객체 구성요소

`GLTFLoader` 를 사용하여 불러온 Model 은 3D Tool 로 개발한 Model 의 정보를 포함하고 있습니다.

3D Tool 에서 parent 와 children 구조를 사용하여 Model 을 만들었다면, Three.js 에서 불러온 Model 객체 역시 동일한 구조를 가지게 됩니다.

그리고 Three.js 에서 활용하기 위한 추가적인 정보와 메소드 등을 가지고 있습니다.

<img src="/markdownAssets/threejs/2024-01-21-01/2024-01-21-01-02.png" alt="Model 객체" />

<br />

* `animations`: 3D Tool 에서 만든 Animation 객체
* `scene`: Model 의 Mesh 객체

<br />

이번 포스팅에서는 **scene** 속성의 일부를 살펴보겠습니다.



<br />



## Model 객체의 **scene** 속성

Model 객체의 Scene 속성은 **Group** type 이며, Model 의 최상위 Mesh 역할을 합니다.

우리가 Three.js 에 렌더링할 때 사용했던 속성입니다.

그리고 중첩된 **children** 속성으로 하위 Mesh 를 포함하고 있습니다.

<img src="/markdownAssets/threejs/2024-01-21-01/2024-01-21-01-03.png" alt="Model Scene 객체" />

<br />

**children** 의 구성요소로 사용되는 대표적인 **type** 은 다음과 같습니다.

* **Mesh** 타입: 3D Tool 에서 만든 Mesh 객체만이 이 타입의 인스턴스가 됩니다.
* **Object3D** 타입: **Mesh 타입이 아닌 모든 객체** 가 이 타입의 인스턴스로 표현됩니다.
    * 3D Tool 의 **Null Object (group)**
    * 3D Tool 의 **대칭 생성(Symmetry)**, **부드러운 면 만들기(Subdivision surface)** 등의 유틸 객체



<br />



## Mesh 타입 객체의 주요 속성

* `name`: 3D Tool 에서 명명한 이름입니다.
* `isMesh`: `true` 값을 가지며, 이 객체가 **Mesh 타입 객체** 라는 것을 단언할 수 있는 상태값입니다.
* `type`: 이 객체의 type 명입니다.
* `material`: `Material` 객체 입니다.
    * 그림자, 재질 등을 변경할 때 사용하게 될 속성(객체) 입니다.
* `position`: Three.js 에 렌더링할 좌표값 입니다.
* `rotation`: Three.js 에서 얼만큼 회전시켜서 렌더링할지 설정값 입니다.
* `scale`: Three.js 상에서 얼만큼 확대/축소 할지에 대한 설정값 입니다.
* `castShadow`: 그림자 생성 여부에 대한 설정 입니다.
* `receiveShadow`: 다른 Mesh 의 그림자에 영향을 받을지에 대한 설정 입니다.



<br />



## `traverse` 메서드

Model 은 복수의 Mesh 객체들로 구성될 수 있습니다.

이는 **children** 속성으로 중첩된 구조를 갖습니다.

만약 그림자 설정을 변경한다면, Model 을 구성하는 모든 Mesh 객체의 그림자 설정값을 변경해주어야 합니다.

<br />

3D Tool 에서 만든 Model 이 어떤 구조로 되어있는지 모든 구조를 파악하고 설정을 바꿔주는 것은 매우 어려워 보입니다.

그래서 Model 객체의 **scene** 속성(객체) 는 `traverse()` 메서드를 제공합니다.

<br />

`traverse()` 메소드는 Model 을 구성하는 모든 **children** 을 깊은 탐색하는 기능을 수행합니다.

즉, 그림자 설정을 변경한다면, `traverse()` 메소드를 사용하여 모든 하위 Mesh 에 설정을 일괄 변경할 수 있습니다.

<br />

탐색 대상이 되는 children 구성요소는 Mesh 타입이 아닐수도 있습니다.

이때 Mesh 객체인지 식별하기 위해 `isMesh` 속성을 사용하게 됩니다.

<br />

아래 코드는 `traverse()` 메소드를 사용하여 그림자 설정을 활성화 하고 있습니다.

```js title="traverse() 를 사용한 그림자 설정" showLineNumbers{92} {5-12}
function initCoastRocksMesh() {
    const loader = new GLTFLoader();

    loader.load('/gltf/coast-rocks-05/coast_rocks_05_4k.gltf', gltf => {
        gltf.scene.traverse(obj => {
            if (!obj.isMesh) {
                return;
            }

            obj.castShadow = true;
            obj.receiveShadow = true;
        });

        scene.add(gltf.scene);
    });
}
```

<img src="/markdownAssets/threejs/2024-01-21-01/2024-01-21-01-04.png" alt="traverse() 메소드" />



<br />



## 추가: 빛에 대한 Model 객체의 양감 설정하기

`traverse()` 메소드를 사용하여 Mesh 객체의 **material** 속성을 일괄 변경할 수 있습니다.

Mesh 객체는 **material** 속성을 가지고 있으므로, 이를 사용하여 Mesh 의 양감을 변경할 수 있습니다.

<br />

양감은 Mesh 의 색상이 뚜렷하게 렌더링되는 경우에 풍부하게 연출됩니다.

material 의 `metalness` 값을 `0` 으로 설정하면, 주변 배경을 반사하는 것이 아닌, Mesh 본연의 색상에서 빛의 반사효과만 렌더링됩니다.

<br />

또한 `roughness` 값을 변경하여 빛이 얼마나 뚜렷하게 비춰질지 설정할 수도 있습니다.

```js title="빛에 대한 Metal 객체의 양감 설정하기" showLineNumbers{92} {12-13}
function initCoastRocksMesh() {
    const loader = new GLTFLoader();

    loader.load('/gltf/coast-rocks-05/coast_rocks_05_4k.gltf', gltf => {
        gltf.scene.traverse(obj => {
            if (!obj.isMesh) {
                return;
            }

            obj.castShadow = true;
            obj.receiveShadow = true;
            obj.material.metalness = 0;
            obj.material.roughness = 0;
        });

        scene.add(gltf.scene);
    });
}
```



<br />



## 마치며

Model 에 그림자 설정을 위한 코드는 `traverse()` 메소드를 사용하면 간단하게 적용할 수 있었습니다.

Model 객체가 어떻게 구성되고, 설정을 변경하는 이유 등을 파악하는 것이 쉽지는 않았습니다.

이번 포스팅에서 정리한 내용은 Three.js 전반에 필요한 개념으로 생각되어 성취감이 느껴집니다.
1d:T2000,---
id: 7
title: 모델 파일을 Three.js 에 렌더링하기
description: '.gltf 또는 .glb 확장자인 모델 파일을 Three.js 에 불러오고 렌더링하는 방법을 정리합니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'threejs',
    'javascript',
    '3d',
    'hdr',
    '.gltf',
    '.glb',
    'model',
]

createdAt: '2024-01-10 23:50:00'
modifiedHistories: []
---

# 모델 파일을 Three.js 에 렌더링하기

3D 모델 파일의 확장자는 아래와 같습니다.

* .gltf
    * 3D 모델 파일이며 JSON 형식의 데이터입니다.
* .glb
    * 3D 모델 파일이며 Binary 데이터입니다.
    * **3D 모델을 렌더링하여 사용할 목적이라면, .glb 파일의 용량이 더 적으므로 적합합니다.**

<br />

이번 포스팅에서는 3D 모델 파일을 Three.js 에 렌더링하는 방법과 불러온 모델 객체를 수정하는 방법에 대해 정리하고자 합니다.



<br />



## 용어 정리

### Luminance

Luminance 는 **휘도** 라는 뜻을 가집니다.

Three.js 에서는 **emissive** 가 **빛을 방출하는 정도에 대한 속성** 이지만, 3D Tool 중 Cinema4D 에서는 **Luminance** 로 표기되어 있습니다.



<br />



## 예시 코드

이번 포스팅에서 사용할 예시 코드는 다음과 같습니다.

```js title="예시 코드" showLineNumbers
import {
    WebGLRenderer,
    Scene,
    PerspectiveCamera,

    Color,
    DirectionalLight,
    HemisphereLight,

    SphereGeometry,
    MeshStandardMaterial,
    Mesh,
} from 'three';
import {
    OrbitControls,
} from 'three/examples/jsm/controls/OrbitControls';
import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { Scene } */
let scene;

/** @type { PerspectiveCamera } */
let camera;

/** @type { OrbitControls } */
let controls;

//
// core
//
function initCanvas() {
    const $canvas = document.createElement('canvas');
    $canvas.width = window.innerWidth;
    $canvas.height = window.innerHeight;

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    return $canvas;
}

function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });

    renderer.shadowMap.enabled = true;
}

function initScene() {
    scene = new Scene();
}

function initCamera() {
    camera = new PerspectiveCamera();
    camera.fov = 35;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.position.set(0, 0, 2);

    camera.updateProjectionMatrix();
}

function initControls($emitter) {
    controls = new OrbitControls(camera, $emitter);
    controls.enableDamping = true;
}

//
// light
//
function initDirectionalLight() {
    const color = new Color('#fff');

    const light = new DirectionalLight(color);
    light.position.set(1, 1, 1);
    light.castShadow = true;

    scene.add(light);
}

function initHemisphereLight() {
    const skyColor = new Color('#fff');
    const groundColor = new Color('#000');

    const light = new HemisphereLight(
        skyColor,
        groundColor,
        0.25
    );

    scene.add(light);
}

//
// mesh
//
function initSphereMesh() {
    const geometry = new SphereGeometry();
    const material = new MeshStandardMaterial();
    const sphere = new Mesh(geometry, material);

    scene.add(sphere);
}

//
// executor
//
function render() {
    window.requestAnimationFrame(render);

    renderer.render(scene, camera);
    controls.update();
}

function init() {
    const $canvas = initCanvas();

    initRenderer($canvas);
    initScene();
    initCamera();
    initControls($canvas);

    initDirectionalLight();
    initHemisphereLight();

    initSphereMesh();

    render();
}

init();
```



<br />



## GLTFLoader 를 사용하여 3D 모델 파일 불러오기

.glb 또는 .gltf 파일을 불러오기 위해서는 Loader 가 필요합니다.

이 때 사용하는 Loader 는 GLTFLoader 인스턴스 입니다.

아래는 .gltf 파일을 불러온 후, 불러온 모델 객체를 `console.log()` 로 출력하고 있습니다.

```js title="GLTFLoader import 하기" showLineNumbers{17}
import {
    GLTFLoader,
} from 'three/examples/jsm/loaders/GLTFLoader';
```

```js title="GLTFLoader 로 .gltf 파일 불러오기" showLineNumbers{112}
function initRubberDuck() {
    const loader = new GLTFLoader();
    loader.load('/gltf/rubberDuck/rubber_duck_toy_4k.gltf', gltf => {
        console.group('onLoad()');
        console.log('gltf: ', gltf);
        console.groupEnd();
    });
}
```

```js title="iniRubberDuct 함수 호출" showLineNumbers{131} {13}
function init() {
    const $canvas = initCanvas();

    initRenderer($canvas);
    initScene();
    initCamera();
    initControls($canvas);

    initDirectionalLight();
    initHemisphereLight();

    initSphereMesh();
    initRubberDuck();

    render();
}
```

<br />

부라우저 콘솔에서 확인하면, GLTFLoader 가 불러온 3D 모델 객체를 확인할 수 있습니다.



## 불러온 3D 모델 객체 렌더링하기

불러온 3D 모델 객체에는 **scene 속성** 이 있습니다.

**scene 속성** 을 Mesh 와 동일하게 취급할 수 있습니다.

따라서 기존의 sphere Mesh 를 `scene.add()` 메서드로 추가했던 것과 동일한 방법으로 `scene` 에 추가할 수 있습니다.

```js title="3D 모델 객체 렌더링" showLineNumbers{112} {8-9}
function initRubberDuck() {
    const loader = new GLTFLoader();
    loader.load('/gltf/rubberDuck/rubber_duck_toy_4k.gltf', gltf => {
        console.group('onLoad()');
        console.log('gltf: ', gltf);
        console.groupEnd();

        gltf.scene.position.set(0, -0.15, 0);
        scene.add(gltf.scene);
    });
}
```

<img src="/markdownAssets/threejs/2024-01-10-01/2024-01-10-01-01.png" alt="3D 모델 렌더링" />



<br />



## 추가: 불러온 3D 모델이 깨지는 현상

3D 모델을 Three.js 에 렌더링했을 때, 깨지는 현상이 발생할 수 있습니다.

이는 3D Tool(예: Cinema4D, Blender) 를 사용하여, 모델의 **Material** 을 수정하여 해결할 수 있습니다.

가장 유력한 케이스는 **Material** 설정 중, **Alpha** 설정이 활성화된 경우 입니다.

만약 **Alpha** 설정이 활성화되어 있었다면, 해제 후 export 한 파일을 사용해봅니다.

<br />

Three.js 는 브라우저 환경에서 동작하기 때문에 3D Tool 의 무거운 기능들은 지원하지 않습니다.

이러한 현상이 나타난다면, **Material** 을 좀 더 가볍게 하면 해소할 수 있습니다.



<br />



## 3D 모델 객체 구조 살펴보기

Three.js 에 불러온 3D 모델을 그대로 렌더링했을 때, 원하는 결과를 얻지 못할 가능성이 큽니다.

특히 그림자 설정은 3D 모델을 개발할 때 설정하는 것이 아닌, Three.js 에 렌더링할 객체의 설정이 필요한 경우입니다.

이러한 이유로 Three.js 에 불러온 3D 모델 객체의 주요 속성들을 수정하기 위해, 먼저 속성들을 살펴보겠습니다.

<br />

GLTFLoader 로 불러운 3D 모델을 gltf 로 칭하겠습니다.

gltf 객체는 크게 다음과 같은 속성이 있습니다.

* scene
    * Mesh 처럼 다룰 수 있으며, 렌더링할 때도 사용합니다.
* animations
    * 애니메이션 객체 입니다.
* children
    * 3D Tool 로 개발할 때 만든 부모-자식 계층 입니다.
* material
    * 현재 Mesh 의 Material 설정입니다.

<br />

gltf 객체의 scene 과 children 의 중첩구조를 살펴보면 크게 2가지 타입으로 이루어져 있습니다.

* Mesh
    * 실제 Mesh 객체입니다.
* Object3D
    * Mesh 가 아닌 기타 타입입니다.
    * 3D Tool 의 Symmetry(대칭복사), Subdivision(곡선생성) 등의 기능으로 만든 부분 (엄밀히 Mesh 는 아니기 때문)



<br />



## 마치며

3D Mesh 파일(.glTF, .gbl) 을 불러온 상태에서는 빛 반사나 그림자와 같은 효과는 적용되지 않습니다.

다음 포스팅에서는 3D Mesh 불러온 후, Mesh 내부 속성을 변경하는 방법을 알아보겠습니다.
1e:T3408,---
id: 6
title: 배경화면 및 환경조명 설정하기
description: '360도 이미지 확장자인 .hdr 파일을 사용하여 배경화면을 설정하고, 배경화면에 의한 환경조명 설정에 대한 정리입니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'threejs',
    'javascript',
    '3d',
    'hdr',
    'background',
    '3D 배경화면',
    '환경조명',
]

createdAt: '2024-01-08 23:50:00'
modifiedHistories: []
---

# 배경화면 및 환경조명 설정하기

지금까지는 배경이 없는 환경에서 물체를 렌더링하였습니다.

3D 환경에서 배경화면을 설정하기 위해 360도 이미지 파일인 **.hdr (Hign Dynamic Range)** 파일을 설정해 보고자 합니다.

<br />

추가로 배경화면이 물체에 반사되는 환경조명까지 설정해 보겠습니다.

환경조명을 설정하게 되면, 배경이 스틸에 반사되는 효과를 연출할 수 있습니다.

이를 위해 **Material** 설정 방법에 대해서도 정리합니다.



<br />



## 예시 코드

이번 포스팅에서 사용할 예시 코드는 다음과 같습니다.

```js title="예시 코드" showLineNumbers
import {
    WebGLRenderer,
    Scene,
    PerspectiveCamera,

    Color,

    DirectionalLight,
    DirectionalLightHelper,
    HemisphereLight,
    HemisphereLightHelper,

    Mesh,
    MeshStandardMaterial,

    SphereGeometry,
    PlaneGeometry,

    VSMShadowMap,
} from 'three';
import {
    OrbitControls,
} from 'three/examples/jsm/controls/OrbitControls';

import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { Scene } */
let scene;

/** @type { PerspectiveCamera } */
let camera;

/** @type { OrbitControls } */
let controls;

//
// core
//
function initCanvas() {
    const $canvas = document.createElement('canvas');
    $canvas.width = window.innerWidth;
    $canvas.height = window.innerHeight;

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    return $canvas;
}

function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });

    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = VSMShadowMap;
}

function initScene() {
    scene = new Scene();
}

function initCamera() {
    camera = new PerspectiveCamera();
    camera.fov = 75;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.position.set(-3, 3, 5);

    camera.updateProjectionMatrix();
}

function initControls($canvas) {
    controls = new OrbitControls(camera, $canvas);
    controls.enableDamping = true;
}

//
// light
//
function initDirectionalLight() {
    const color = new Color('#fff');

    const light = new DirectionalLight(
        color,
        0.75
    );
    light.position.set(1, 1, 1);
    light.castShadow = true;
    light.shadow.blurSamples = 30;
    light.shadow.radius = 12;

    const helper = new DirectionalLightHelper(light);

    scene.add(light);
    scene.add(helper);
}

function initHemisphereLight() {
    const skyColor = new Color('#fff');
    const groundColor = new Color('#000');

    const light = new HemisphereLight(
        skyColor,
        groundColor,
        0.25
    );

    const helper = new HemisphereLightHelper(light);

    scene.add(light);
    scene.add(helper);
}

//
// mesh
//
function initSphereMesh() {
    const geometry = new SphereGeometry();
    const material = new MeshStandardMaterial();
    const sphere = new Mesh(geometry, material);
    sphere.castShadow = true;

    scene.add(sphere);
}

function initPlaneMesh() {
    const geometry = new PlaneGeometry(10, 10);
    const material = new MeshStandardMaterial();
    const plane = new Mesh(geometry, material);
    plane.position.set(0, -1, 0);
    plane.rotation.set(Math.PI / -2, 0, 0);
    plane.receiveShadow = true;

    scene.add(plane);
}

//
// executor
//
function render() {
    window.requestAnimationFrame(render);

    controls.update();
    renderer.render(scene, camera);
}

(function init() {
    const $canvas = initCanvas();
    initRenderer($canvas);
    initScene();
    initCamera();
    initControls($canvas);

    initDirectionalLight();
    initHemisphereLight();

    initSphereMesh();
    initPlaneMesh();

    render();

    console.log('init()');
}());
```



<br />



## **.hdr** 파일이란?

Three.js 는 3D 환경입니다.

배경화면을 설정하려면 일반적인 2D 이미지를 사용해서는 연출할 수 없습니다.

**.hdr (High Dynamic Range)** 확장자를 가진 파일은 360도 이미지 파일이며, 이 파일을 사용하여 3D 환경에 배경화면을 설정할 수 있습니다.

<br />

360도 배경화면은 아래의 플렛폼에서 오픈소스로 다운로드할 수 있습니다.

* [polyhaven.com](https://polyhaven.com/hdris)



<br />



## 용어 정리

이번 포스팅에서 사용하게될 컴퓨터 그래픽스 용어에 대해 간단하게 정리하고 가겠습니다.

### Vertex

3D 공간에서 가장 작은 단위인 **점** 을 말합니다.

### Edge

2개의 Vertex 를 연결하여 생성된 **선** 을 말합니다.

### Polygon

복수의 Edge 를 연결하여 만들어진 **면** 을 말합니다.

가장 작은 Polygon 은 3개의 Edge 로 만들 수 있는 삼각형 입니다.

### Mesh

복수의 Polygon 으로 만들 수 있는 다각형으로, 지금까지 사용해보았던 Sphere, Box, Plane 등을 말합니다.

### Texture

[참고: 나무위키](https://namu.wiki/w/%ED%85%8D%EC%8A%A4%EC%B2%98)

3D 물체의 표면에 2D 이미지를 입혀서 렌더링 하는 방식을 말합니다.

Mesh 를 구성하는 Polygon 이 많을수록 성능을 많이 사용하게 되는데, 이를 해소하기 위해 Mesh 의 표면에 2D 이미지를 입히는 방식의 렌더링 요소 입니다.

### emissive

emission 은 **(빛)방사** 라는 뜻을 가집니다.

컴퓨터 그래픽스에서 **emissive** 라는 용어를 사용하는데, 이는 Mesh 가 광원이 되여 빛을 방출한다는 것을 말합니다.

### (영단어) equirectangular

정사각형

### (영단어) reflection

반사

### (영단어) refraction

굴절



<br />



## RGBELoader 를 사용하여 .hdr 파일을 Texture 로 만들기

3D 공간 자체를 하나의 Mesh 라고 가정해 보겠습니다.

Three.js 에서는 `Scene` 객체가 배경의 역할을 하고 있습니다.

배경화면을 설정하기 위해서는 `Scene` 의 `background` 에 `Texture` 를 입혀서 표현할 수 있습니다.

<br />

Three.js 는 다양한 **DataTextureLoader** 를 제공하는데, Loader 를 사용하면 360도 이미지인 `.hdr` 파일을 읽어서 `Texture` 객체로 만들 수 있습니다.

생성한 `Texture` 를 `Scene` 의 `background` 로 입혀주는 것으로 배경화면을 설정할 수 있습니다.

[Three.js 공식문서 - DataTextureLoader](https://threejs.org/docs/#api/en/loaders/DataTextureLoader)

<br />

```js title="import 하기" showLineNumbers {21, 27}
import {
    WebGLRenderer,
    Scene,
    PerspectiveCamera,

    Color,

    DirectionalLight,
    DirectionalLightHelper,
    HemisphereLight,
    HemisphereLightHelper,

    Mesh,
    MeshStandardMaterial,

    SphereGeometry,
    PlaneGeometry,

    VSMShadowMap,

    EquirectangularReflectionMapping,
} from 'three';
import {
    OrbitControls,
} from 'three/examples/jsm/controls/OrbitControls';
import {
    RGBELoader,
} from 'three/examples/jsm/loaders/RGBELoader';
```

```js title="Scene 에 배경화면 설정하기" showLineNumbers{68} {4-9}
function initScene() {
    scene = new Scene();

    const loader = new RGBELoader();
    loader.load('/hrd/background.hdr', texture => {
        texture.mapping = EquirectangularReflectionMapping;

        scene.background = texture;
    });
}
```

<br />

먼저 import 부분을 살펴보겠습니다.

**EquirectangularReflectionMapping** 은 Texture 의 mapping 방식을 제공하는 **객체** 입니다.

Texture 객체의 `mapping` 속성에 **EquirectangularReflectionMapping** 객체를 대입하는 것으로 mapping 방식을 설정하게 됩니다.

<br />

Three.js 에서 제공하는 Texture mapping 방식은 여러가지가 있습니다.

[Three.js 공식문서 - Texture Constants](https://threejs.org/docs/index.html?q=texture#api/en/constants/Textures)

* UVMapping (default)
* CubeReflectionMapping 
* CubeRefractionMapping
* EquirectangularReflectionMapping
* EquirectangularRefractionMapping 
* CubeUVReflectionMapping

<br />

위에서 사용한 **EquirectangularReflectionMapping** 은 **environment map** 에 사용하는 Texture mapping 방식 입니다.

이 mapping 방식을 사용하게 되면 `.hdr` 이미지가 마치 배경처럼 렌더링됩니다.

<br />

Texture 의 mapping 방식을 설정해준 뒤, **Scene** 의 `background` 속성에 Texture 를 대입하면 배경화면이 렌더링된 것을 볼 수 있습니다.

<img src="/markdownAssets/threejs/2024-01-08-01/2024-01-08-01-01.png" alt="배경화면 설정" />



<br />



## 환경조명 설정

빛이 있어야 물체가 렌더링 됩니다.

지금까지는 DirectionalLight 나 HemisphereLight 처럼 조명 객체를 생성하여 빛을 만들었습니다.

이번에는 조명을 모두 제거하고, 환경조명으로 렌더링하고자 합니다.

<br />

**Scene** 의 `environment` 속성에 환경조명으로 사용할 Texture 를 대입하여 설정할 수 있습니다.

`background` 로 사용했던 Texture 를 환경조명으로도 사용하도록 해보겠습니다.

```js title="환경조명 설정하기" showLineNumbers{68} {9}
function initScene() {
    scene = new Scene();

    const loader = new RGBELoader();
    loader.load('/hdr/background.hdr', texture => {
        texture.mapping = EquirectangularReflectionMapping;

        scene.background = texture;
        scene.environment = texture;
    });
}
```

<img src="/markdownAssets/threejs/2024-01-08-01/2024-01-08-01-02.png" alt="환경조명 설정하기" />

<br />

환경조명으로 설정한 Texture 의 밝은 부분과 어두운 부분이 조명의 세기로 적용되어 배경화면과 자연스러운 연출이 됩니다.



<br />



## 배경화면을 반사하는 Mesh 만들기

Sphere 와 Plane Mesh 를 렌더링하고 있습니다.

현재는 각 Mesh 에 설정한 **MeshStandardMaterial** 색상 그대로 렌더링되는 상태입니다.

이번에는 Mesh 의 Material 에 설정을 추가하여, 배경화면이 Mesh 에 비추어지는 효과를 연출해 보겠습니다.

<br />

Mesh 의 외관은 Material 에 의해 렌더링 결과가 달라집니다.

Material 은 Mesh 의 색상이나 질감을 표현하는 객체입니다.

배경화면을 반사하는 Mesh 를 만들기 위해서는 Material 설정을 사용하여 구현할 수 있습니다.

```js title="배경화면을 반사하는 Mesh 설정하기" showLineNumbers{134} {3-8}
function initSphereMesh() {
    const geometry = new SphereGeometry();
    const material = new MeshStandardMaterial({
        color: new Color('#fff'),
        roughness: 0,
        metalness: 1,
        // emissive: Color('#000'),
    });
    const sphere = new Mesh(geometry, material);
    sphere.castShadow = true;

    scene.add(sphere);
}
```

<img src="/markdownAssets/threejs/2024-01-08-01/2024-01-08-01-03.png" alt="Material 설정" />

<br />

**MeshStandardMaterial** 생성자 params 를 사용하여 Material 를 설정하고 있습니다.

params 의 각 속성은 다음고 같은 설정을 가집니다.

* `color`: 
    * Material 자체의 색상입니다. (Mesh 의 색상이 됩니다.)
* `roughness`: 
    * 배경화면을 반사하는 Mesh 의 질감을 얼만큼 거칠게 표현할지에 대한 설정입니다.
    * `0` 설정 시, 배경화면이 깔끔하게 반사됩니다.
    * `1` 설정 시, 반사되는 배경화면이 분간하기 어려울 정도로 어글어져서 렌더링됩니다.
* `metalness`:
    * 매탈 재질처럼 보이는 정도를 설정합니다.
    * `0` 설정 시, 메탈 느낌 보다는 플라스틱 느낌이 강하며, 함께 설정한 `color` 의 비중이 더 크게 렌더링됩니다.
    * `1` 설정 시, 함께 설정한 `color` 는 거의 보이지 않고, 메탈 느낌으로 렌더링됩니다.
* `emissive`:
    * Mesh(Material) 이 방출하는 빛의 색상을 설정합니다.
    * `밝은색` 설정 시, 광원처럼 밝은 빛을 내며, 자신의 그림자가 거의 생기지 않습니다.
    * `어두운색` 설정 시, 발광하는 빛이 거의 없으며, 자신의 그림자가 비교적 선명하게 생깁니다.
    * 일반적으로 활용도가 떨어지는 설정이라서, 잘 사용하지 않습니다.



<br />



## 마치며

Material 설정을 통해 배경화면을 반사하는 효과를 연출해 보았습니다.

이번에 사용한 반사효과는 배경화면만을 반사하고, Mesh 간의 반사는 렌더링되지 않습니다.

**Post Processing** 기능을 사용하면, 거울처럼 다른 Mesh 와 상호작용하며 반사하는 연출이 가능해집니다.

이 부분은 차후 정리할 예정입니다.

[Three.js 공식문서 - 거울효과 예시](https://threejs.org/examples/?q=mirror#webgl_mirror)
1f:T2c06,---
id: 5
title: 그림자 표현하기
description: '그림자 설정방법과 특징에 대해 정리합니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'threejs',
    'javascript',
    '3d',
    'shadow',
]

createdAt: '2024-01-07 23:50:00'
modifiedHistories: []
---

# 그림자 표현하기

그림자를 표현하기 위해서는 물체와 조명의 각도, 그림자의 크기, 형태 등의 상호작용 연산이 필요합니다.

그래서 Three.js 의 그림자 설정의 기본값은 모두 미사용으로 설정되어 있습니다.

이 덕분에 개발자가 원하는 조명과 원하는 물체의 그림자를 직접 지정하여 표현할 수 있습니다.



<br />



## 예시 코드

이전 포스팅에서 바닥(땅) 을 만들었던 코드에 그림자 설정을 추가해 보겠습니다.

```js title="예시 코드" showLineNumbers
import {
    WebGLRenderer,
    Scene,
    PerspectiveCamera,

    Mesh,
    MeshStandardMaterial,
    SphereGeometry,
    PlaneGeometry,

    Color,
    HemisphereLight,
    HemisphereLightHelper,
    DirectionalLight,
    DirectionalLightHelper,
} from 'three';
import {
    OrbitControls,
} from 'three/examples/jsm/controls/OrbitControls';
import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { Scene } */
let scene;

/** @type { PerspectiveCamera } */
let camera;

/** @type { OrbitControls } */
let controls;

function initCanvas() {
    const $canvas = document.createElement('canvas');
    $canvas.width = window.innerWidth;
    $canvas.height = window.innerHeight;

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    return $canvas;
}

function initScene() {
    scene = new Scene();
}

function initCamera() {
    camera = new PerspectiveCamera();
    camera.fov = 35;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.position.set(0, 0, 12);

    camera.updateProjectionMatrix();
}

function initControls($canvas) {
    controls = new OrbitControls(camera, $canvas);
    controls.enableDamping = true;
}

function initHemisphereLight() {
    const skyColor = new Color('#fff');
    const groundColor = new Color('#000');
    const light = new HemisphereLight(
        skyColor,
        groundColor,
        0.75
    );

    const helper = new HemisphereLightHelper(light);

    scene.add(light);
    scene.add(helper);
}

function initDirectionalLight() {
    const color = new Color('#fff');
    const light = new DirectionalLight(color);
    light.position.set(2, 2, 2);

    const helper = new DirectionalLightHelper(light);

    scene.add(light);
    scene.add(helper);
}

function initSphereMesh() {
    const geometry = new SphereGeometry();
    const material = new MeshStandardMaterial();
    const sphere = new Mesh(geometry, material);

    scene.add(sphere);
}

function initPlaneMesh() {
    const geometry = new PlaneGeometry(10, 10);
    const material = new MeshStandardMaterial();
    const plane = new Mesh(geometry, material);
    plane.position.set(0, -1, 0);
    plane.rotation.set(
        Math.PI * -0.5,
        0,
        0
    );

    scene.add(plane);
}

function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });
}

function render() {
    window.requestAnimationFrame(render);

    renderer.render(scene, camera);
    controls.update();
}

(function init() {
    const $canvas = initCanvas();
    initRenderer($canvas);
    initScene();
    initCamera();
    initControls($canvas);

    initHemisphereLight();
    initDirectionalLight();

    initSphereMesh();
    initPlaneMesh();

    render();
}());
```



<br />



## 그림자 종류

Three.js 에서 제공하는 그림자는 크게 2가지로 볼 수 있습니다.

* Hard Shadow: 선명하며 거친 그림자를 표현합니다.
* Soft Shadow: 부드러운 그림자를 표현합니다.

<br />

Soft Shadow 는 그림자에 Blur 를 적용하여 부드럽게 표현합니다.

주의할 점은 Blur 값을 크게 설정할수록 부드럽게 표현하지만, 사용자 PC 의 연산량이 커진다는 것 입니다.

<br />

Three.js 의 그림자 설정은 다음과 같은 과정으로 만들 수 있습니다.

1. Hard Shadow 설정하기
2. Soft Shadow 설정 추가하기



<br />



## 그림자 설정이 필요한 인스턴스들

그림자를 표현하려면 몇가지 설정을 함께 해주어야 합니다.

아래는 그림자 설정이 필요한 인스턴스들 입니다.

* WebGLRenderer 인스턴스
* Light 인스턴스
* Mesh 인스턴스



<br />



## WebGLRenderer 에 shadow 설정하기

WebGLRenderer 는 **ShadowMap** 이라는 메커니즘을 제공합니다.

지금은 컴퓨터 그래픽스에서 그림자를 표현하는 여러 알고리즘 중 한가지 라는 것 정도로 정리하고자 합니다.

* WebGLRenderer shadowMap 은 그림자를 이미지로 생성한 후, 그림자를 씌우는 방식으로 동작합니다.

<br />

아래 코드는 WebGLRenderer 가 그림자를 표현하도록 설정합니다.

```js title="WebGLRenderer 그림자 사용 설정" showLineNumbers{111} {7}
function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });

    renderer.shadowMap.enabled = true;
}
```



<br />



## Light 와 Mesh 의 그림자 설정 (Hard Shadow)

Light 와 Mesh 의 그림자 설정 속성은 동일한 인터페이스를 가집니다.

그림자 설정 속성은 크게 두가지가 있습니다.

* 그림자를 만들어내는 설정: `castShadow`
* 다른 Mesh 의 그림자를 받는 설정: `receiveShadow`

<br />

Light 가 비추는 빛은 다른 Mesh 에 의해 그림자를 생성하게 됩니다.

그러므로 Light 의 **castShadow** 를 `true` 로 설정해줍니다.

```js title="DirectionalLight shadow 설정" showLineNumbers{78} {5}
function initDirectionalLight() {
    const color = new Color('#fff');
    const light = new DirectionalLight(color);
    light.position.set(2, 2, 2);
    light.castShadow = true;

    const helper = new DirectionalLightHelper(light);

    scene.add(light);
    scene.add(helper);
}
```

<br />

빛에 의해 그림자를 만들어내는 Mesh 역시 그림자를 생성하므로, **caseShadow** 를 `true` 로 설정해줍니다.

```js title="Sphere Mesh shadow 설정" showLineNumbers{90} {5}
function initSphereMesh() {
    const geometry = new SphereGeometry();
    const material = new MeshStandardMaterial();
    const sphere = new Mesh(geometry, material);
    sphere.castShadow = true;

    scene.add(sphere);
}
```

<br />

바닥(땅) 을 표현한 Plane Mesh 는 다른 Mesh 의 그림자를 받게 되므로, **receiveShadow** 를 `true` 로 설정해줍니다.

```js title="Plane Mesh shadow 설정" showLineNumbers{99} {12}
function initPlaneMesh() {
    const geometry = new PlaneGeometry(10, 10);
    const material = new MeshStandardMaterial();
    const plane = new Mesh(geometry, material);
    plane.position.set(0, -1, 0);
    plane.rotation.set(
        Math.PI * -0.5,
        0,
        0
    );

    plane.receiveShadow = true;

    scene.add(plane);
}
```

<br />

<img src="/markdownAssets/threejs/2024-01-07-02/2024-01-07-02-01.png" alt="Hard Shadow" />

<br />

지금까지 설정하여 만들어낸 그림자는 **Hard Shadow** 입니다.

Blur 처리를 하지 않기 때문에 선명한 그림자가 그려지고, 곡선에서 픽셀이 보이는 특징이 있습니다.



<br />



## Soft Shadow 설정 추가하기

Hard Shadow 설정을 한 후, WebGLRenderer 의 `shadowMap.type` 을 `VSMShadowMap` 으로 설정하므로써 Soft Shadow 로 표현됩니다.

```js title="VSMShadowMap import 하기" showLineNumbers {16}
import {
    WebGLRenderer,
    Scene,
    PerspectiveCamera,

    Mesh,
    MeshStandardMaterial,
    SphereGeometry,
    PlaneGeometry,

    Color,
    HemisphereLight,
    HemisphereLightHelper,
    DirectionalLight,
    DirectionalLightHelper,
    VSMShadowMap,
} from 'three';
```

```js title="Soft Shadow" showLineNumbers{116} {8}
function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });

    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = VSMShadowMap;
}
```

<br />

위 코드에서 사용한 `VSMShadowMap` 이외에도 다른 종류의 shadowMap 을 사용할 수도 있습니다. (이번 포스팅에서는 `VSMShadowMap` 을 사용합니다.)

[Three.js 공식 문서 - WebGLRenderer.shadowMap](https://threejs.org/docs/index.html?q=webglRenderer#api/en/renderers/WebGLRenderer.shadowMap)

* BasicShadowMap
* PCFShadowMap (default)
* PCFSoftShadowMap
* VSMShadowMap

<br />

위 설정을 추가한 후, 결과를 확인하면 Hard Shadow 와 다른점이 없어 보입니다.

이는 그림자를 생성하는 Light 의 **Blur 정도** 와 **번지는 영역의 Radius** 를 변경하면서 부드러움이 달라지는 것을 확인할 수 있습니다.

```js title="DirectionalLight 의 Blur 와 Radius 설정" showLineNumbers{79} {6-7}
function initDirectionalLight() {
    const color = new Color('#fff');
    const light = new DirectionalLight(color);
    light.position.set(2, 2, 2);
    light.castShadow = true;
    light.shadow.blurSamples = 30;
    light.shadow.radius = 12;

    const helper = new DirectionalLightHelper(light);

    scene.add(light);
    scene.add(helper);
}
```

<img src="/markdownAssets/threejs/2024-01-07-02/2024-01-07-02-02.png" alt="Soft Shadow" />

<br />

Light 의 shadow 설정 시, 주의할 사항은 다음과 같습니다.

* `shadow.blurSamples`: 값이 커질수록 부드러운 그림자를 표현하지만, 필요 성능이 높아집니다.
* `shadow.radius`: 값이 너무 작으면 화면이 깨지는 현상이 있으므로, **10 이상** 설정을 권장합니다.



<br />



## 추가: VSMShadowMap 에 대하여

Soft Shadow 를 표현하기 위해 VSMShadowMaper 을 사용해 보았습니다.

VSMShadowMap 은 곡선에 대한 그림자를 부드럽게 표현할 수 있는 특징을 가졌습니다.

그래서 지금까지 실습했던 Shpere Mesh 의 그림자를 부드럽게 표현할 수 있었습니다.

<br />

만약 Sphere Mesh 가 아닌 Box Mesh 에 VSMShadowMap 을 적용한다면, 그림자가 드리우지 않아야 하는 영역까지 침범하는 현상을 볼 수 있습니다.

이는 VSMShadowMap 의 Blur 처리가 되면서 번지는 그림자가 렌더링된 결과 입니다.

<br />

화면 구성에 Box Mesh 가 많다면, VSMShadowMap 을 사용했을 때 오히려 지저분한 그림자가 만들어질 수 있다는 점을 고려하여 선택해야 합니다.

<img src="/markdownAssets/threejs/2024-01-07-02/2024-01-07-02-03.png" alt="VSMShadow 단점" />



<br />



## 마치며

그림자는 조명과 물제의 상호연산을 사용하기 때문에 연산량이 많이 필요하다고 합니다.

그래서 그림자를 최소한으로 사용할 수 있도록 여러가지 설정을 분리시켜놓은 느낌이 들었습니다.

Three.js 를 활용할 때, 그림자 설정이 성능 최적화 대상이라는 것을 알게 되었습니다.
20:T1a79,---
id: 4
title: 평평한 바닥(땅) 만들기 (Plane Mesh)
description: '바닥을 표현하기 위해 Plane Mesh 를 생성합니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'threejs',
    'javascript',
    '3d',
    'plane',
]

createdAt: '2024-01-07 23:20:00'
modifiedHistories: []
---

# 평평한 바닥(땅) 만들기 (Plane Mesh)

이번 포스팅에서는 바닥(땅) 을 만들어 보겠습니다.

Three.js 에서는 바닥(땅) 을 **Plane Mesh** 로 만들 수 있습니다.

다음 포스팅에서 다룰 그림자를 표현하려면, 바닥(땅) 이 있어야 하므로 별도의 포스팅으로 분리하게 되었습니다.



<br />



## 예시 코드

이번 포스팅에서 사용할 예시 코드는 다음과 같습니다.

```js title="예시 코드" showLineNumbers {96}
import {
    WebGLRenderer,
    Scene,
    PerspectiveCamera,

    Mesh,
    MeshStandardMaterial,
    SphereGeometry,

    Color,
    HemisphereLight,
    HemisphereLightHelper,
    DirectionalLight,
    DirectionalLightHelper,
} from 'three';
import {
    OrbitControls,
} from 'three/examples/jsm/controls/OrbitControls';
import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { Scene } */
let scene;

/** @type { PerspectiveCamera } */
let camera;

/** @type { OrbitControls } */
let controls;

function initCanvas() {
    const $canvas = document.createElement('canvas');
    $canvas.width = window.innerWidth;
    $canvas.height = window.innerHeight;

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    return $canvas;
}

function initScene() {
    scene = new Scene();
}

function initCamera() {
    camera = new PerspectiveCamera();
    camera.fov = 35;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.position.set(0, 0, 12);

    camera.updateProjectionMatrix();
}

function initControls($canvas) {
    controls = new OrbitControls(camera, $canvas);
    controls.enableDamping = true;
}

function initHemisphereLight() {
    const skyColor = new Color('#fff');
    const groundColor = new Color('#000');
    const light = new HemisphereLight(
        skyColor,
        groundColor,
        0.75
    );

    const helper = new HemisphereLightHelper(light);

    scene.add(light);
    scene.add(helper);
}

function initDirectionalLight() {
    const color = new Color('#fff');
    const light = new DirectionalLight(color);
    light.position.set(2, 2, 2);

    const helper = new DirectionalLightHelper(light);

    scene.add(light);
    scene.add(helper);
}

function initSphereMesh() {
    const geometry = new SphereGeometry();
    const material = new MeshStandardMaterial();
    const sphere = new Mesh(geometry, material);

    scene.add(sphere);
}

// 여기에 Plane Mesh(바닥) 을 생성하는 함수를 구현할 예정입니다.

function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });
}

function render() {
    window.requestAnimationFrame(render);

    renderer.render(scene, camera);
    controls.update();
}

(function init() {
    const $canvas = initCanvas();
    initRenderer($canvas);
    initScene();
    initCamera();
    initControls($canvas);

    initHemisphereLight();
    initDirectionalLight();

    initSphereMesh();

    render();
}());
```



<br />



## Plane Mesh 생성 함수 만들기

Plane Mesh 는 **PlaneGeometry** class 를 사용하여 생성할 수 있습니다.

```js title="PlaneGeometry class import 하기" showLineNumbers {9}
import {
    WebGLRenderer,
    Scene,
    PerspectiveCamera,

    Mesh,
    MeshStandardMaterial,
    SphereGeometry,
    PlaneGeometry,

    Color,
    HemisphereLight,
    HemisphereLightHelper,
    DirectionalLight,
    DirectionalLightHelper,
} from 'three';
```

```js title="initPlaneMesh() 함수 구현하기" showLineNumbers{97}
function initPlaneMesh() {
    const geometry = new PlaneGeometry();
    const material = new MeshStandardMaterial();
    const plane = new Mesh(geometry, material);
    plane.position.set(0, -1, 0);

    scene.add(plane);
}
```

```js title="initPlaneMesh 함수 호출하기" showLineNumbers{120} {12}
(function init() {
    const $canvas = initCanvas();
    initRenderer($canvas);
    initScene();
    initCamera();
    initControls($canvas);

    initHemisphereLight();
    initDirectionalLight();

    initSphereMesh();
    initPlaneMesh();

    render();
}());
```

<img src="/markdownAssets/threejs/2024-01-07-01/2024-01-07-01-01.png" alt="PlaneMesh" />



<br />



## Plane Mesh 회전 및 크기 변경하기

위 코드를 실행하면, Sphere 하부에 사각형 물체가 렌더링됩니다.

**width**, **height**, **rotation** 을 변경하여 바닥(땅) 처럼 보이도록 설정해 보겠습니다.

```js title="initPlaneMesh() 함수 구현하기" showLineNumbers{97} {2, 6-10}
function initPlaneMesh() {
    const geometry = new PlaneGeometry(5, 5);
    const material = new MeshStandardMaterial();
    const plane = new Mesh(geometry, material);
    plane.position.set(0, -1, 0);
    plane.rotation.set(
        Math.PI * -0.5, 
        0, 
        0
    );

    scene.add(plane);
}
```

<br />

PlaneGeometry class 는 생성자에 **width** 와 **height** 를 넘겨주어 크기를 설정할 수 있습니다.

```js title="width, height 설정" showLineNumbers{98}
const geometry = new PlaneGeometry(5, 5);
```

<br />

그리고 Plane Mesh 인스턴스의 `rotation.set()` 메소드를 사용하여 회전시킬 수 있습니다.

회전시킬 값은 **Radian** 으로 넘겨주어야 하므로, **Math.PI** 를 사용합니다.

```js title="회전 시키기" showLineNumbers{102} {2}
plane.rotation.set(
    Math.PI * -0.5, 
    0, 
    0
);
```

위 코드에서 X축 회전으로 `Math.PI * -0.5` 를 주었는데, 이는 아래와 같은 Plane Mesh 의 특성으로 고려한 것입니다.

* Plane Mesh 는 한쪽면만 렌더링되는 단면 물체 입니다.
* 렌더링되지 않는 반대쪽 면에는 그림자가 드리우지 않습니다.

<br />

이렇게 실행한 결과는 다음과 같습니다.

<img src="/markdownAssets/threejs/2024-01-07-01/2024-01-07-01-02.png" alt="PlaneMesh 설정" />

<br />

카메라를 회전시켜서 Plane Mesh 의 반대쪽 면을 보면, 렌더링되지 않은 결과를 볼 수 있습니다.

<img src="/markdownAssets/threejs/2024-01-07-01/2024-01-07-01-03.png" alt="PlaneMesh 반대면" />



## 마치며

Plane Mesh 를 생성하여 바닥(땅) 을 만들 수 있게 되었습니다.

다음 포스팅에서는 바닥(땅) 에 그림자를 표현하여, 조명과 물체의 자연스러운 연출 방법을 정리해 보겠습니다.
21:T2eef,---
id: 3
title: 조명 종류와 설정
description: '조명 종류와 설정 방법에 대해 정리합니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'threejs',
    'javascript',
    '3d',
    'light',
]

createdAt: '2024-01-06 23:00:00'
modifiedHistories: []
---

# 조명 종류와 설정

Three.js 는 조명이 없으면 검은 화면만 보이게 됩니다.

이번 포스팅에서는 조명의 종류와 특징, 설정 방법에 대해 정리하고자 합니다.



<br />



## 조명 종류

조명의 종류는 다음과 같습니다.

* DirectionalLight
* PointLight
* AmbientLight
* HemisphereLight

그리고 개발환경에서 조명의 광원 위치를 파악하기 쉽게 도와주는 **Helper class** 가 있습니다.

자세한 사항은 각 조명과 함께 정리하겠습니다.



<br />



## 예시 코드

이번 포스팅에서 사용할 예시 코드는 다음과 같습니다.

```js title="예시 코드" showLineNumbers {94}
import {
    WebGLRenderer,
    Scene,
    PerspectiveCamera,

    SphereGeometry,
    MeshStandardMaterial,
    Mesh,

    Color,

    DirectionalLight,
    DirectionalLightHelper,
} from 'three';
import './style.css';
import {
    OrbitControls,
} from 'three/examples/jsm/controls/OrbitControls';

/** @type { WebGLRenderer } */
let renderer;

/** @type { Scene } */
let scene;

/** @type { PerspectiveCamera } */
let camera;

/** @type { OrbitControls } */
let controls;

function initCanvas() {
    const $canvas = document.createElement('canvas');
    $canvas.width = window.innerWidth;
    $canvas.height = window.innerHeight;

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    return $canvas;
}

function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });
}

function initScene() {
    scene = new Scene();
}

function initCamera() {
    camera = new PerspectiveCamera();
    camera.fov = 35;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.position.set(0, 0, 10);

    camera.updateProjectionMatrix();
}

function initControls($canvas) {
    controls = new OrbitControls(camera, $canvas);
    controls.enableDamping = true;
}

function createSphere() {
    const geometry = new SphereGeometry();
    const material = new MeshStandardMaterial();
    const sphere = new Mesh(geometry, material);

    return sphere;
}

function render() {
    requestAnimationFrame(render);

    renderer.render(scene, camera);
    controls.update();
}

function init() {
    const $canvas = initCanvas();

    initRenderer($canvas);
    initScene();
    initCamera();
    initControls($canvas);

    const sphere = createSphere();
    scene.add(sphere);

    // 여기에서 `조명 설정` 함수를 호출하며 실습할 예정입니다.

    render();
}

init();
```



<br />



## DirectionalLight

DirectionalLight 는 **광원** 에서 **특정 지점(lookAt(좌표))** 로 비추는 **단방향 조명** 입니다.

물체에 비추는 빛의 양은 광원과의 거리와 무관한 빛의 세기(intensity) 설정값이 적용됩니다.

<br />

```js title="DirectionalLight import 하기" showLineNumbers
import {
    DirectionalLight,
} from 'three';
```

```js title="DirectionalLight" showLineNumbers{83} {9, 14-18}
function init() {
    initRenderer(initCanvas());
    initCamera();
    initScene();

    const sphere = createSphere();
    scene.add(sphere);

    initDirectionalLight();

    render();
}

function initDirectionalLight() {
    const light = new DirectionalLight();
    light.position.set(1, 1, 1);
    scene.add(light);
}

init();
```

<br />

DirectionalLight 생성자에 인자로 **Color 객체** 를 넘겨주어 빛의 색상을 변경할 수 있습니다.

**Color** 는 Three.js 에서 제공하는 class 이며, Three.js 의 색상관련 설정은 **Color 인스턴스** 를 받습니다.

```js title="Color import 하기" showLineNumbers
import {
    Color,
} from 'three';
```

```js title="DirectionalLight 색상 설정하기" showLineNumbers{83} {15}
function init() {
    initRenderer(initCanvas());
    initCamera();
    initScene();

    const sphere = createSphere();
    scene.add(sphere);

    initDirectionalLight();

    render();
}

function initDirectionalLight() {
    const color = new Color('#f0f400');
    const light = new DirectionalLight(color);
    light.position.set(1, 1, 1);

    scene.add(light);
}

init();
```

<img src="/markdownAssets/threejs/2024-01-06-01/2024-01-06-01-01.png" alt="DirectionalLight" />



<br />



### DirectionalLightHelper

DirectionalLight 의 광원을 표기해주는 기능을 사용해 보겠습니다.

DirectionalLightHelper 인스턴스를 생성한 후, `scene.add()` 를 사용하여 등록해 줍니다.

```js title="DirectionalLightHelper import 하기" showLineNumbers {3}
import {
    DirectionalLight,
    DirectionalLightHelper,
} from 'three';
```

```js title="DirectionalLight 색상 설정하기" showLineNumbers{83} {20-21}
function init() {
    initRenderer(initCanvas());
    initCamera();
    initScene();

    const sphere = createSphere();
    scene.add(sphere);

    initDirectionalLight();

    render();
}

function initDirectionalLight() {
    const color = new Color('#f0f400');
    const light = new DirectionalLight(color);
    light.position.set(1, 1, 1);
    scene.add(light);

    const helper = new DirectionalLightHelper(light);
    scene.add(helper);
}

init();
```

<img src="/markdownAssets/threejs/2024-01-06-01/2024-01-06-01-02.png" alt="DirectionalLightHelper" />



<br />



## 빛의 세기(intensity) 설정하기

조명은 빛의 세기(intensity) 가 있습니다.

Three.js 의 모든 조명에도 빛의 세기(intensity) 를 설정할 수 있습니다.

빛의 세기 값은 **0 ~ 1** 값으로 설정합니다.

아래 코드는 DirectionalLight 에 빛의 세기(intensity) 를 0.75 로 설정하고 있습니다.

```js title="DirectionalLight 색상 설정하기" showLineNumbers{83} {18}
function init() {
    initRenderer(initCanvas());
    initCamera();
    initScene();

    const sphere = createSphere();
    scene.add(sphere);

    initDirectionalLight();

    render();
}

function initDirectionalLight() {
    const color = new Color('#f0f400');
    const light = new DirectionalLight(
        color, 
        0.75
    );
    light.position.set(1, 1, 1);
    scene.add(light);

    const helper = new DirectionalLightHelper(light);
    scene.add(helper);
}

init();
```



<br />



## PointLight

전등처럼 한 점에서 빛을 방사하는 조명 입니다.

사용방법은 다음과 같습니다.

```js title="PointLight import 하기" showLineNumbers
import {
    PointLight,
    PointLightHelper,
} from 'three';
```

```js title="PointLight 색상 설정하기" showLineNumbers{83} {9, 14-25}
function init() {
    initRenderer(initCanvas());
    initCamera();
    initScene();

    const sphere = createSphere();
    scene.add(sphere);

    initPointLight();

    render();
}

function initPointLight() {
    const color = new Color('#f0f400');
    const light = new PointLight(
        color,
        0.75 // 빛의 세기(intensity)
    );
    light.position.set(1, 1, 1);
    scene.add(light);

    const helper = new PointLightHelper(light);
    scene.add(helper);
}

init();
```

<img src="/markdownAssets/threejs/2024-01-06-01/2024-01-06-01-03.png" alt="PointLight" />



<br />



## AmbientLight

Ambient 는 `주변` 이라는 뜻을 가지고 있습니다.

AmbientLight 는 특정한 광원이 없고, 모든 영역에 동일하게 비추는 조명입니다.

즉 `(x, y, z)` 에 관계없이 동일한 빛을 비춥니다.

<br />

AmbientLight 가 적용된 결과를 확인하기 위해, PointLight 와 함께 사용해 보겠습니다.

```js title="PointLight import 하기" showLineNumbers {5}
import {
    PointLight,
    PointLightHelper,

    AmbientLight,
} from 'three';
```

```js title="PointLight 색상 설정하기" showLineNumbers{83} {10, 28-35}
function init() {
    initRenderer(initCanvas());
    initCamera();
    initScene();

    const sphere = createSphere();
    scene.add(sphere);

    initPointLight();
    initAmbientLight();

    render();
}

function initPointLight() {
    const color = new Color('#f0f400');
    const light = new PointLight(
        color,
        0.75 // 빛의 세기(intensity)
    );
    light.position.set(1, 1, 1);
    scene.add(light);

    const helper = new PointLightHelper(light);
    scene.add(helper);
}

function initAmbientLight() {
    const color = new Color('#fff');
    const light = new AmbientLight(
        color,
        0.25, // 빛의 세기(intensity)
    );
    scene.add(light);
}

init();
```

<img src="/markdownAssets/threejs/2024-01-06-01/2024-01-06-01-04.png" alt="AmbientLight" />

<br />

그리고 AmbientLight 는 모든 영역에 비추는 조명이므로, **Helper class 가 없다는 특징** 이 있습니다.



<br />



## HemisphereLight

HemisphereLight 는 위쪽(skyColor) 와 아래쪽(groundColor) 를 인자로 받고, 그라데이션으로 비추는 조명입니다.

일반적으로 기본 조명으로 사용하는데, 이는 Three.js 특성 때문입니다.

* 조명이 없으면, 물체(Mesh) 는 보이지 않는 검은 화면만 렌더링 됩니다.
* 다른 조명에 의해 생기는 그림자를 좀 더 자연스럽고 부드럽게 만들어줍니다.

<br />

아래 코드는 HemisphereLight 와 DirectionalLight 를 조합한 예시 입니다.

```js title="PointLight import 하기" showLineNumbers {5-6}
import {
    DirectionalLight,
    DirectionalLightHelper,

    HemisphereLight,
    HemisphereLightHelper,
} from 'three';
```

```js title="PointLight 색상 설정하기" showLineNumbers{83} {10, 28-40}
function init() {
    initRenderer(initCanvas());
    initCamera();
    initScene();

    const sphere = createSphere();
    scene.add(sphere);

    initDirectionalLight();
    initHemisphereLight();

    render();
}

function initDirectionalLight() {
    const color = new Color('#fff');
    const light = new DirectionalLight(
        color,
        0.75 // 빛의 세기(intensity)
    );
    light.position.set(1, 1, 1);
    scene.add(light);

    const helper = new PointLightHelper(light);
    scene.add(helper);
}

function initHemisphereLight() {
    const skyColor = new Color('#fff');
    const groundColor = new Color('#000');
    const light = new HemisphereLight(
        skyColor,
        groundColor,
        0.25, // 빛의 세기(intensity)
    );
    scene.add(light);

    const helper = new HemisphereLightHelper(light);
    scene.add(helper);
}

init();
```

<img src="/markdownAssets/threejs/2024-01-06-01/2024-01-06-01-05.png" alt="Hemisphere" />



<br />



## 마치며

일반적으로 DirectionalLight 와 HemisphereLight 를 조합하여 기본 조명을 구성합니다.

각 설정은 다음과 같습니다.

```js title="일반적인 조명 설정" showLineNumbers
function initDirectionalLight() {
    const color = new Color('#fff');
    const light = new DirectionalLight(
        color,
        0.75 // HemispherLight 보다 0.5 강하게 설정합니다.
    );
    scene.add(light);
}

function initHemisphereLight() {
    const skyColor = new Color('#fff');
    const groundColor = new Color('#000');
    const light = new HemisphereLight(
        skyColor,
        groundColor,
        0.25 // DirectionalLight 보다 0.5 약하게 설정합니다.
    );
    scene.add(light);
}
```

<br />

HemisphereLight 를 사용하므로써 그림자 부분이 검은색으로 보이지 않도록 해주며, 좀 더 자연스러운 조명을 연출할 수 있습니다.

그리고 PointLight 는 특정 물체를 강조하거나 효과를 주기위해 주로 사용합니다.

<br />

Three.js 는 개발 능력뿐만 아니라 사물을 표현하는 예술 능력도 필요하겠다는 느낌이 듭니다. 😱
22:T3ac1,---
id: 2
title: 카메라 설정 (PerspectiveCamera)
description: 'Three.js 의 카메라인 PerspectiveCamera 설정에 대한 포스팅입니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'threejs',
    'javascript',
    '3d',
    'camera',
]

createdAt: '2024-01-01 23:50:00'
modifiedHistories: []
---

# 카메라 설정 (PerspectiveCamera)

Three.js 가 `<canvas />` 에 실제로 렌더링하는 부분은 `카메라 (PerspectiveCamera)` 가 비추는 영역입니다.

이번 포스팅에서는 카메라 설정과 효과, 사용자 인터렉션 적용 방법에 대해 정리해 보겠습니다.

이번 포스팅에서는 아래의 코드를 시작점으로 사용하겠습니다.

```js title="샘플 코드" showLineNumbers
import {
    WebGLRenderer,
    PerspectiveCamera,
    Scene,
    DirectionalLight,

    BoxGeometry,
    MeshPhongMaterial,
    Mesh,
} from 'three';
import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

/** @type { Scene } */
let scene;

(function init() {
    const $canvas = initCanvas();

    initRenderer($canvas);

    const light = createLight();
    const boxMesh = createBoxMesh();

    initCamera();
    initScene(light, boxMesh);

    render();

    console.log('시작');
}());

function render() {
    renderer.render(scene, camera);

    window.requestAnimationFrame(render);
}

function initCanvas() {
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    return $canvas;
}

/**
 * @param { HTMLCanvasElement } $canvas 
 */
function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });

    renderer.setSize(
        window.innerWidth,
        window.innerHeight
    );
}

function createLight() {
    const light = new DirectionalLight();
    light.position.set(1, 2, 3);

    return light;
}

function createBoxMesh() {
    const boxGeometry = new BoxGeometry();
    const boxMaterial = new MeshPhongMaterial();

    return new Mesh(boxGeometry, boxMaterial);
}

function initCamera() {
    camera = new PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight
    );

    camera.position.set(0, 0, 5);
}

function initScene(...items) {
    scene = new Scene();

    items.forEach(item => {
        scene.add(item);
    });
}
```



<br />



## PerspectiveCamera 생성자 params

카메라 생성자 params 를 사용하여 초기 설정을 할 수 있습니다.

```ts title="PerspectiveCamera 생성자 함수" showLineNumbers
class PerspectiveCamera {
    constructor(
        fov?: number,
        aspect?: number,
        near?: number,
        far?: number
    );
}
```

* fov (Field of View): 시야각 (화각)
    * fov 설정값이 클수록 먼 거리에서 보는 느낌이 납니다.
    * fov 설정값이 커질수록 **투시에 따른 왜곡현상** 이 도드라지게 나타납니다.
* aspect: 카메라 종횡비 (aspect radio)
    * 카메라의 가로, 세로 비율값 입니다.
* near: (Near clipping)
    * 카메라를 기준으로 가까운 물체(Mesh) 에 대한 렌더링 잘라내기 설정값 입니다.
* far: (Far clipping)
    * 카메라를 기준으로 먼 물체(Mesh) 에 대한 렌더링 잘라내기 설정값 입니다.

<br />

위 설정들은 PerspectiveCamera 생성자를 통해서도 설정할 수 있고, 객체를 생성한 후 설정을 변경할 수도 있습니다.

만약 객체를 생성한 후 설정을 변경한다면, 카메라 메소드인 **updateProjectionMatrix()** 함수를 호출하여야 실제 렌더링에 반영됩니다.

아래 코드는 PerspectiveCamera 객체를 생성한 후, 카메라 설정을 변경하고 있습니다.

```js title="카메라 객체 설정값 변경하기" showLineNumbers {88, 89, 92}
import {
    WebGLRenderer,
    PerspectiveCamera,
    Scene,
    DirectionalLight,

    BoxGeometry,
    MeshPhongMaterial,
    Mesh,
} from 'three';
import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

/** @type { Scene } */
let scene;

(function init() {
    const $canvas = initCanvas();

    initRenderer($canvas);

    const light = createLight();
    const boxMesh = createBoxMesh();

    initCamera();
    initScene(light, boxMesh);

    render();

    console.log('시작');
}());

function render() {
    renderer.render(scene, camera);

    window.requestAnimationFrame(render);
}

function initCanvas() {
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    return $canvas;
}

/**
 * @param { HTMLCanvasElement } $canvas 
 */
function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });

    renderer.setSize(
        window.innerWidth,
        window.innerHeight
    );
}

function createLight() {
    const light = new DirectionalLight();
    light.position.set(1, 2, 3);

    return light;
}

function createBoxMesh() {
    const boxGeometry = new BoxGeometry();
    const boxMaterial = new MeshPhongMaterial();

    return new Mesh(boxGeometry, boxMaterial);
}

function initCamera() {
    camera = new PerspectiveCamera(
        // 45,
        // window.innerWidth / window.innerHeight
    );

    camera.fov = 45;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.position.set(0, 0, 3);

    camera.updateProjectionMatrix();
}

function initScene(...items) {
    scene = new Scene();

    items.forEach(item => {
        scene.add(item);
    });
}
```

<br />

위 코드의 실행 결과로 BoxMesh 의 단면을 볼 수 있습니다.

<img src="/markdownAssets/threejs/2024-01-01-01/2024-01-01-01-01.png" alt="실행 결과" />



<br />



## 카메라의 주시 좌표값 변경하기

현재는 BoxMesh 의 단면만을 비추고 있어서 마치 2D 인것 처럼 보입니다.

카메라의 위치와 카메라의 주시 좌표값을 변경하면, 물체를 다각도에서 다양한 구도로 렌더링할 수 있습니다.

<br />

먼저 카메라의 위치를 (1, 1, 2) 로 변경해 보겠습니다.

```js title="카메라 position 변경" showLineNumbers{82} {6}
function initCamera() {
    camera = new PerspectiveCamera();

    camera.fov = 45;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.position.set(1, 1, 2);

    camera.updateProjectionMatrix();
}
```

<img src="/markdownAssets/threejs/2024-01-01-01/2024-01-01-01-02.png" alt="실행 결과" />

<br />

카메라의 position 만을 변경한 결과, BoxMesh 의 일부분만 렌더링되고 있습니다.

이는 카메라의 주시 좌표값을 설정하지 않아서 카메라 위치에서 정면을 주시하고 있기 때문입니다.

카메라 객체의 `lookAt()` 메소드를 사용하면, 카메라의 위치인 position 에서 특정 좌표를 주시하게 됩니다.

BoxMesh 가 카메라의 중앙에 오도록 하기위해, BoxMesh 의 position 위치값인 (0, 0, 0) 으로 카메라 주시 좌표를 설정해 보겠습니다.

```js title="카메라 position 변경" showLineNumbers{82} {8}
function initCamera() {
    camera = new PerspectiveCamera();

    camera.fov = 45;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.position.set(1, 1, 2);

    camera.lookAt(0, 0, 0);

    camera.updateProjectionMatrix();
}
```

<img src="/markdownAssets/threejs/2024-01-01-01/2024-01-01-01-03.png" alt="실행 결과" />



<br />



## 카메라 fov 와 position 설정에 따른 왜곡 현상

fov(Field of View) 값이 커질수록 멀리서 보는 느낌으로 렌더링됩니다.

이는 물체가 더 작게 보이는 결과를 볼 수 있습니다.

<br />

만약 fov 를 큰 값으로 설정하여 물체가 작게 보이도록 한 후, 카메라의 위치를 물체와 가깝게 설정하면 어떻게 될까요?

이는 카메라의 **왜곡 현상** 에 의해 좀 더 렌즈의 굴곡이 커지게 됩니다.

fov 와 position 의 관계를 표현해 보면 다음과 같습니다.

* fov 작게 설정, position 멀리 설정
    * 왜곡 현상이 적어집니다.
* fov 크게 설정, position 가깝게 설정
    * 왜곡 현상이 커집니다.

<br />

실제 왜곡 현상의 차이를 확인하기 위해 두가지 설정을 비교해 보겠습니다.

* 첫번째 설정: **fov 작게, position 멀리** 설정
* 두번째 설정: **fov 크게, position 가깝게** 설정

```js title="fov 작게, position 멀리 설정" showLineNumbers{82} {5-6}
function initCamera() {
    camera = new PerspectiveCamera();

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.fov = 45;
    camera.position.set(2, 2, 2);

    camera.lookAt(0, 0, 0);

    camera.updateProjectionMatrix();
}
```

<img src="/markdownAssets/threejs/2024-01-01-01/2024-01-01-01-04.png" alt="실행 결과" />

<br /><br />

```js title="fov 크게, position 가깝게 설정" showLineNumbers{82} {5-6}
function initCamera() {
    camera = new PerspectiveCamera();

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.fov = 90;
    camera.position.set(1, 1, 1);

    camera.lookAt(0, 0, 0);

    camera.updateProjectionMatrix();
}
```

<img src="/markdownAssets/threejs/2024-01-01-01/2024-01-01-01-05.png" alt="실행 결과" />



<br />



## 추가: 마우스를 사용하여 카메라 제어하기

Three.js 는 여러가지 Addons 를 제공합니다.

이 중 **OrbitControls** 객체를 사용하면, 마우스를 사용하여 카메라를 제어하는 기능을 제공할 수 있습니다.

<br />

OrbitControls 는 **PerspectiveCamera 의 Addon** 개념으로 사용하게 되며, 카메라의 제어를 담당하게 됩니다.

주의할 점은 PerspectiveCamera 의 `lookAt()` 메소드를 함께 사용하게 되면, 카메라 제어에 충돌이 발생하는 현상입니다.

그러므로 OrbitControls 를 사용하려면, `lookAt()` 메소드는 꼭 제거해 주는 것이 좋습니다.

<br />

먼저 OrbitControls 의 생성자를 살펴보면 다음과 같습니다.

```ts
class OrbitControls {
    constructor(
        object: Camera, 
        domElement?: HTMLElement
    );
}
```

* object: 제어할 카메라 객체
* domElement: 마우스 이벤트를 발생시킬 HTMLElement

<br />

PerspectiveCamera 에 OrbitControls 를 적용하는 `initControls()` 함수를 추가해 보겠습니다.

```js title="OrbitControls 로 카메라 제어하기" showLineNumbers {11-13, 25-26, 37, 45, 103-108}
import {
    WebGLRenderer,
    PerspectiveCamera,
    Scene,
    DirectionalLight,

    BoxGeometry,
    MeshPhongMaterial,
    Mesh,
} from 'three';
import {
    OrbitControls,
} from 'three/examples/jsm/controls/OrbitControls'
import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

/** @type { Scene } */
let scene;

/** @type { OrbitControls } */
let controls;

(function init() {
    const $canvas = initCanvas();

    initRenderer($canvas);

    const light = createLight();
    const boxMesh = createBoxMesh();

    initCamera();
    initControls($canvas);
    initScene(light, boxMesh);

    render();
}());

function render() {
    renderer.render(scene, camera);
    controls.update();

    window.requestAnimationFrame(render);
}

function initCanvas() {
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    return $canvas;
}

/**
 * @param { HTMLCanvasElement } $canvas 
 */
function initRenderer($canvas) {
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });

    renderer.setSize(
        window.innerWidth,
        window.innerHeight
    );
}

function createLight() {
    const light = new DirectionalLight();
    light.position.set(1, 2, 3);

    return light;
}

function createBoxMesh() {
    const boxGeometry = new BoxGeometry();
    const boxMaterial = new MeshPhongMaterial();

    return new Mesh(boxGeometry, boxMaterial);
}

function initCamera() {
    camera = new PerspectiveCamera();

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.fov = 45;
    camera.position.set(2, 2, 2);

    camera.fov = 90;
    camera.position.set(1, 1, 1);

    camera.lookAt(0, 0, 0);

    camera.updateProjectionMatrix();
}

/**
 * @param { HTMLElement } $targetElement 
 */
function initControls($targetElement) {
    controls = new OrbitControls(camera, $targetElement);
}

function initScene(...items) {
    scene = new Scene();

    items.forEach(item => {
        scene.add(item);
    });
}
```

<br />

OrbitControls 를 카메라에 설치하게 되면 아래와 같은 마우스 인터렉션을 사용할 수 있습니다.

* 마우스 좌클릭 - 드래그
    * 카메라 주시 좌표를 회전 중심점으로 하여, **드래그 반대 방향으로 카메라를 회전** 시킵니다.
    * 결과적으로 카메라가 고정된 상태에서 **바라보는 물체가 회전** 하게 됩니다.
* 마우스 휠
    * 확대, 축소 동작을 합니다.
* 마우스 우클릭 - 드래그
    * **드래그 반대 방향으로 카메라의 위치를 이동** 시킵니다.
    * 결과적으로 카메라가 고정된 상태에서 **바라보는 물체가 이동** 하게 됩니다.

<br />

OrbitControls 객체의 설정을 사용하여, 특정 마우스 인터렉션의 사용 여부를 설정할 수 있습니다.

이 설정 프로퍼티들은 `enable` 을 접두사로 사용하고 있습니다.

* `enableRotate`: `false` 값을 대입하면, 회전기능을 막습니다.
* `enableZoom`: `false` 값을 대입하면 확대, 축소 기능을 막습니다.
* `enablePan`: `false` 값을 대입하면 이동 기능을 막습니다.

<br />

추가로 `enableDamping` 에 `true` 값을 대입하게 되면, 카메라의 모든 인터렉션에 감속도가 적용되어 **카메라의 부드러운 움직임이 연출** 됩니다.



<br />



## 마치며

일전에 HTML Canvas API 를 스터디하면서, 도형에 대한 인터렉션이나 애니메이션을 구현해본 적이 있습니다.

물체의 튕김이나 가속도, 감속도를 구현해 보려는 시도를 했었지만, 제가 구현한 결과물은 너무나 어색했습니다.

Three.js 의 인터렉션은 OrbitControls 하나를 접했을 뿐인데, 부드러운 3D 엔진에 그저 놀라울 뿐입니다.

<br />

하지만 실제 구현할 기획에 따라 엔진의 물리 효과를 커스터마이징을 할 수 있어야 자연스러운 결과물이 나올 것 같습니다.

OrbitControls 가 제공하는 효과는 마치 물속의 부력이 작용하는 것처럼 느껴졌습니다.

Three.js 의 기본 사용법과 원리를 이해한 후, 물리 엔진 커스터마이징에 대해서도 도전해 보고 싶어졌습니다.
23:T5077,---
id: 1
title: Three.js 설치 및 실행
description: 'Three.js 를 사용하기 위한 설치와 첫번째 화면을 그려봅니다.'
thumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg

featured: false
tags: [
    'threejs',
    'javascript',
    '3d',
]

createdAt: '2023-12-31 22:47:00'
modifiedHistories: []
---

# Three.js 설치 및 실행

일반적인 웹페이지는 2D 기반으로 구현합니다.

이러한 웹페이지는 서비스를 제공하거나 정보 공유를 목적으로 충분합니다.

만약 이렇게 보편적으로 사용하는 2D 웹페이지에 3D 환경을 더한다면, 서비스나 제품의 브렌딩에 차별점을 줄 수 있을 것 같습니다.

<br />

Three.js 를 스터디하며, 이 블로그의 Profile 페이지를 구현하는 것을 첫번째 목표로 하여 포스팅을 해보려 합니다.



<br />



## Vite 프로젝트 생성하기

Three.js 를 사용하기 위해, VanillaJS 환경의 프로젝트를 생성해 보겠습니다.

Webpack 을 사용하여 프로젝트를 만들어도 되지만, 프로젝트 구성에 투자되는 리소스가 많아지므로, Vite 를 사용하여 프로젝트를 생성해보겠습니다.

```bash title="Vite 프로젝트 생성"
yarn create vite --template vanilla my-threejs

cd my-threejs

yarn install
```



<br />



## Three.js 설치하기

프로젝트를 생성한 후, Three.js 를 설치합니다.

```bash title="Three.js 설치"
yarn install three
```



<br />



## Three.js 기본 구조 구성하기

Three.js 는 **WebGL** 을 기반으로 동작합니다.

이는 **HTML Canvas API** 를 사용하여 그리는 방식입니다.

Three.js 로 화면을 그리기 위한 기본 과정을 살펴보면 다음과 같습니다.

1. `<canvas />` 태그 생성
2. **WebGLRenderer** 객체 생성
3. 카메라 생성
4. 조명 생성
5. **Scene** 객체 생성
6. 위에서 생성한 객체들을 조합하여 **WebGLRenderer** 에 적용
7. `requestAnimationFrame()` 을 사용하여 `<canvas />` 렌더링

<br />

위 과정은 아래와 같이 함수를 생성하여 구현해 보겠습니다.

1. `init()` 함수 만들기: 1번 ~ 6번 과정을 처리합니다.
2. `render()` 함수 만들기: 7번 과정을 처리합니다.



<br />



## 1. `<canvas />` 태그 생성

먼저 Three.js 를 렌더링할 `<canvas />` 태그를 생성하는 로직을 구현해 보겠습니다.

```js title="main.js" showLineNumber
function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);
}

init();
```



<br />



## 2. **WebGLRenderer** 객체 생성

**WebGLRenderer** 객체는 Three.js 의 코어 역할을 합니다.

위에서 생성한 `<canvas />` 를 인자로 넘겨주어 렌더링 대상을 지정해 줍니다.

```js title="main.js" showLineNumbers {2, 5-6, 15-18}
import {
    WebGLRenderer,
} from 'three';

/** @type { WebGLRenderer } */
let renderer;

function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    // 2. WebGLRenderer 객체 생성
    renderer = new WebGLRenderer({
        canvas: $canvas,
    });
}

init();
```



<br />



## 3. 카메라 생성

Three.js 가 실제로 화면에 렌더링하는 것은 `Camera` 가 비추는 곳이 됩니다.

따라서 Three.js 에 사용할 카메라 객체를 생성해 줍니다.

```js title="main.js" showLineNumbers {3, 9-10, 24-25}
import {
    WebGLRenderer,
    PerspectiveCamera,
} from 'three';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    // 2. `WebGLRenderer` 객체 생성
    renderer = new WebGLRenderer({
        canvas: $canvas,
    });

    // 3. 카메라 생성
    camera = new PerspectiveCamera();
}

init();
```



<br />



## 4. 조명 생성

이번에는 조명 객체인 **DirectionalLight** 객체를 생성해 보겠습니다.

현실 세계에서도 빛이 있어야 물체를 볼 수 있듯이, Three.js 에서도 조명이 있어야 물체가 렌더링 됩니다.

조명은 여러가지가 있는데, 이 중 햇빛처럼 직선의 일정한 양의 빛을 나타내는 **DirectionalLight** 객체를 사용해 보겠습니다.

```js title="main.js" showLineNumbers {4, 28-29}
import {
    WebGLRenderer,
    PerspectiveCamera,
    DirectionalLight,
} from 'three';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    // 2. `WebGLRenderer` 객체 생성
    renderer = new WebGLRenderer({
        canvas: $canvas,
    });

    // 3. 카메라 생성
    camera = new PerspectiveCamera();

    // 4. 조명 생성
    const light = new DirectionalLight();
}

init();
```



<br />



## 5. **Scene** 객체 생성

무대는 `Scene` 객체로 만들 수 있습니다.

`Scene` 객체는 `add()` 메서드를 사용하여 위에서 만들었던 조명과 물체(Mesh)들을 적용할 수 있습니다.

<br />

`Scene` 객체를 생성하고 조명을 적용해 보겠습니다.

```js title="main.js" showLineNumbers {5, 14-15, 35-37}
import {
    WebGLRenderer,
    PerspectiveCamera,
    DirectionalLight,
    Scene,
} from 'three';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

/** @type { Scene } */
let scene;

function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    // 2. `WebGLRenderer` 객체 생성
    renderer = new WebGLRenderer({
        canvas: $canvas,
    });

    // 3. 카메라 생성
    camera = new PerspectiveCamera();

    // 4. 조명 생성
    const light = new DirectionalLight();

    // 5. `Scene` 객체 생성
    scene = new Scene();
    scene.add(light);
}

init();
```



<br />



## 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용

이제 Three.js 를 실행하여 화면을 그릴 준비가 되었습니다.

**WebGLRenderer** 는 **Scene(무대)** 와 **카메라** 를 사용하여 화면을 그리는 역할을 하게 됩니다.

```js title="main.js" showLineNumbers {39-40}
import {
    WebGLRenderer,
    PerspectiveCamera,
    DirectionalLight,
    Scene,
} from 'three';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

/** @type { Scene } */
let scene;

function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    // 2. `WebGLRenderer` 객체 생성
    renderer = new WebGLRenderer({
        canvas: $canvas,
    });

    // 3. 카메라 생성
    camera = new PerspectiveCamera();

    // 4. 조명 생성
    const light = new DirectionalLight();

    // 5. `Scene` 객체 생성
    scene = new Scene();
    scene.add(light);

    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용
    renderer.render(scene, camera);
}

init();
```



<br />



## 7. `requestAnimationFrame()` 을 사용하여 `<canvas />` 렌더링

이번에는 `init()` 의 마지막에 호출할 `render()` 함수를 만들고, Three.js 를 실행하여 브라우저에서 결과를 확인해 보겠습니다.

추가할 `render()` 함수는 `requestAnimationFrame()` 을 사용하여 `render()` 함수를 재귀 호출하도록 하는데, 이는 브라우저에서 **60fps 로 실행하며 화면을 업데이트** 하게 됩니다.

```js title="main.js" showLineNumbers {42-43, 46-50}
import {
    WebGLRenderer,
    PerspectiveCamera,
    DirectionalLight,
    Scene,
} from 'three';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

/** @type { Scene } */
let scene;

function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    // 2. `WebGLRenderer` 객체 생성
    renderer = new WebGLRenderer({
        canvas: $canvas,
    });

    // 3. 카메라 생성
    camera = new PerspectiveCamera();

    // 4. 조명 생성
    const light = new DirectionalLight();

    // 5. `Scene` 객체 생성
    scene = new Scene();
    scene.add(light);

    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용
    renderer.render(scene, camera);

    // 7. requestAnimationFrame() 을 사용하여 <canvas /> 렌더링
    render();
}

function render() {
    renderer.render(scene, camera);

    requestAnimationFrame(render);
}

init();
```



<br />



## 추가: Scene 에 SphereMesh 추가하기

지금까지 작성한 코드를 실행하면, 검은색 화면만 보이게 됩니다.

이는 실제로 화면에 그릴 물체(Mesh) 가 없기 때문에 그릴 대상이 없는 현상입니다.

<br />

위에서 구성한 Three.js 가 잘 동작하는지 테스트를 위해 구형 물체(Sphere Mesh) 를 생성하고, 적용해 보겠습니다.

```js title="main.js" showLineNumbers {7-9, 48-49, 61-67}
import {
    WebGLRenderer,
    PerspectiveCamera,
    DirectionalLight,
    Scene,

    SphereGeometry,
    MeshPhongMaterial,
    Mesh,
} from 'three';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

/** @type { Scene } */
let scene;

function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    // 2. `WebGLRenderer` 객체 생성
    renderer = new WebGLRenderer({
        canvas: $canvas,
    });

    // 3. 카메라 생성
    camera = new PerspectiveCamera();
    camera.position.set(0, 0, 10);

    // 4. 조명 생성
    const light = new DirectionalLight();
    light.position.set(1, 1, 1);

    // 5. `Scene` 객체 생성
    scene = new Scene();
    scene.add(light);

    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용
    renderer.render(scene, camera);

    // 추가: Schene 에 SphereMesh 추가하기
    createSphereMesh();

    // 7. requestAnimationFrame() 을 사용하여 <canvas /> 렌더링
    render();
}

function render() {
    renderer.render(scene, camera);

    requestAnimationFrame(render);
}

function createSphereMesh() {
    const sphere_geometry = new SphereGeometry();
    const sphere_material = new MeshPhongMaterial();
    const sphere_mesh = new Mesh(sphere_geometry, sphere_material);

    scene.add(sphere_mesh);
}

init();
```

<br />

`createSphereMesh()` 함수에서 3가지 객체를 생성하고 있습니다.

이는 컴퓨터 그래픽스에서 3D 물체를 표현하기 위한 요소들 입니다.

* Geometry: 색이 없는 모델링 객체
* Material: 모델링 객체의 색상 또는 질감
* Mesh: Geometry 와 Material 을 합친 결과 모델링 객체

`sphere_mesh` 객체의 `add()` 메소드를 사용하여 **Geometry** 와 **Material** 을 합쳐서 하나의 **Mesh** 를 만들 수 있게 됩니다.

<br />

지금까지 작성한 코드를 실행하면 다음과 같은 결과물을 볼 수 있습니다.

<img src="/markdownAssets/threejs/2023-12-31-01/2023-12-31-01-01.png" alt="Threejs 실행 결과" />



<br />



## 추가: `<canvas />` 를 전체화면으로 설정하기

위 결과물을 확인하면, `<canvas />` 요소가 inline 으로 렌더링되고 있습니다.

이는 **WebGLRenderer** 객체의 **size** 를 조정하여 전체화면으로 설정할 수 있습니다.

그리고 `<canvas />` 의 기본 스타일인 `display: inline` 을 `display: block` 으로 변경합니다.

```css title="style.css" showLineNumbers
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

canvas {
    display: block;
}
```

```js title="main.js" showLineNumbers {11, 33-36}
import {
    WebGLRenderer,
    PerspectiveCamera,
    DirectionalLight,
    Scene,

    SphereGeometry,
    MeshPhongMaterial,
    Mesh,
} from 'three';
import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

/** @type { Scene } */
let scene;

function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    // 2. `WebGLRenderer` 객체 생성
    renderer = new WebGLRenderer({
        canvas: $canvas,
    });
    renderer.setSize(
        window.innerWidth,
        window.innerHeight
    );

    // 3. 카메라 생성
    camera = new PerspectiveCamera();
    camera.position.set(0, 0, 10);

    // 4. 조명 생성
    const light = new DirectionalLight();
    light.position.set(1, 1, 1);

    // 5. `Scene` 객체 생성
    scene = new Scene();
    scene.add(light);

    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용
    renderer.render(scene, camera);

    // 추가: Schene 에 SphereMesh 추가하기
    createSphereMesh();

    // 7. requestAnimationFrame() 을 사용하여 <canvas /> 렌더링
    render();
}

function render() {
    renderer.render(scene, camera);

    requestAnimationFrame(render);
}

function createSphereMesh() {
    const sphere_geometry = new SphereGeometry();
    const sphere_material = new MeshPhongMaterial();
    const sphere_mesh = new Mesh(sphere_geometry, sphere_material);

    scene.add(sphere_mesh);
}

init();
```

<br />

이렇게 적용한 결과는 다음과 같습니다.

<img src="/markdownAssets/threejs/2023-12-31-01/2023-12-31-01-02.png" alt="전체화면 적용" />



<br />



## 추가: 찌그러진 화면 보정하기

Scene 에 추가한 모델링은 구(Sphere) 입니다.

하지만 결과 화면에서 보여지는 구는 타원형으로 보여집니다.

원인은 아래와 같습니다. 

* **카메라의 종횡비(aspect radio)** 설정을 하지 않았으므로, 기본값인 **1** 로 설정됨
* 브라우저의 종횡비가 1:1 이 아닌 상태에서 `<canvas />` 를 전체화면으로 늘리면서 발생하는 화면 늘어짐

<br />

이를 해결하기 위해 **카메라의 종횡비(aspect radio)** 를 설정해줍니다.

```js title="main.js" showLineNumbers {39-42}
import {
    WebGLRenderer,
    PerspectiveCamera,
    DirectionalLight,
    Scene,

    SphereGeometry,
    MeshPhongMaterial,
    Mesh,
} from 'three';
import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

/** @type { Scene } */
let scene;

function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    // 2. `WebGLRenderer` 객체 생성
    renderer = new WebGLRenderer({
        canvas: $canvas,
    });
    renderer.setSize(
        window.innerWidth,
        window.innerHeight
    );

    // 3. 카메라 생성
    camera = new PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight
    );
    camera.position.set(0, 0, 10);

    // 4. 조명 생성
    const light = new DirectionalLight();
    light.position.set(1, 1, 1);

    // 5. `Scene` 객체 생성
    scene = new Scene();
    scene.add(light);

    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용
    renderer.render(scene, camera);

    // 추가: Schene 에 SphereMesh 추가하기
    createSphereMesh();

    // 7. requestAnimationFrame() 을 사용하여 <canvas /> 렌더링
    render();
}

function render() {
    renderer.render(scene, camera);

    requestAnimationFrame(render);
}

function createSphereMesh() {
    const sphere_geometry = new SphereGeometry();
    const sphere_material = new MeshPhongMaterial();
    const sphere_mesh = new Mesh(sphere_geometry, sphere_material);

    scene.add(sphere_mesh);
}

init();
```

<br />

`PerspectiveCamera` 생성자에 인자로 2가지를 넘겨주었습니다.

인자 타입은 다음과 같습니다.

```ts title="Perspective 생성자의 인자"
class PerspectiveCamera {
    constructor(
        fov: number,
        aspect: number
    ) {
        // ...
    }
}
```

**fov (Field of View)** 는 **카메라의 왜곡 정도값**을 말합니다.

이는 **렌즈 배율** 과 **Sensor-size** 에 대한 연산값이며, **화각을 수치화** 한 것입니다.

값이 클수록 멀리서 보는 느낌의 효과가 발생합니다.

<br />

두번째 인자인 **aspect** 는 **카메라 종횡비(aspect ratio)** 에 대한 설정입니다.

화면의 **가로 / 세로** 비율을 나타내므로, `window.innerWidth / window.innerHeight` 로 값을 도출할 수 있습니다.

<br />

이렇게 설정한 결과물은 아래와 같습니다.

<img src="/markdownAssets/threejs/2023-12-31-01/2023-12-31-01-03.png" alt="전체화면 적용" />



<br />



## 추가: **계단 효과** 보정하기

모니터는 Pixel 에 RGB 를 발사하여 화면을 그립니다.

이 Pixel 은 정사각형 모양이기 때문에 곡선을 렌더링하게 되면 마치 계단처럼 각진 곡선으로 표현됩니다.

**WebGLRenderer** 객체를 생성하며 options 를 통해 계단 효과를 보정할 수 있습니다.

<br />

컴퓨터 그래픽스에서 계단 효과를 해소하는 기법을 간단하게 설명하면, 곡선이 아닌 부분을 흐림(blur) 처리하여 마치 자연스러운 곡선처럼 표현해 줍니다.

이러한 기법을 **Anti-Aliasing** 이라고 합니다.

```js title="main.js" showLineNumbers {32}
import {
    WebGLRenderer,
    PerspectiveCamera,
    DirectionalLight,
    Scene,

    SphereGeometry,
    MeshPhongMaterial,
    Mesh,
} from 'three';
import './style.css';

/** @type { WebGLRenderer } */
let renderer;

/** @type { PerspectiveCamera } */
let camera;

/** @type { Scene } */
let scene;

function init() {
    // 1. `<canvas />` 태그 생성
    const $canvas = document.createElement('canvas');

    const $app = document.querySelector('#app');
    $app.appendChild($canvas);

    // 2. `WebGLRenderer` 객체 생성
    renderer = new WebGLRenderer({
        canvas: $canvas,
        antialias: true,
    });
    renderer.setSize(
        window.innerWidth,
        window.innerHeight
    );

    // 3. 카메라 생성
    camera = new PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight
    );
    camera.position.set(0, 0, 10);

    // 4. 조명 생성
    const light = new DirectionalLight();
    light.position.set(1, 1, 1);

    // 5. `Scene` 객체 생성
    scene = new Scene();
    scene.add(light);

    // 6. 위에서 생성한 객체들을 조합하여 WebGLRenderer 에 적용
    renderer.render(scene, camera);

    // 추가: Schene 에 SphereMesh 추가하기
    createSphereMesh();

    // 7. requestAnimationFrame() 을 사용하여 <canvas /> 렌더링
    render();
}

function render() {
    renderer.render(scene, camera);

    requestAnimationFrame(render);
}

function createSphereMesh() {
    const sphere_geometry = new SphereGeometry();
    const sphere_material = new MeshPhongMaterial();
    const sphere_mesh = new Mesh(sphere_geometry, sphere_material);

    scene.add(sphere_mesh);
}

init();
```



## 마치며

Three.js 를 실행하기 위한 최소 구성요소를 구현해 보았습니다.

뭔가 복잡해 보이지만 현실 세계의 무대를 만드는 것과 유사한 개념으로 만들고 있습니다.

* `WebGLRenderer`: 무대를 구성할 건물
* `Scene`: 무대
* `PerspectiveCamera`: 카메라
* `DirectionalLight`: 조명
* `Mesh`: 배경, 배우, 소품

<br />

Three.js 를 처음 시작하며 제가 느낀 어려움으로는 컴퓨터 그래픽스 개념과 카메라에 대한 이해였습니다.

단순히 Three.js 사용법을 익히는 것만으로 원하는 결과물을 얻기는 어려워 보입니다.

지금까지의 코딩에 비해 학습 난이도는 높지만, 새로운 성취감과 즐거움이 기대됩니다.
b:["$","$Lc",null,{"featuredMarkdownFileDataList":[{"category":"jest","slug":"2023-12-17-01","href":"/blog/jest/2023-12-17-01","frontmatter":{"id":1,"title":"\"node:fs\" 테스트 하기","description":"node 모듈중 File System 기능, \"fs\" 를 테스트하는 방법에 대해 정리합니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":true,"tags":["mock-fs","fs","node:fs","jest","@testing-library","유닛 테스트"],"createdAt":"$D2023-12-17T15:33:00.000Z","modifiedHistories":[]},"markdownFile":"$d"},{"category":"threejs","slug":"2024-01-28-01","href":"/blog/threejs/2024-01-28-01","frontmatter":{"id":10,"title":"Gamma, GammFactor, sRGB 정리","description":"디지털 환경에서 색상을 표현하는데 사용되는 일부 개념들을 정리합니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":true,"tags":["threejs","gamma","gamma factor","sRGB"],"createdAt":"$D2024-01-28T18:00:00.000Z","modifiedHistories":[]},"markdownFile":"$e"}],"commonMarkdownFileDataList":[{"category":"javascript","slug":"2023-12-21-01","href":"/blog/javascript/2023-12-21-01","frontmatter":{"id":1,"title":"구조 분해 할당의 기본값 지정, null 은 사용 불가!","description":"구조 분해 할당의 기본값 설정은 Nullish(undefined 와 null) 가 아닌, 오직 undefined 일 때만 적용됩니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["javascript"],"createdAt":"$D2023-12-21T20:20:00.000Z","modifiedHistories":[]},"markdownFile":"$f"},{"category":"javascript","slug":"2023-12-30-01","href":"/blog/javascript/2023-12-30-01","frontmatter":{"id":2,"title":"AWS S3 를 사용한 PDF 뷰어 구현시, Metadata 설정","description":"AWS S3 에 업로드한 PDF 파일이 렌더링되지 않고 다운로드 되는 이슈에 대한 정리 입니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["javascript","PDF","PDF Metadata","AWS","S3"],"createdAt":"$D2023-12-30T16:00:00.000Z","modifiedHistories":[]},"markdownFile":"$10"},{"category":"jest","slug":"2024-01-06-01","href":"/blog/jest/2024-01-06-01","frontmatter":{"id":4,"title":"Nextjs 의 useRouter mock 정의하기","description":"Nextjs 의 useRouter 를 사용하는 컴포넌트를 테스트하기 위한 방법을 정리합니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["jest","@testing-library","useRouter","next-router-mock","유닛 테스트"],"createdAt":"$D2024-01-06T17:30:00.000Z","modifiedHistories":[]},"markdownFile":"$11"},{"category":"jest","slug":"2023-12-26-01","href":"/blog/jest/2023-12-26-01","frontmatter":{"id":3,"title":"\"styled-components\" 로 구현한 컴포넌트 테스트하기","description":"\"styled-components\" 를 사용한 컴포넌트를 테스트하기 위한 환경설정에 대해 알아봅니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["jest","styled-components","@testing-library","유닛 테스트"],"createdAt":"$D2023-12-26T23:50:00.000Z","modifiedHistories":[]},"markdownFile":"$12"},{"category":"jest","slug":"2023-12-23-01","href":"/blog/jest/2023-12-23-01","frontmatter":{"id":2,"title":"\"jest.fn()\" 으로 함수 테스트하기","description":"컴포넌트 props 로 넘겨주는 함수를 테스트하는 방법으로 \"jest.fn()\" 사용방법에 대한 정리 입니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["jest.fn","jest","@testing-library","유닛 테스트"],"createdAt":"$D2023-12-23T14:45:00.000Z","modifiedHistories":[]},"markdownFile":"$13"},{"category":"llmops","slug":"2023-12-16-01","href":"/blog/llmops/2023-12-16-01","frontmatter":{"id":1,"title":"LLMOps 와 친해지기 1 - 용어 정리","description":"AI 학습 모델인 Large Language Model 에 대한 정리입니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":[],"createdAt":"$D2023-12-16T15:00:00.000Z","modifiedHistories":[]},"markdownFile":"$14"},{"category":"nextjs","slug":"2024-01-01-01","href":"/blog/nextjs/2024-01-01-01","frontmatter":{"id":2,"title":".DS_Store not found 에러","description":"Nextjs 빌드 시, .DS_Store 파일을 찾을 수 없다는 에러를 마주하게 되었습니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["nextjs",".DS_Store"],"createdAt":"$D2024-01-01T15:20:00.000Z","modifiedHistories":[]},"markdownFile":"---\nid: 2\ntitle: .DS_Store not found 에러\ndescription: 'Nextjs 빌드 시, .DS_Store 파일을 찾을 수 없다는 에러를 마주하게 되었습니다.'\nthumbnail: https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg\n\nfeatured: false\ntags: [\n    'nextjs',\n    '.DS_Store',\n]\n\ncreatedAt: '2024-01-01 15:20:00'\nmodifiedHistories: []\n---\n\n# .DS_Store not found 에러\n\nNextjs 프로젝트에 이미지 파일을 추가하고 삭제한 후, 빌드 에러가 발생하였습니다.\n\n> Error: ENOENT: no such file or directory, open '/.../.DS_Store\n\n\n\n<br />\n\n\n\n## 에러 원인 파악\n\n.DS_Store 는 맥북의 폴더 관련 메타데이터 파일이며, Finder 로 폴더에 접근하게 되면 자동으로 생성됩니다.\n\n문제는 Nextjs 프로젝트를 개발 환경으로 실행하거나 빌드할 때, .DS_Store 파일이 추가되면, 빌드 에러가 발생합니다.\n\n\n\n\n<br />\n\n\n\n## 해결 방법\n\n* 참고: [Stack Overflow](https://github.com/vercel/next.js/discussions/15573#discussioncomment-2415012)\n\n<br />\n\nNextjs 프로젝트 하위에 존재하는 .DS_Store 파일을 모두 삭제하는 것으로 해결할 수 있었습니다.\n\n모든 폴더를 직접 열어보면서 지우는 방법도 있겠지만, 터미널을 사용하여 삭제 명령으로 처리할 수 있습니다.\n\n```bash title=\"프로젝트 내의 모든 .DS_Store 파일 삭제\"\nrm **/.DS_Store\n```\n\n<br />\n\n삭제 명령이 실행 완료되면, Nextjs 프로젝트가 정상적으로 빌드되는 것을 확인할 수 있습니다.\n"},{"category":"nextjs","slug":"2023-12-16-01","href":"/blog/nextjs/2023-12-16-01","frontmatter":{"id":1,"title":"Nextjs 프로젝트의 유닛 테스트","description":"유닛 테스트를 위해 Jest 와 @testing-library 설치 및 설정에 대한 정리 입니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["nextjs","jest","@testing-library","react","유닛 테스트"],"createdAt":"$D2023-12-16T22:13:00.000Z","modifiedHistories":[]},"markdownFile":"$15"},{"category":"react","slug":"2023-12-19-01","href":"/blog/react/2023-12-19-01","frontmatter":{"id":1,"title":"Custom Hook 으로 분리하며 발생한 실수","description":"Custom Hook 으로 분리한 useEffect 가 여러번 호출 케이스 중 한가지를 정리합니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["react","custom hook"],"createdAt":"$D2023-12-19T22:50:00.000Z","modifiedHistories":[]},"markdownFile":"$16"},{"category":"threejs","slug":"2024-02-03-02","href":"/blog/threejs/2024-02-03-02","frontmatter":{"id":13,"title":"Model 에 Click Event 적용하기 (추가: ToneMapping, light.shadow.camera)","description":"Canvas 에 렌더링된 Model 에 Click 인터렉션을 적용 해봅니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["threejs","3D","mouse event","click interaction"],"createdAt":"$D2024-02-03T16:00:00.000Z","modifiedHistories":[]},"markdownFile":"$17"},{"category":"threejs","slug":"2024-02-03-01","href":"/blog/threejs/2024-02-03-01","frontmatter":{"id":13,"title":"(Issue) 조명이 어둡게 보이는 현상","description":"강좌의 결과물에 비해 실습 결과물의 밝기가 어둡게 렌더링되는 현상이 발생하였습니다. 현상 원인과 해결 방법에 대해 정리하고자 합니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["threejs","3D","DirectionalLgith","HemisphereLight","intensity"],"createdAt":"$D2024-02-03T14:00:00.000Z","modifiedHistories":[]},"markdownFile":"$18"},{"category":"threejs","slug":"2024-01-30-01","href":"/blog/threejs/2024-01-30-01","frontmatter":{"id":12,"title":"키보드를 사용하여 카메라 이동 인터렉션 만들기","description":"키보드 입력에 대한 event listener 를 사용하여 카메라를 이동할 수 있는 인터렉션을 구현해 봅니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["threejs","3D","keyboard event","camera","interaction"],"createdAt":"$D2024-01-30T18:00:00.000Z","modifiedHistories":[]},"markdownFile":"$19"},{"category":"threejs","slug":"2024-01-28-02","href":"/blog/threejs/2024-01-28-02","frontmatter":{"id":11,"title":"canvas 크기 설정 및 material 렌더링 side 설정","description":"사용자 모니터 대응을 위한 WebGLRenderer 설정과 material 의 렌더링 side 설정에 대해 정리합니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["threejs","setSize()","setPixelRatio()","material","FrontSide","BackSide","DoubleSide"],"createdAt":"$D2024-01-28T23:00:00.000Z","modifiedHistories":[]},"markdownFile":"$1a"},{"category":"threejs","slug":"2024-01-26-01","href":"/blog/threejs/2024-01-26-01","frontmatter":{"id":9,"title":"Model 에 Animation 효과 적용하기","description":"Model 파일인 .gltf, .glb 에 Animation 을 적용하는 방법에 대해 정리합니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["threejs","javascript","3d",".gltf",".glb","model","animation"],"createdAt":"$D2024-01-26T20:00:00.000Z","modifiedHistories":[]},"markdownFile":"$1b"},{"category":"threejs","slug":"2024-01-21-01","href":"/blog/threejs/2024-01-21-01","frontmatter":{"id":8,"title":"Model (.gltf, .glb) 객체 구조파악 및 그림자 적용","description":"Three.js 환경에 불러온 Model 객체의 주요 구성요소를 파악하고, 속성값을 변경하여 그림자를 만들어 봅니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["threejs","javascript","3d",".gltf",".glb","model","traverse","shadow"],"createdAt":"$D2024-01-21T16:00:00.000Z","modifiedHistories":[]},"markdownFile":"$1c"},{"category":"threejs","slug":"2024-01-10-01","href":"/blog/threejs/2024-01-10-01","frontmatter":{"id":7,"title":"모델 파일을 Three.js 에 렌더링하기","description":".gltf 또는 .glb 확장자인 모델 파일을 Three.js 에 불러오고 렌더링하는 방법을 정리합니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["threejs","javascript","3d","hdr",".gltf",".glb","model"],"createdAt":"$D2024-01-10T23:50:00.000Z","modifiedHistories":[]},"markdownFile":"$1d"},{"category":"threejs","slug":"2024-01-08-01","href":"/blog/threejs/2024-01-08-01","frontmatter":{"id":6,"title":"배경화면 및 환경조명 설정하기","description":"360도 이미지 확장자인 .hdr 파일을 사용하여 배경화면을 설정하고, 배경화면에 의한 환경조명 설정에 대한 정리입니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["threejs","javascript","3d","hdr","background","3D 배경화면","환경조명"],"createdAt":"$D2024-01-08T23:50:00.000Z","modifiedHistories":[]},"markdownFile":"$1e"},{"category":"threejs","slug":"2024-01-07-02","href":"/blog/threejs/2024-01-07-02","frontmatter":{"id":5,"title":"그림자 표현하기","description":"그림자 설정방법과 특징에 대해 정리합니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["threejs","javascript","3d","shadow"],"createdAt":"$D2024-01-07T23:50:00.000Z","modifiedHistories":[]},"markdownFile":"$1f"},{"category":"threejs","slug":"2024-01-07-01","href":"/blog/threejs/2024-01-07-01","frontmatter":{"id":4,"title":"평평한 바닥(땅) 만들기 (Plane Mesh)","description":"바닥을 표현하기 위해 Plane Mesh 를 생성합니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["threejs","javascript","3d","plane"],"createdAt":"$D2024-01-07T23:20:00.000Z","modifiedHistories":[]},"markdownFile":"$20"},{"category":"threejs","slug":"2024-01-06-01","href":"/blog/threejs/2024-01-06-01","frontmatter":{"id":3,"title":"조명 종류와 설정","description":"조명 종류와 설정 방법에 대해 정리합니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["threejs","javascript","3d","light"],"createdAt":"$D2024-01-06T23:00:00.000Z","modifiedHistories":[]},"markdownFile":"$21"},{"category":"threejs","slug":"2024-01-01-01","href":"/blog/threejs/2024-01-01-01","frontmatter":{"id":2,"title":"카메라 설정 (PerspectiveCamera)","description":"Three.js 의 카메라인 PerspectiveCamera 설정에 대한 포스팅입니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["threejs","javascript","3d","camera"],"createdAt":"$D2024-01-01T23:50:00.000Z","modifiedHistories":[]},"markdownFile":"$22"},{"category":"threejs","slug":"2023-12-31-01","href":"/blog/threejs/2023-12-31-01","frontmatter":{"id":1,"title":"Three.js 설치 및 실행","description":"Three.js 를 사용하기 위한 설치와 첫번째 화면을 그려봅니다.","thumbnail":"https://image.dongascience.com/Photo/2020/03/5bddba7b6574b95d37b6079c199d7101.jpg","featured":false,"tags":["threejs","javascript","3d"],"createdAt":"$D2023-12-31T22:47:00.000Z","modifiedHistories":[]},"markdownFile":"$23"}]}]
